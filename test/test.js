(function(f){typeof define==='function'&&define.amd?define(f):f();}((function(){'use strict';function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}function _typeof$1(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$1(obj);
}

var REGEX_LEN_VAL = /^\d+(?:[a-z]|\%)+$/i;
var REGEX_DIGITS = /\d+$/;
var REGEX_SPACE = /\s/;
var REGEX_KEBAB = /([A-Z])+/g;
var IMPORTANT = 'important';
var POSSIBLE_PREFIXES = ['webkit', 'moz', 'ms', 'o'];
var REQUIRES_UNIT_VALUE = ['background-position-x', 'background-position-y', 'block-size', 'border-width', 'columnRule-width', 'cx', 'cy', 'font-size', 'grid-column-gap', 'grid-row-gap', 'height', 'inline-size', 'line-height', 'minBlock-size', 'min-height', 'min-inline-size', 'min-width', 'max-height', 'max-width', 'outline-offset', 'outline-width', 'perspective', 'shape-margin', 'stroke-dashoffset', 'stroke-width', 'text-indent', 'width', 'word-spacing', 'top', 'bottom', 'left', 'right', 'x', 'y'];
var QUAD_SHORTHANDS = ['margin', 'padding', 'border', 'border-radius'];
var DIRECTIONS = ['top', 'bottom', 'left', 'right'];
QUAD_SHORTHANDS.forEach(function (property) {
  var direction, i, len;
  REQUIRES_UNIT_VALUE.push(property);

  for (i = 0, len = DIRECTIONS.length; i < len; i++) {
    direction = DIRECTIONS[i];
    REQUIRES_UNIT_VALUE.push(property + '-' + direction);
  }
});
var SAMPLE_STYLE, styleConfig;
SAMPLE_STYLE = document.createElement('div').style;

var includes = function includes(target, item) {
  return target && target.indexOf(item) !== -1;
};

var isIterable = function isIterable(target) {
  return target && _typeof$1(target) === 'object' && typeof target.length === 'number' && !target.nodeType;
};

var toKebabCase = function toKebabCase(string) {
  return string.replace(REGEX_KEBAB, function (e, letter) {
    return "-".concat(letter.toLowerCase());
  });
};

var isPropSupported = function isPropSupported(property) {
  return typeof SAMPLE_STYLE[property] !== 'undefined';
};

var isValueSupported = function isValueSupported(property, value) {
  if (window.CSS && window.CSS.supports) {
    return window.CSS.supports(property, value);
  } else {
    SAMPLE_STYLE[property] = value;
    return SAMPLE_STYLE[property] === '' + value;
  }
};

var getPrefix = function getPrefix(property, skipInitialCheck) {
  var j, len1, prefix;

  if (skipInitialCheck || !isPropSupported(property)) {
    for (j = 0, len1 = POSSIBLE_PREFIXES.length; j < len1; j++) {
      prefix = POSSIBLE_PREFIXES[j];

      if (isPropSupported("-".concat(prefix, "-").concat(property))) {
        /* istanbul ignore next */
        return "-".concat(prefix, "-");
      }
    }
  }

  return '';
};

var normalizeProperty = function normalizeProperty(property) {
  property = toKebabCase(property);

  if (isPropSupported(property)) {
    return property;
  } else {
    return "".concat(getPrefix(property, true)).concat(property);
  }
};

var normalizeValue = function normalizeValue(property, value) {
  if (includes(REQUIRES_UNIT_VALUE, property) && value !== null) {
    value = '' + value;

    if (REGEX_DIGITS.test(value) && !REGEX_LEN_VAL.test(value) && !REGEX_SPACE.test(value)) {
      value += property === 'line-height' ? 'em' : 'px';
    }
  }

  return value;
};

var sort = function sort(array) {
  var great, i, len, less, pivot;

  if (array.length < 2) {
    return array;
  } else {
    pivot = array[0];
    less = [];
    great = [];
    len = array.length;
    i = 0;

    while (++i !== len) {
      if (array[i] <= pivot) {
        less.push(array[i]);
      } else {
        great.push(array[i]);
      }
    }

    return sort(less).concat(pivot, sort(great));
  }
};

var hash = function hash(string) {
  var hsh, i, length;
  hsh = 5381;
  i = -1;
  length = string.length;

  while (++i !== string.length) {
    hsh = (hsh << 5) - hsh + string.charCodeAt(i);
    hsh |= 0;
  }

  return '_' + (hsh < 0 ? hsh * -2 : hsh);
};

var ruleToString = function ruleToString(rule, important) {
  var j, len1, output, prop, property, props, value;
  output = '';
  props = sort(Object.keys(rule));

  for (j = 0, len1 = props.length; j < len1; j++) {
    prop = props[j];

    if (typeof rule[prop] === 'string' || typeof rule[prop] === 'number') {
      property = normalizeProperty(prop);
      value = normalizeValue(property, rule[prop]);

      if (important) {
        value += " !important";
      }

      output += "".concat(property, ":").concat(value, ";");
    }
  }

  return output;
};

var inlineStyleConfig = styleConfig = Object.create(null);

var inlineStyle = function inlineStyle(rule, valueToStore, level) {
  var config, styleEl;

  if (!(config = styleConfig[level])) {
    styleEl = document.createElement('style');
    styleEl.id = "quickcss".concat(level || '');
    document.head.appendChild(styleEl);
    styleConfig[level] = config = {
      el: styleEl,
      content: '',
      cache: Object.create(null)
    };
  }

  if (!config.cache[rule]) {
    config.cache[rule] = valueToStore || true;
    config.el.textContent = config.content += rule;
  }
};

var clearInlineStyle = function clearInlineStyle(level) {
  var config, j, key, keys, len1;

  if (config = styleConfig[level]) {
    if (!config.content) {
      return;
    }

    config.el.textContent = config.content = '';
    keys = Object.keys(config.cache);

    for (j = 0, len1 = keys.length; j < len1; j++) {
      key = keys[j];
      config.cache[key] = null;
    }
  }
};

var version = "1.4.4";

var _quickcss;

var index = _quickcss = function quickcss(targetEl, property, value, important) {
  var computedStyle, i, len, subEl, subProperty, subValue;

  switch (false) {
    case !isIterable(targetEl):
      for (i = 0, len = targetEl.length; i < len; i++) {
        subEl = targetEl[i];

        _quickcss(subEl, property, value);
      }

      break;

    case _typeof$1(property) !== 'object':
      // Passed a style map
      for (subProperty in property) {
        subValue = property[subProperty];

        _quickcss(targetEl, subProperty, subValue);
      }

      break;

    default:
      property = normalizeProperty(property);

      if (typeof value === 'undefined') {
        computedStyle = targetEl._computedStyle || (targetEl._computedStyle = getComputedStyle(targetEl));
        return computedStyle[property];
      } else if (property) {
        targetEl.style.setProperty(property, normalizeValue(property, value), important ? IMPORTANT : null);
      }

  }
};

_quickcss.animation = function (name, frames) {
  var frame, generated, prefix, rules;

  if (name && typeof name === 'string' && frames && _typeof$1(frames) === 'object') {
    prefix = getPrefix('animation');
    generated = '';

    for (frame in frames) {
      rules = frames[frame];
      generated += "".concat(frame, " {").concat(ruleToString(rules), "}");
    }

    generated = "@".concat(prefix, "keyframes ").concat(name, " {").concat(generated, "}");
    return inlineStyle(generated, true, 0);
  }
};

_quickcss.register = function (rule, level, important) {
  var className, ref, style;

  if (rule && _typeof$1(rule) === 'object') {
    level || (level = 0);
    rule = ruleToString(rule, important);

    if (!(className = (ref = inlineStyleConfig[level]) != null ? ref[rule] : void 0)) {
      className = hash(rule);
      style = ".".concat(className, " {").concat(rule, "}");
      inlineStyle(style, className, level);
    }

    return className;
  }
};

_quickcss.clearRegistered = function (level) {
  return clearInlineStyle(level || 0);
};
/* istanbul ignore next */


_quickcss.UNSET = function () {
  switch (false) {
    case !isValueSupported('display', 'unset'):
      return 'unset';

    case !isValueSupported('display', 'initial'):
      return 'initial';

    case !isValueSupported('display', 'inherit'):
      return 'inherit';
  }
}();

_quickcss.supports = isValueSupported;
_quickcss.supportsProperty = isPropSupported;
_quickcss.normalizeProperty = normalizeProperty;
_quickcss.normalizeValue = normalizeValue;
_quickcss.version = version;var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */
function exclude() {
  var excludes = [].slice.call(arguments);

  function excludeProps(res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude() {
    var args = [].slice.call(arguments),
        i = 0,
        res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
}
/*!
 * Primary Exports
 */

var assertionError = AssertionError;
/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError(message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON'),
      props = extend(_props || {}); // default values

  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false; // copy from properties

  for (var key in props) {
    this[key] = props[key];
  } // capture stack trace


  ssf = ssf || AssertionError;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    try {
      throw new Error();
    } catch (e) {
      this.stack = e.stack;
    }
  }
}
/*!
 * Inherit from Error.prototype
 */


AssertionError.prototype = Object.create(Error.prototype);
/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';
/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;
/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack'),
      props = extend({
    name: this.name
  }, this); // include stack if exists and not turned off

  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};/* !
 * Chai - pathval utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has own
 * or inherited from prototype chain named property.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with null/undefined values
 * and other primitives.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(obj, 'str');  // true
 *     hasProperty(obj, 'constructor');  // true
 *     hasProperty(obj, 'bar');  // false
 *
 *     hasProperty(obj.str, 'length'); // true
 *     hasProperty(obj.str, 1);  // true
 *     hasProperty(obj.str, 5);  // false
 *
 *     hasProperty(obj.arr, 'length');  // true
 *     hasProperty(obj.arr, 2);  // true
 *     hasProperty(obj.arr, 3);  // false
 *
 * @param {Object} object
 * @param {String|Symbol} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name hasProperty
 * @api public
 */

function hasProperty(obj, name) {
  if (typeof obj === 'undefined' || obj === null) {
    return false;
  } // The `in` operator does not work with primitives.


  return name in Object(obj);
}
/* !
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `internalGetPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be infinitely deep and nested.
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */


function parsePath(path) {
  var str = path.replace(/([^\\])\[/g, '$1.[');
  var parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function mapMatches(value) {
    var regexp = /^\[(\d+)\]$/;
    var mArr = regexp.exec(value);
    var parsed = null;

    if (mArr) {
      parsed = {
        i: parseFloat(mArr[1])
      };
    } else {
      parsed = {
        p: value.replace(/\\([.\[\]])/g, '$1')
      };
    }

    return parsed;
  });
}
/* !
 * ## internalGetPathValue(obj, parsed[, pathDepth])
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(obj, parsed);
 *
 * @param {Object} object to search against
 * @param {Object} parsed definition from `parsePath`.
 * @param {Number} depth (nesting level) of the property we want to retrieve
 * @returns {Object|Undefined} value
 * @api private
 */


function internalGetPathValue(obj, parsed, pathDepth) {
  var temporaryValue = obj;
  var res = null;
  pathDepth = typeof pathDepth === 'undefined' ? parsed.length : pathDepth;

  for (var i = 0; i < pathDepth; i++) {
    var part = parsed[i];

    if (temporaryValue) {
      if (typeof part.p === 'undefined') {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }

      if (i === pathDepth - 1) {
        res = temporaryValue;
      }
    }
  }

  return res;
}
/* !
 * ## internalSetPathValue(obj, value, parsed)
 *
 * Companion function for `parsePath` that sets
 * the value located at a parsed address.
 *
 *  internalSetPathValue(obj, 'value', parsed);
 *
 * @param {Object} object to search and define on
 * @param {*} value to use upon set
 * @param {Object} parsed definition from `parsePath`
 * @api private
 */


function internalSetPathValue(obj, val, parsed) {
  var tempObj = obj;
  var pathDepth = parsed.length;
  var part = null; // Here we iterate through every part of the path

  for (var i = 0; i < pathDepth; i++) {
    var propName = null;
    var propVal = null;
    part = parsed[i]; // If it's the last part of the path, we set the 'propName' value with the property name

    if (i === pathDepth - 1) {
      propName = typeof part.p === 'undefined' ? part.i : part.p; // Now we set the property with the name held by 'propName' on object with the desired val

      tempObj[propName] = val;
    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
      tempObj = tempObj[part.p];
    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
      tempObj = tempObj[part.i];
    } else {
      // If the obj doesn't have the property we create one with that name to define it
      var next = parsed[i + 1]; // Here we set the name of the property which will be defined

      propName = typeof part.p === 'undefined' ? part.i : part.p; // Here we decide if this property will be an array or a new object

      propVal = typeof next.p === 'undefined' ? [] : {};
      tempObj[propName] = propVal;
      tempObj = tempObj[propName];
    }
  }
}
/**
 * ### .getPathInfo(object, path)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */


function getPathInfo(obj, path) {
  var parsed = parsePath(path);
  var last = parsed[parsed.length - 1];
  var info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  info.exists = hasProperty(info.parent, info.name);
  return info;
}
/**
 * ### .getPathValue(object, path)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(obj, 'prop1.str'); // Hello
 *     getPathValue(obj, 'prop1.att[2]'); // b
 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */


function getPathValue(obj, path) {
  var info = getPathInfo(obj, path);
  return info.value;
}
/**
 * ### .setPathValue(object, path, value)
 *
 * Define the value in an object at a given string path.
 *
 * ```js
 * var obj = {
 *     prop1: {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *   , prop2: {
 *         arr: [ { nested: 'Universe' } ]
 *       , str: 'Hello again!'
 *     }
 * };
 * ```
 *
 * The following would be acceptable.
 *
 * ```js
 * var properties = require('tea-properties');
 * properties.set(obj, 'prop1.str', 'Hello Universe!');
 * properties.set(obj, 'prop1.arr[2]', 'B');
 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
 * ```
 *
 * @param {Object} object
 * @param {String} path
 * @param {Mixed} value
 * @api private
 */


function setPathValue(obj, path, val) {
  var parsed = parsePath(path);
  internalSetPathValue(obj, val, parsed);
  return obj;
}

var pathval = {
  hasProperty: hasProperty,
  getPathInfo: getPathInfo,
  getPathValue: getPathValue,
  setPathValue: setPathValue
};/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */
var flag = function flag(obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));

  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

var test$1 = function test(obj, args) {
  var negate = flag(obj, 'negate'),
      expr = args[0];
  return negate ? !expr : expr;
};var typeDetect = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
     module.exports = factory() ;
  })(commonjsGlobal, function () {
    /* !
     * type-detect
     * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    var promiseExists = typeof Promise === 'function';
    /* eslint-disable no-undef */

    var globalObject = typeof self === 'object' ? self : commonjsGlobal; // eslint-disable-line id-blacklist

    var symbolExists = typeof Symbol !== 'undefined';
    var mapExists = typeof Map !== 'undefined';
    var setExists = typeof Set !== 'undefined';
    var weakMapExists = typeof WeakMap !== 'undefined';
    var weakSetExists = typeof WeakSet !== 'undefined';
    var dataViewExists = typeof DataView !== 'undefined';
    var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
    var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
    var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
    var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
    var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
    var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
    var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
    var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
    var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
    var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
    var toStringLeftSliceLength = 8;
    var toStringRightSliceLength = -1;
    /**
     * ### typeOf (obj)
     *
     * Uses `Object.prototype.toString` to determine the type of an object,
     * normalising behaviour across engine versions & well optimised.
     *
     * @param {Mixed} object
     * @return {String} object type
     * @api public
     */

    function typeDetect(obj) {
      /* ! Speed optimisation
       * Pre:
       *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
       *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
       *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
       *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
       *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
       * Post:
       *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
       *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
       *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
       *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
       *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
       */
      var typeofObj = typeof obj;

      if (typeofObj !== 'object') {
        return typeofObj;
      }
      /* ! Speed optimisation
       * Pre:
       *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
       * Post:
       *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
       */


      if (obj === null) {
        return 'null';
      }
      /* ! Spec Conformance
       * Test: `Object.prototype.toString.call(window)``
       *  - Node === "[object global]"
       *  - Chrome === "[object global]"
       *  - Firefox === "[object Window]"
       *  - PhantomJS === "[object Window]"
       *  - Safari === "[object Window]"
       *  - IE 11 === "[object Window]"
       *  - IE Edge === "[object Window]"
       * Test: `Object.prototype.toString.call(this)``
       *  - Chrome Worker === "[object global]"
       *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
       *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
       *  - IE 11 Worker === "[object WorkerGlobalScope]"
       *  - IE Edge Worker === "[object WorkerGlobalScope]"
       */


      if (obj === globalObject) {
        return 'global';
      }
      /* ! Speed optimisation
       * Pre:
       *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
       * Post:
       *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
       */


      if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
        return 'Array';
      } // Not caching existence of `window` and related properties due to potential
      // for `window` to be unset before tests in quasi-browser environments.


      if (typeof window === 'object' && window !== null) {
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/browsers.html#location)
         * WhatWG HTML$7.7.3 - The `Location` interface
         * Test: `Object.prototype.toString.call(window.location)``
         *  - IE <=11 === "[object Object]"
         *  - IE Edge <=13 === "[object Object]"
         */
        if (typeof window.location === 'object' && obj === window.location) {
          return 'Location';
        }
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#document)
         * WhatWG HTML$3.1.1 - The `Document` object
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         *       WhatWG HTML states:
         *         > For historical reasons, Window objects must also have a
         *         > writable, configurable, non-enumerable property named
         *         > HTMLDocument whose value is the Document interface object.
         * Test: `Object.prototype.toString.call(document)``
         *  - Chrome === "[object HTMLDocument]"
         *  - Firefox === "[object HTMLDocument]"
         *  - Safari === "[object HTMLDocument]"
         *  - IE <=10 === "[object Document]"
         *  - IE 11 === "[object HTMLDocument]"
         *  - IE Edge <=13 === "[object HTMLDocument]"
         */


        if (typeof window.document === 'object' && obj === window.document) {
          return 'Document';
        }

        if (typeof window.navigator === 'object') {
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
           * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
           *  - IE <=10 === "[object MSMimeTypesCollection]"
           */
          if (typeof window.navigator.mimeTypes === 'object' && obj === window.navigator.mimeTypes) {
            return 'MimeTypeArray';
          }
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
           * Test: `Object.prototype.toString.call(navigator.plugins)``
           *  - IE <=10 === "[object MSPluginsCollection]"
           */


          if (typeof window.navigator.plugins === 'object' && obj === window.navigator.plugins) {
            return 'PluginArray';
          }
        }

        if ((typeof window.HTMLElement === 'function' || typeof window.HTMLElement === 'object') && obj instanceof window.HTMLElement) {
          /* ! Spec Conformance
          * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
          * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
          * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
          *  - IE <=10 === "[object HTMLBlockElement]"
          */
          if (obj.tagName === 'BLOCKQUOTE') {
            return 'HTMLQuoteElement';
          }
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltabledatacellelement)
           * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('td'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */


          if (obj.tagName === 'TD') {
            return 'HTMLTableDataCellElement';
          }
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltableheadercellelement)
           * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('th'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */


          if (obj.tagName === 'TH') {
            return 'HTMLTableHeaderCellElement';
          }
        }
      }
      /* ! Speed optimisation
      * Pre:
      *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
      *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
      *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
      *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
      *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
      *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
      *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
      *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
      *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
      * Post:
      *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
      *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
      *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
      *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
      *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
      *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
      *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
      *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
      *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
      */


      var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];

      if (typeof stringTag === 'string') {
        return stringTag;
      }

      var objPrototype = Object.getPrototypeOf(obj);
      /* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
      */

      if (objPrototype === RegExp.prototype) {
        return 'RegExp';
      }
      /* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
      */


      if (objPrototype === Date.prototype) {
        return 'Date';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: `Object.prototype.toString.call(Promise.resolve())``
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */


      if (promiseExists && objPrototype === Promise.prototype) {
        return 'Promise';
      }
      /* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
      */


      if (setExists && objPrototype === Set.prototype) {
        return 'Set';
      }
      /* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
      */


      if (mapExists && objPrototype === Map.prototype) {
        return 'Map';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
      */


      if (weakSetExists && objPrototype === WeakSet.prototype) {
        return 'WeakSet';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
      */


      if (weakMapExists && objPrototype === WeakMap.prototype) {
        return 'WeakMap';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
       *  - Edge <=13 === "[object Object]"
       */


      if (dataViewExists && objPrototype === DataView.prototype) {
        return 'DataView';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: `Object.prototype.toString.call(new Map().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (mapExists && objPrototype === mapIteratorPrototype) {
        return 'Map Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: `Object.prototype.toString.call(new Set().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (setExists && objPrototype === setIteratorPrototype) {
        return 'Set Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
        return 'Array Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
        return 'String Iterator';
      }
      /* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
      */


      if (objPrototype === null) {
        return 'Object';
      }

      return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
    }

    return typeDetect;
  });
});/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */

var expectTypes = function expectTypes(obj, types) {
  var flagMsg = flag(obj, 'message');
  var ssfi = flag(obj, 'ssfi');
  flagMsg = flagMsg ? flagMsg + ': ' : '';
  obj = flag(obj, 'object');
  types = types.map(function (t) {
    return t.toLowerCase();
  });
  types.sort(); // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'

  var str = types.map(function (t, index) {
    var art = ~['a', 'e', 'i', 'o', 'u'].indexOf(t.charAt(0)) ? 'an' : 'a';
    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
    return or + art + ' ' + t;
  }).join(', ');
  var objType = typeDetect(obj).toLowerCase();

  if (!types.some(function (expected) {
    return objType === expected;
  })) {
    throw new assertionError(flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given', undefined, ssfi);
  }
};/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */
var getActual = function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};/* !
 * Chai - getFuncName utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getFuncName(constructorFn)
 *
 * Returns the name of a function.
 * When a non-function instance is passed, returns `null`.
 * This also includes a polyfill function if `aFunc.name` is not defined.
 *
 * @name getFuncName
 * @param {Function} funct
 * @namespace Utils
 * @api public
 */

var toString = Function.prototype.toString;
var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;

function getFuncName(aFunc) {
  if (typeof aFunc !== 'function') {
    return null;
  }

  var name = '';

  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
    var match = toString.call(aFunc).match(functionNameMatch);

    if (match) {
      name = match[1];
    }
  } else {
    // If we've got a `name` property we just use it
    name = aFunc.name;
  }

  return name;
}

var getFuncName_1 = getFuncName;/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */
var getProperties = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);

  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */
var getEnumerableProperties = function getEnumerableProperties(object) {
  var result = [];

  for (var name in object) {
    result.push(name);
  }

  return result;
};var config = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */
  includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */
  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */
  truncateThreshold: 40,

  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {Boolean}
   * @api public
   */
  useProxy: true,

  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @api public
   */
  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']
};var inspect_1 = createCommonjsModule(function (module, exports) {
  // This is (almost) directly from Node.js utils
  // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js
  module.exports = inspect;
  /**
   * ### .inspect(obj, [showHidden], [depth], [colors])
   *
   * Echoes the value of a value. Tries to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
   *    properties of objects. Default is false.
   * @param {Number} depth Depth in which to descend in object. Default is 2.
   * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
   *    output. Default is false (no coloring).
   * @namespace Utils
   * @name inspect
   */

  function inspect(obj, showHidden, depth, colors) {
    var ctx = {
      showHidden: showHidden,
      seen: [],
      stylize: function (str) {
        return str;
      }
    };
    return formatValue(ctx, obj, typeof depth === 'undefined' ? 2 : depth);
  } // Returns true if object is a DOM element.


  var isDOMElement = function (object) {
    if (typeof HTMLElement === 'object') {
      return object instanceof HTMLElement;
    } else {
      return object && typeof object === 'object' && 'nodeType' in object && object.nodeType === 1 && typeof object.nodeName === 'string';
    }
  };

  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);

      if (typeof ret !== 'string') {
        ret = formatValue(ctx, ret, recurseTimes);
      }

      return ret;
    } // Primitive types cannot have properties


    var primitive = formatPrimitive(ctx, value);

    if (primitive) {
      return primitive;
    } // If this is a DOM element, try to get the outer HTML.


    if (isDOMElement(value)) {
      if ('outerHTML' in value) {
        return value.outerHTML; // This value does not have an outerHTML attribute,
        //   it could still be an XML element
      } else {
        // Attempt to serialize it
        try {
          if (document.xmlVersion) {
            var xmlSerializer = new XMLSerializer();
            return xmlSerializer.serializeToString(value);
          } else {
            // Firefox 11- do not support outerHTML
            //   It does, however, support innerHTML
            //   Use the following to render the element
            var ns = "http://www.w3.org/1999/xhtml";
            var container = document.createElementNS(ns, '_');
            container.appendChild(value.cloneNode(false));
            var html = container.innerHTML.replace('><', '>' + value.innerHTML + '<');
            container.innerHTML = '';
            return html;
          }
        } catch (err) {// This could be a non-native DOM implementation,
          //   continue with the normal flow:
          //   printing the element as if it is an object.
        }
      }
    } // Look up the keys of the object.


    var visibleKeys = getEnumerableProperties(value);
    var keys = ctx.showHidden ? getProperties(value) : visibleKeys;
    var name, nameSuffix; // Some type of object without properties can be shortcut.
    // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
    // a `stack` plus `description` property; ignore those for consistency.

    if (keys.length === 0 || isError(value) && (keys.length === 1 && keys[0] === 'stack' || keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')) {
      if (typeof value === 'function') {
        name = getFuncName_1(value);
        nameSuffix = name ? ': ' + name : '';
        return ctx.stylize('[Function' + nameSuffix + ']', 'special');
      }

      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }

      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
      }

      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '',
        array = false,
        typedArray = false,
        braces = ['{', '}'];

    if (isTypedArray(value)) {
      typedArray = true;
      braces = ['[', ']'];
    } // Make Array say that they are Array


    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    } // Make functions say that they are functions


    if (typeof value === 'function') {
      name = getFuncName_1(value);
      nameSuffix = name ? ': ' + name : '';
      base = ' [Function' + nameSuffix + ']';
    } // Make RegExps say that they are RegExps


    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    } // Make dates with properties first say the date


    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    } // Make error with message first say the error


    if (isError(value)) {
      return formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);
    var output;

    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else if (typedArray) {
      return formatTypedArray(value);
    } else {
      output = keys.map(function (key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }

  function formatPrimitive(ctx, value) {
    switch (typeof value) {
      case 'undefined':
        return ctx.stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');

      case 'number':
        if (value === 0 && 1 / value === -Infinity) {
          return ctx.stylize('-0', 'number');
        }

        return ctx.stylize('' + value, 'number');

      case 'boolean':
        return ctx.stylize('' + value, 'boolean');

      case 'symbol':
        return ctx.stylize(value.toString(), 'symbol');
    } // For some reason typeof null is "object", so special case here.


    if (value === null) {
      return ctx.stylize('null', 'null');
    }
  }

  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }

  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];

    for (var i = 0, l = value.length; i < l; ++i) {
      if (Object.prototype.hasOwnProperty.call(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push('');
      }
    }

    keys.forEach(function (key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }

  function formatTypedArray(value) {
    var str = '[ ';

    for (var i = 0; i < value.length; ++i) {
      if (str.length >= config.truncateThreshold - 7) {
        str += '...';
        break;
      }

      str += value[i] + ', ';
    }

    str += ' ]'; // Removing trailing `, ` if the array was not truncated

    if (str.indexOf(',  ]') !== -1) {
      str = str.replace(',  ]', ' ]');
    }

    return str;
  }

  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name;
    var propDescriptor = Object.getOwnPropertyDescriptor(value, key);
    var str;

    if (propDescriptor) {
      if (propDescriptor.get) {
        if (propDescriptor.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (propDescriptor.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
    }

    if (visibleKeys.indexOf(key) < 0) {
      name = '[' + key + ']';
    }

    if (!str) {
      if (ctx.seen.indexOf(value[key]) < 0) {
        if (recurseTimes === null) {
          str = formatValue(ctx, value[key], null);
        } else {
          str = formatValue(ctx, value[key], recurseTimes - 1);
        }

        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function (line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function (line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }

    if (typeof name === 'undefined') {
      if (array && key.match(/^\d+$/)) {
        return str;
      }

      name = JSON.stringify('' + key);

      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }

  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function (prev, cur) {
      return prev + cur.length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }

  function isTypedArray(ar) {
    // Unfortunately there's no way to check if an object is a TypedArray
    // We have to check if it's one of these types
    return typeof ar === 'object' && /\w+Array]$/.test(objectToString(ar));
  }

  function isArray(ar) {
    return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';
  }

  function isRegExp(re) {
    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
  }

  function isDate(d) {
    return typeof d === 'object' && objectToString(d) === '[object Date]';
  }

  function isError(e) {
    return typeof e === 'object' && objectToString(e) === '[object Error]';
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .objDisplay(object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

var objDisplay = function objDisplay(obj) {
  var str = inspect_1(obj),
      type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === '' ? '[Function]' : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj),
          kstr = keys.length > 2 ? keys.splice(0, 2).join(', ') + ', ...' : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

var getMessage = function getMessage(obj, args) {
  var negate = flag(obj, 'negate'),
      val = flag(obj, 'object'),
      expected = args[3],
      actual = getActual(obj, args),
      msg = negate ? args[2] : args[1],
      flagMsg = flag(obj, 'message');
  if (typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg.replace(/#\{this\}/g, function () {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function () {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function () {
    return objDisplay(expected);
  });
  return flagMsg ? flagMsg + ': ' + msg : msg;
};/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, `lockSsfi`,
 * and `message`) will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAssertion = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */
var transferFlags = function transferFlags(assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll || flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message') {
      object.__flags[flag] = flags[flag];
    }
  }
};/* globals Symbol: false, Uint8Array: false, WeakMap: false */

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


function FakeMap() {
  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}

FakeMap.prototype = {
  get: function getMap(key) {
    return key[this._key];
  },
  set: function setMap(key, value) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value: value,
        configurable: true
      });
    }
  }
};
var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/

function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return null;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);

    if (typeof result === 'boolean') {
      return result;
    }
  }

  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/


function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
/*!
 * Primary Export
 */


var deepEql = deepEqual;
var MemoizeMap_1 = MemoizeMap;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */

function deepEqual(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

  if (simpleResult !== null) {
    return simpleResult;
  } // Deeper comparisons are pushed through to a larger function


  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */


function simpleEqual(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  } // handle NaN cases


  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
      return true;
    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.


  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }

  return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/


function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator; // Check if a memoized result exists.

  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);

  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }

  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);

  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  } // If a comparator is present, use it.


  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.

    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.


    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = typeDetect(leftHandOperand);

  if (leftHandType !== typeDetect(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  } // Temporarily set the operands in the memoize object to prevent blowing the stack


  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());

    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;

    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual(leftHandOperand, rightHandOperand, options);

    case 'RegExp':
      return regexpEqual(leftHandOperand, rightHandOperand);

    case 'Generator':
      return generatorEqual(leftHandOperand, rightHandOperand, options);

    case 'DataView':
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);

    case 'ArrayBuffer':
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);

    case 'Set':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    case 'Map':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */


function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function entriesEqual(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }

  if (leftHandOperand.size === 0) {
    return true;
  }

  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  });
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;

  if (length !== rightHandOperand.length) {
    return false;
  }

  if (length === 0) {
    return true;
  }

  var index = -1;

  while (++index < length) {
    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */


function hasIteratorFunction(target) {
  return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */


function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }

  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */


function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];

  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }

  return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */


function getEnumerableKeys(target) {
  var keys = [];

  for (var key in target) {
    keys.push(key);
  }

  return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;

  if (length === 0) {
    return true;
  }

  for (var i = 0; i < length; i += 1) {
    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);

  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();

    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {
      return false;
    }

    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);

  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }

  return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */


function isPrimitive(value) {
  return value === null || typeof value !== 'object';
}
deepEql.MemoizeMap = MemoizeMap_1;/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .isProxyEnabled()
 *
 * Helper function to check if Chai's proxy protection feature is enabled. If
 * proxies are unsupported or disabled via the user's Chai config, then return
 * false. Otherwise, return true.
 *
 * @namespace Utils
 * @name isProxyEnabled
 */

var isProxyEnabled = function isProxyEnabled() {
  return config.useProxy && typeof Proxy !== 'undefined' && typeof Reflect !== 'undefined';
};/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addProperty(ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

var addProperty = function addProperty(ctx, name, getter) {
  getter = getter === undefined ? function () {} : getter;
  Object.defineProperty(ctx, name, {
    get: function propertyGetter() {
      // Setting the `ssfi` flag to `propertyGetter` causes this function to
      // be the starting point for removing implementation frames from the
      // stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', propertyGetter);
      }

      var result = getter.call(this);
      if (result !== undefined) return result;
      var newAssertion = new chai.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addLengthGuard(fn, assertionName, isChainable)
 *
 * Define `length` as a getter on the given uninvoked method assertion. The
 * getter acts as a guard against chaining `length` directly off of an uninvoked
 * method assertion, which is a problem because it references `function`'s
 * built-in `length` property instead of Chai's `length` assertion. When the
 * getter catches the user making this mistake, it throws an error with a
 * helpful message.
 *
 * There are two ways in which this mistake can be made. The first way is by
 * chaining the `length` assertion directly off of an uninvoked chainable
 * method. In this case, Chai suggests that the user use `lengthOf` instead. The
 * second way is by chaining the `length` assertion directly off of an uninvoked
 * non-chainable method. Non-chainable methods must be invoked prior to
 * chaining. In this case, Chai suggests that the user consult the docs for the
 * given assertion.
 *
 * If the `length` property of functions is unconfigurable, then return `fn`
 * without modification.
 *
 * Note that in ES6, the function's `length` property is configurable, so once
 * support for legacy environments is dropped, Chai's `length` property can
 * replace the built-in function's `length` property, and this length guard will
 * no longer be necessary. In the mean time, maintaining consistency across all
 * environments is the priority.
 *
 * @param {Function} fn
 * @param {String} assertionName
 * @param {Boolean} isChainable
 * @namespace Utils
 * @name addLengthGuard
 */

var addLengthGuard = function addLengthGuard(fn, assertionName, isChainable) {
  if (!fnLengthDesc.configurable) return fn;
  Object.defineProperty(fn, 'length', {
    get: function () {
      if (isChainable) {
        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' + ' to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
      }

      throw Error('Invalid Chai property: ' + assertionName + '.length. See' + ' docs for proper usage of "' + assertionName + '".');
    }
  });
  return fn;
};/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .proxify(object)
 *
 * Return a proxy of given object that throws an error when a non-existent
 * property is read. By default, the root cause is assumed to be a misspelled
 * property, and thus an attempt is made to offer a reasonable suggestion from
 * the list of existing properties. However, if a nonChainableMethodName is
 * provided, then the root cause is instead a failure to invoke a non-chainable
 * method prior to reading the non-existent property.
 *
 * If proxies are unsupported or disabled via the user's Chai config, then
 * return object without modification.
 *
 * @param {Object} obj
 * @param {String} nonChainableMethodName
 * @namespace Utils
 * @name proxify
 */

var builtins = ['__flags', '__methods', '_obj', 'assert'];

var proxify = function proxify(obj, nonChainableMethodName) {
  if (!isProxyEnabled()) return obj;
  return new Proxy(obj, {
    get: function proxyGetter(target, property) {
      // This check is here because we should not throw errors on Symbol properties
      // such as `Symbol.toStringTag`.
      // The values for which an error should be thrown can be configured using
      // the `config.proxyExcludedKeys` setting.
      if (typeof property === 'string' && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        // Special message for invalid property access of non-chainable methods.
        if (nonChainableMethodName) {
          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
        } // If the property is reasonably close to an existing Chai property,
        // suggest that property to the user. Only suggest properties with a
        // distance less than 4.


        var suggestion = null;
        var suggestionDistance = 4;
        getProperties(target).forEach(function (prop) {
          if (!Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
            var dist = stringDistanceCapped(property, prop, suggestionDistance);

            if (dist < suggestionDistance) {
              suggestion = prop;
              suggestionDistance = dist;
            }
          }
        });

        if (suggestion !== null) {
          throw Error('Invalid Chai property: ' + property + '. Did you mean "' + suggestion + '"?');
        } else {
          throw Error('Invalid Chai property: ' + property);
        }
      } // Use this proxy getter as the starting point for removing implementation
      // frames from the stack trace of a failed assertion. For property
      // assertions, this prevents the proxy getter from showing up in the stack
      // trace since it's invoked before the property getter. For method and
      // chainable method assertions, this flag will end up getting changed to
      // the method wrapper, which is good since this frame will no longer be in
      // the stack once the method is invoked. Note that Chai builtin assertion
      // properties such as `__flags` are skipped since this is only meant to
      // capture the starting point of an assertion. This step is also skipped
      // if the `lockSsfi` flag is set, thus indicating that this assertion is
      // being called from within another assertion. In that case, the `ssfi`
      // flag is already set to the outer assertion's starting point.


      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {
        flag(target, 'ssfi', proxyGetter);
      }

      return Reflect.get(target, property);
    }
  });
};
/**
 * # stringDistanceCapped(strA, strB, cap)
 * Return the Levenshtein distance between two strings, but no more than cap.
 * @param {string} strA
 * @param {string} strB
 * @param {number} number
 * @return {number} min(string distance between strA and strB, cap)
 * @api private
 */


function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap) {
    return cap;
  }

  var memo = []; // `memo` is a two-dimensional array containing distances.
  // memo[i][j] is the distance between strA.slice(0, i) and
  // strB.slice(0, j).

  for (var i = 0; i <= strA.length; i++) {
    memo[i] = Array(strB.length + 1).fill(0);
    memo[i][0] = i;
  }

  for (var j = 0; j < strB.length; j++) {
    memo[0][j] = j;
  }

  for (var i = 1; i <= strA.length; i++) {
    var ch = strA.charCodeAt(i - 1);

    for (var j = 1; j <= strB.length; j++) {
      if (Math.abs(i - j) >= cap) {
        memo[i][j] = cap;
        continue;
      }

      memo[i][j] = Math.min(memo[i - 1][j] + 1, memo[i][j - 1] + 1, memo[i - 1][j - 1] + (ch === strB.charCodeAt(j - 1) ? 0 : 1));
    }
  }

  return memo[strA.length][strB.length];
}/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addMethod(ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */

var addMethod = function addMethod(ctx, name, method) {
  var methodWrapper = function () {
    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the
    // starting point for removing implementation frames from the stack trace of
    // a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', methodWrapper);
    }

    var result = method.apply(this, arguments);
    if (result !== undefined) return result;
    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(methodWrapper, name, false);
  ctx[name] = proxify(methodWrapper, name);
};/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteProperty(ctx, name, fn)
 *
 * Overwrites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

var overwriteProperty = function overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name),
      _super = function () {};

  if (_get && 'function' === typeof _get.get) _super = _get.get;
  Object.defineProperty(ctx, name, {
    get: function overwritingPropertyGetter() {
      // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this
      // function to be the starting point for removing implementation frames
      // from the stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', overwritingPropertyGetter);
      } // Setting the `lockSsfi` flag to `true` prevents the overwritten
      // assertion from changing the `ssfi` flag. By this point, the `ssfi`
      // flag is already set to the correct starting point for this assertion.


      var origLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      var result = getter(_super).call(this);
      flag(this, 'lockSsfi', origLockSsfi);

      if (result !== undefined) {
        return result;
      }

      var newAssertion = new chai.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteMethod(ctx, name, fn)
 *
 * Overwrites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

var overwriteMethod = function overwriteMethod(ctx, name, method) {
  var _method = ctx[name],
      _super = function () {
    throw new Error(name + ' is not a function');
  };

  if (_method && 'function' === typeof _method) _super = _method;

  var overwritingMethodWrapper = function () {
    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this
    // function to be the starting point for removing implementation frames from
    // the stack trace of a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', overwritingMethodWrapper);
    } // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion
    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already
    // set to the correct starting point for this assertion.


    var origLockSsfi = flag(this, 'lockSsfi');
    flag(this, 'lockSsfi', true);
    var result = method(_super).apply(this, arguments);
    flag(this, 'lockSsfi', origLockSsfi);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = proxify(overwritingMethodWrapper, name);
};/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/*!
 * Module variables
 */
// Check whether `Object.setPrototypeOf` is supported

var canSetPrototype = typeof Object.setPrototypeOf === 'function'; // Without `Object.setPrototypeOf` support, this module will need to add properties to a function.
// However, some of functions' own props are not configurable and should be skipped.

var testFn = function () {};

var excludeNames = Object.getOwnPropertyNames(testFn).filter(function (name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name); // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,
  // but then returns `undefined` as the property descriptor for `callee`. As a
  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,
  // and then filter it out if it's not an object as it should be.

  if (typeof propDesc !== 'object') return true;
  return !propDesc.configurable;
}); // Cache `Function` properties

var call = Function.prototype.call,
    apply = Function.prototype.apply;
/**
 * ### .addChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

var addChainableMethod = function addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () {};
  }

  var chainableBehavior = {
    method: method,
    chainingBehavior: chainingBehavior
  }; // save the methods so we can overwrite them later, if we need to.

  if (!ctx.__methods) {
    ctx.__methods = {};
  }

  ctx.__methods[name] = chainableBehavior;
  Object.defineProperty(ctx, name, {
    get: function chainableMethodGetter() {
      chainableBehavior.chainingBehavior.call(this);

      var chainableMethodWrapper = function () {
        // Setting the `ssfi` flag to `chainableMethodWrapper` causes this
        // function to be the starting point for removing implementation
        // frames from the stack trace of a failed assertion.
        //
        // However, we only want to use this function as the starting point if
        // the `lockSsfi` flag isn't set.
        //
        // If the `lockSsfi` flag is set, then this assertion is being
        // invoked from inside of another assertion. In this case, the `ssfi`
        // flag has already been set by the outer assertion.
        //
        // Note that overwriting a chainable method merely replaces the saved
        // methods in `ctx.__methods` instead of completely replacing the
        // overwritten assertion. Therefore, an overwriting assertion won't
        // set the `ssfi` or `lockSsfi` flags.
        if (!flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', chainableMethodWrapper);
        }

        var result = chainableBehavior.method.apply(this, arguments);

        if (result !== undefined) {
          return result;
        }

        var newAssertion = new chai.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };

      addLengthGuard(chainableMethodWrapper, name, true); // Use `Object.setPrototypeOf` if available

      if (canSetPrototype) {
        // Inherit all properties from the object by replacing the `Function` prototype
        var prototype = Object.create(this); // Restore the `call` and `apply` methods from `Function`

        prototype.call = call;
        prototype.apply = apply;
        Object.setPrototypeOf(chainableMethodWrapper, prototype);
      } // Otherwise, redefine all properties (slow!)
      else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (excludeNames.indexOf(asserterName) !== -1) {
              return;
            }

            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          });
        }

      transferFlags(this, chainableMethodWrapper);
      return proxify(chainableMethodWrapper);
    },
    configurable: true
  });
};/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Overwrites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.lengthOf(3);
 *     expect(myFoo).to.have.lengthOf.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

var overwriteChainableMethod = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];
  var _chainingBehavior = chainableBehavior.chainingBehavior;

  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
    var result = chainingBehavior(_chainingBehavior).call(this);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  var _method = chainableBehavior.method;

  chainableBehavior.method = function overwritingChainableMethodWrapper() {
    var result = method(_method).apply(this, arguments);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };
};/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .compareByInspect(mixed, mixed)
 *
 * To be used as a compareFunction with Array.prototype.sort. Compares elements
 * using inspect instead of default behavior of using toString so that Symbols
 * and objects with irregular/missing toString can still be sorted without a
 * TypeError.
 *
 * @param {Mixed} first element to compare
 * @param {Mixed} second element to compare
 * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1
 * @name compareByInspect
 * @namespace Utils
 * @api public
 */

var compareByInspect = function compareByInspect(a, b) {
  return inspect_1(a) < inspect_1(b) ? -1 : 1;
};/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getOwnEnumerablePropertySymbols(object)
 *
 * This allows the retrieval of directly-owned enumerable property symbols of an
 * object. This function is necessary because Object.getOwnPropertySymbols
 * returns both enumerable and non-enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerablePropertySymbols
 * @api public
 */
var getOwnEnumerablePropertySymbols = function getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== 'function') return [];
  return Object.getOwnPropertySymbols(obj).filter(function (sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
};/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .getOwnEnumerableProperties(object)
 *
 * This allows the retrieval of directly-owned enumerable property names and
 * symbols of an object. This function is necessary because Object.keys only
 * returns enumerable property names, not enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerableProperties
 * @api public
 */

var getOwnEnumerableProperties = function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
};/* !
 * Chai - checkError utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .checkError
 *
 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
 *
 * @api public
 */

/**
 * ### .compatibleInstance(thrown, errorLike)
 *
 * Checks if two instances are compatible (strict equal).
 * Returns false if errorLike is not an instance of Error, because instances
 * can only be compatible if they're both error instances.
 *
 * @name compatibleInstance
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */

function compatibleInstance(thrown, errorLike) {
  return errorLike instanceof Error && thrown === errorLike;
}
/**
 * ### .compatibleConstructor(thrown, errorLike)
 *
 * Checks if two constructors are compatible.
 * This function can receive either an error constructor or
 * an error instance as the `errorLike` argument.
 * Constructors are compatible if they're the same or if one is
 * an instance of another.
 *
 * @name compatibleConstructor
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */


function compatibleConstructor(thrown, errorLike) {
  if (errorLike instanceof Error) {
    // If `errorLike` is an instance of any error we compare their constructors
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if (errorLike.prototype instanceof Error || errorLike === Error) {
    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }

  return false;
}
/**
 * ### .compatibleMessage(thrown, errMatcher)
 *
 * Checks if an error's message is compatible with a matcher (String or RegExp).
 * If the message contains the String or passes the RegExp test,
 * it is considered compatible.
 *
 * @name compatibleMessage
 * @param {Error} thrown error
 * @param {String|RegExp} errMatcher to look for into the message
 * @namespace Utils
 * @api public
 */


function compatibleMessage(thrown, errMatcher) {
  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;

  if (errMatcher instanceof RegExp) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === 'string') {
    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers
  }

  return false;
}
/**
 * ### .getFunctionName(constructorFn)
 *
 * Returns the name of a function.
 * This also includes a polyfill function if `constructorFn.name` is not defined.
 *
 * @name getFunctionName
 * @param {Function} constructorFn
 * @namespace Utils
 * @api private
 */


var functionNameMatch$1 = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;

function getFunctionName(constructorFn) {
  var name = '';

  if (typeof constructorFn.name === 'undefined') {
    // Here we run a polyfill if constructorFn.name is not defined
    var match = String(constructorFn).match(functionNameMatch$1);

    if (match) {
      name = match[1];
    }
  } else {
    name = constructorFn.name;
  }

  return name;
}
/**
 * ### .getConstructorName(errorLike)
 *
 * Gets the constructor name for an Error instance or constructor itself.
 *
 * @name getConstructorName
 * @param {Error|ErrorConstructor} errorLike
 * @namespace Utils
 * @api public
 */


function getConstructorName(errorLike) {
  var constructorName = errorLike;

  if (errorLike instanceof Error) {
    constructorName = getFunctionName(errorLike.constructor);
  } else if (typeof errorLike === 'function') {
    // If `err` is not an instance of Error it is an error constructor itself or another function.
    // If we've got a common function we get its name, otherwise we may need to create a new instance
    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
    constructorName = getFunctionName(errorLike).trim() || getFunctionName(new errorLike()); // eslint-disable-line new-cap
  }

  return constructorName;
}
/**
 * ### .getMessage(errorLike)
 *
 * Gets the error message from an error.
 * If `err` is a String itself, we return it.
 * If the error has no message, we return an empty string.
 *
 * @name getMessage
 * @param {Error|String} errorLike
 * @namespace Utils
 * @api public
 */


function getMessage$1(errorLike) {
  var msg = '';

  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === 'string') {
    msg = errorLike;
  }

  return msg;
}

var checkError = {
  compatibleInstance: compatibleInstance,
  compatibleConstructor: compatibleConstructor,
  compatibleMessage: compatibleMessage,
  getMessage: getMessage$1,
  getConstructorName: getConstructorName
};/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */

/**
 * ### .isNaN(value)
 *
 * Checks if the given value is NaN or not.
 *
 *     utils.isNaN(NaN); // true
 *
 * @param {Value} The value which has to be checked if it is NaN
 * @name isNaN
 * @api private
 */
function isNaN(value) {
  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
  // section's NOTE.
  return value !== value;
} // If ECMAScript 6's Number.isNaN is present, prefer that.


var _isNaN = Number.isNaN || isNaN;/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Dependencies that are used for multiple exports are required here only once
 */

/*!
 * test utility
 */

var test$2 = test$1;
/*!
 * type utility
 */

var type = typeDetect;
/*!
 * expectTypes utility
 */

var expectTypes$1 = expectTypes;
/*!
 * message utility
 */

var getMessage$2 = getMessage;
/*!
 * actual utility
 */

var getActual$1 = getActual;
/*!
 * Inspect util
 */

var inspect = inspect_1;
/*!
 * Object Display util
 */

var objDisplay$1 = objDisplay;
/*!
 * Flag utility
 */

var flag$1 = flag;
/*!
 * Flag transferring utility
 */

var transferFlags$1 = transferFlags;
/*!
 * Deep equal utility
 */

var eql = deepEql;
/*!
 * Deep path info
 */

var getPathInfo$1 = pathval.getPathInfo;
/*!
 * Check if a property exists
 */

var hasProperty$1 = pathval.hasProperty;
/*!
 * Function name
 */

var getName = getFuncName_1;
/*!
 * add Property
 */

var addProperty$1 = addProperty;
/*!
 * add Method
 */

var addMethod$1 = addMethod;
/*!
 * overwrite Property
 */

var overwriteProperty$1 = overwriteProperty;
/*!
 * overwrite Method
 */

var overwriteMethod$1 = overwriteMethod;
/*!
 * Add a chainable method
 */

var addChainableMethod$1 = addChainableMethod;
/*!
 * Overwrite chainable method
 */

var overwriteChainableMethod$1 = overwriteChainableMethod;
/*!
 * Compare by inspect method
 */

var compareByInspect$1 = compareByInspect;
/*!
 * Get own enumerable property symbols method
 */

var getOwnEnumerablePropertySymbols$1 = getOwnEnumerablePropertySymbols;
/*!
 * Get own enumerable properties method
 */

var getOwnEnumerableProperties$1 = getOwnEnumerableProperties;
/*!
 * Checks error against a given set of criteria
 */

var checkError$1 = checkError;
/*!
 * Proxify util
 */

var proxify$1 = proxify;
/*!
 * addLengthGuard util
 */

var addLengthGuard$1 = addLengthGuard;
/*!
 * isProxyEnabled helper
 */

var isProxyEnabled$1 = isProxyEnabled;
/*!
 * isNaN method
 */

var isNaN$1 = _isNaN;
var utils = {
  test: test$2,
  type: type,
  expectTypes: expectTypes$1,
  getMessage: getMessage$2,
  getActual: getActual$1,
  inspect: inspect,
  objDisplay: objDisplay$1,
  flag: flag$1,
  transferFlags: transferFlags$1,
  eql: eql,
  getPathInfo: getPathInfo$1,
  hasProperty: hasProperty$1,
  getName: getName,
  addProperty: addProperty$1,
  addMethod: addMethod$1,
  overwriteProperty: overwriteProperty$1,
  overwriteMethod: overwriteMethod$1,
  addChainableMethod: addChainableMethod$1,
  overwriteChainableMethod: overwriteChainableMethod$1,
  compareByInspect: compareByInspect$1,
  getOwnEnumerablePropertySymbols: getOwnEnumerablePropertySymbols$1,
  getOwnEnumerableProperties: getOwnEnumerableProperties$1,
  checkError: checkError$1,
  proxify: proxify$1,
  addLengthGuard: addLengthGuard$1,
  isProxyEnabled: isProxyEnabled$1,
  isNaN: isNaN$1
};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var assertion = function (_chai, util) {
  /*!
   * Module dependencies.
   */
  var AssertionError = _chai.AssertionError,
      flag = util.flag;
  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;
  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   *   contain `numKittens` so that the `equal` assertion can reference it when
   *   needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support `Error.captureStackTrace`, and only when
   *   `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to `true` when creating a new assertion
   *   from within another assertion. It's also temporarily set to `true` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */

  function Assertion(obj, msg, ssfi, lockSsfi) {
    flag(this, 'ssfi', ssfi || Assertion);
    flag(this, 'lockSsfi', lockSsfi);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
    return util.proxify(this);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function () {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function (value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });
  Object.defineProperty(Assertion, 'showDiff', {
    get: function () {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function (value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */


  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (false !== showDiff) showDiff = true;
    if (undefined === expected && undefined === _actual) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      msg = util.getMessage(this, arguments);
      var actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
        actual: actual,
        expected: expected,
        showDiff: showDiff
      }, config.includeStack ? this.assert : flag(this, 'ssfi'));
    }
  };
  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */


  Object.defineProperty(Assertion.prototype, '_obj', {
    get: function () {
      return flag(this, 'object');
    },
    set: function (val) {
      flag(this, 'object', val);
    }
  });
};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var assertions = function (chai, _) {
  var Assertion = chai.Assertion,
      AssertionError = chai.AssertionError,
      flag = _.flag;
  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to improve the readability
   * of your assertions.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   * - but
   * - does
   * - still
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  ['to', 'be', 'been', 'is', 'and', 'has', 'have', 'with', 'that', 'which', 'at', 'of', 'same', 'but', 'does', 'still'].forEach(function (chain) {
    Assertion.addProperty(chain);
  });
  /**
   * ### .not
   *
   * Negates all assertions that follow in the chain.
   *
   *     expect(function () {}).to.not.throw();
   *     expect({a: 1}).to.not.have.property('b');
   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
   *
   * Just because you can negate any assertion with `.not` doesn't mean you
   * should. With great power comes great responsibility. It's often best to
   * assert that the one expected output was produced, rather than asserting
   * that one of countless unexpected outputs wasn't produced. See individual
   * assertions for specific guidance.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.equal(1); // Not recommended
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });
  /**
   * ### .deep
   *
   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
   * assertions that follow in the chain to use deep equality instead of strict
   * (`===`) equality. See the `deep-eql` project page for info on the deep
   * equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });
  /**
   * ### .nested
   *
   * Enables dot- and bracket-notation in all `.property` and `.include`
   * assertions that follow in the chain.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
   *
   * `.nested` cannot be combined with `.own`.
   *
   * @name nested
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('nested', function () {
    flag(this, 'nested', true);
  });
  /**
   * ### .own
   *
   * Causes all `.property` and `.include` assertions that follow in the chain
   * to ignore inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * `.own` cannot be combined with `.nested`.
   *
   * @name own
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('own', function () {
    flag(this, 'own', true);
  });
  /**
   * ### .ordered
   *
   * Causes all `.members` assertions that follow in the chain to require that
   * members be in the same order.
   *
   *     expect([1, 2]).to.have.ordered.members([1, 2])
   *       .but.not.have.ordered.members([2, 1]);
   *
   * When `.include` and `.ordered` are combined, the ordering begins at the
   * start of both arrays.
   *
   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
   *       .but.not.include.ordered.members([2, 3]);
   *
   * @name ordered
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ordered', function () {
    flag(this, 'ordered', true);
  });
  /**
   * ### .any
   *
   * Causes all `.keys` assertions that follow in the chain to only require that
   * the target have at least one of the given keys. This is the opposite of
   * `.all`, which requires that the target have all of the given keys.
   *
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false);
  });
  /**
   * ### .all
   *
   * Causes all `.keys` assertions that follow in the chain to require that the
   * target have all of the given keys. This is the opposite of `.any`, which
   * only requires that the target have at least one of the given keys.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` are
   * added earlier in the chain. However, it's often best to add `.all` anyway
   * because it improves readability.
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });
  /**
   * ### .a(type[, msg])
   *
   * Asserts that the target's type is equal to the given string `type`. Types
   * are case insensitive. See the `type-detect` project page for info on the
   * type detection algorithm: https://github.com/chaijs/type-detect.
   *
   *     expect('foo').to.be.a('string');
   *     expect({a: 1}).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(Promise.resolve()).to.be.a('promise');
   *     expect(new Float32Array).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.
   *
   *     var myObj = {
   *       [Symbol.toStringTag]: 'myCustomType'
   *     };
   *
   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
   *
   * It's often best to use `.a` to check a target's type before making more
   * assertions on the same target. That way, you avoid unexpected behavior from
   * any assertion that does different things based on the target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to
   * assert that the target is the expected type, rather than asserting that it
   * isn't one of many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.an('array'); // Not recommended
   *
   * `.a` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     expect(1).to.be.a('string', 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.a('string');
   *
   * `.a` can also be used as a language chain to improve the readability of
   * your assertions.
   *
   *     expect({b: 2}).to.have.a.property('b');
   *
   * The alias `.an` can be used interchangeably with `.a`.
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function an(type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object'),
        article = ~['a', 'e', 'i', 'o', 'u'].indexOf(type.charAt(0)) ? 'an ' : 'a ';
    this.assert(type === _.type(obj).toLowerCase(), 'expected #{this} to be ' + article + type, 'expected #{this} not to be ' + article + type);
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);
  /**
   * ### .include(val[, msg])
   *
   * When the target is a string, `.include` asserts that the given string `val`
   * is a substring of the target.
   *
   *     expect('foobar').to.include('foo');
   *
   * When the target is an array, `.include` asserts that the given `val` is a
   * member of the target.
   *
   *     expect([1, 2, 3]).to.include(2);
   *
   * When the target is an object, `.include` asserts that the given object
   * `val`'s properties are a subset of the target's properties.
   *
   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
   *
   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a
   * member of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Set([1, 2])).to.include(2);
   *
   * When the target is a Map, `.include` asserts that the given `val` is one of
   * the values of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
   *
   * Because `.include` does different things based on the target's type, it's
   * important to check the target's type before using `.include`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *
   * By default, strict (`===`) equality is used to compare array members and
   * object properties. Add `.deep` earlier in the chain to use deep equality
   * instead (WeakSet targets are not supported). See the `deep-eql` project
   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   * By default, all of the target's properties are searched when working with
   * objects. This includes properties that are inherited and/or non-enumerable.
   * Add `.own` earlier in the chain to exclude the target's inherited
   * properties from the search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * Note that a target object is always only searched for `val`'s own
   * enumerable properties.
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.include`.
   *
   *     expect('foobar').to.not.include('taco');
   *     expect([1, 2, 3]).to.not.include(4);
   *
   * However, it's dangerous to negate `.include` when the target is an object.
   * The problem is that it creates uncertain expectations by asserting that the
   * target object doesn't have all of `val`'s key/value pairs but may or may
   * not have some of them. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target object isn't even expected to have `val`'s keys, it's
   * often best to assert exactly that.
   *
   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * When the target object is expected to have `val`'s keys, it's often best to
   * assert that each of the properties has its expected value, rather than
   * asserting that each property doesn't have one of many unexpected values.
   *
   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * `.include` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
   *
   * `.include` can also be used as a language chain, causing all `.members` and
   * `.keys` assertions that follow in the chain to require the target to be a
   * superset of the expected set, rather than an identical set. Note that
   * `.members` ignores duplicates in the subset when `.include` is added.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * Note that adding `.any` earlier in the chain causes the `.keys` assertion
   * to ignore `.include`.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *
   * The aliases `.includes`, `.contain`, and `.contains` can be used
   * interchangeably with `.include`.
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function SameValueZero(a, b) {
    return _.isNaN(a) && _.isNaN(b) || a === b;
  }

  function includeChainingBehavior() {
    flag(this, 'contains', true);
  }

  function include(val, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        objType = _.type(obj).toLowerCase(),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate'),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        descriptor = isDeep ? 'deep ' : '';

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var included = false;

    switch (objType) {
      case 'string':
        included = obj.indexOf(val) !== -1;
        break;

      case 'weakset':
        if (isDeep) {
          throw new AssertionError(flagMsg + 'unable to use .deep.include with WeakSet', undefined, ssfi);
        }

        included = obj.has(val);
        break;

      case 'map':
        var isEql = isDeep ? _.eql : SameValueZero;
        obj.forEach(function (item) {
          included = included || isEql(item, val);
        });
        break;

      case 'set':
        if (isDeep) {
          obj.forEach(function (item) {
            included = included || _.eql(item, val);
          });
        } else {
          included = obj.has(val);
        }

        break;

      case 'array':
        if (isDeep) {
          included = obj.some(function (item) {
            return _.eql(item, val);
          });
        } else {
          included = obj.indexOf(val) !== -1;
        }

        break;

      default:
        // This block is for asserting a subset of properties in an object.
        // `_.expectTypes` isn't used here because `.include` should work with
        // objects with a custom `@@toStringTag`.
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + 'object tested must be an array, a map, an object,' + ' a set, a string, or a weakset, but ' + objType + ' given', undefined, ssfi);
        }

        var props = Object.keys(val),
            firstErr = null,
            numErrs = 0;
        props.forEach(function (prop) {
          var propAssertion = new Assertion(obj);

          _.transferFlags(this, propAssertion, true);

          flag(propAssertion, 'lockSsfi', true);

          if (!negate || props.length === 1) {
            propAssertion.property(prop, val[prop]);
            return;
          }

          try {
            propAssertion.property(prop, val[prop]);
          } catch (err) {
            if (!_.checkError.compatibleConstructor(err, AssertionError)) {
              throw err;
            }

            if (firstErr === null) firstErr = err;
            numErrs++;
          }
        }, this); // When validating .not.include with multiple properties, we only want
        // to throw an assertion error if all of the properties are included,
        // in which case we throw the first property assertion error that we
        // encountered.

        if (negate && props.length > 1 && numErrs === props.length) {
          throw firstErr;
        }

        return;
    } // Assert inclusion in collection or substring in a string.


    this.assert(included, 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val), 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);
  /**
   * ### .ok
   *
   * Asserts that the target is a truthy value (considered `true` in boolean context).
   * However, it's often best to assert that the target is strictly (`===`) or
   * deeply equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.ok; // Not recommended
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.be.ok; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.ok`.
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.not.be.ok; // Not recommended
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.ok; // Not recommended
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.be.ok; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.be.ok; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(flag(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');
  });
  /**
   * ### .true
   *
   * Asserts that the target is strictly (`===`) equal to `true`.
   *
   *     expect(true).to.be.true;
   *
   * Add `.not` earlier in the chain to negate `.true`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `true`.
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.true; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.true; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(true === flag(this, 'object'), 'expected #{this} to be true', 'expected #{this} to be false', flag(this, 'negate') ? false : true);
  });
  /**
   * ### .false
   *
   * Asserts that the target is strictly (`===`) equal to `false`.
   *
   *     expect(false).to.be.false;
   *
   * Add `.not` earlier in the chain to negate `.false`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `false`.
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.not.be.false; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.false; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(true, 'nooo why fail??').to.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(false === flag(this, 'object'), 'expected #{this} to be false', 'expected #{this} to be true', flag(this, 'negate') ? true : false);
  });
  /**
   * ### .null
   *
   * Asserts that the target is strictly (`===`) equal to `null`.
   *
   *     expect(null).to.be.null;
   *
   * Add `.not` earlier in the chain to negate `.null`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `null`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.null; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(null === flag(this, 'object'), 'expected #{this} to be null', 'expected #{this} not to be null');
  });
  /**
   * ### .undefined
   *
   * Asserts that the target is strictly (`===`) equal to `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *
   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `undefined`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.undefined; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(undefined === flag(this, 'object'), 'expected #{this} to be undefined', 'expected #{this} not to be undefined');
  });
  /**
   * ### .NaN
   *
   * Asserts that the target is exactly `NaN`.
   *
   *     expect(NaN).to.be.NaN;
   *
   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `NaN`.
   *
   *     expect('foo').to.equal('foo'); // Recommended
   *     expect('foo').to.not.be.NaN; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(_.isNaN(flag(this, 'object')), 'expected #{this} to be NaN', 'expected #{this} not to be NaN');
  });
  /**
   * ### .exist
   *
   * Asserts that the target is not strictly (`===`) equal to either `null` or
   * `undefined`. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.exist; // Not recommended
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.exist; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.exist`.
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.exist; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.exist; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(null, 'nooo why fail??').to.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('exist', function () {
    var val = flag(this, 'object');
    this.assert(val !== null && val !== undefined, 'expected #{this} to exist', 'expected #{this} to not exist');
  });
  /**
   * ### .empty
   *
   * When the target is a string or array, `.empty` asserts that the target's
   * `length` property is strictly (`===`) equal to `0`.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *
   * When the target is a map or set, `.empty` asserts that the target's `size`
   * property is strictly equal to `0`.
   *
   *     expect(new Set()).to.be.empty;
   *     expect(new Map()).to.be.empty;
   *
   * When the target is a non-function object, `.empty` asserts that the target
   * doesn't have any own enumerable properties. Properties with Symbol-based
   * keys are excluded from the count.
   *
   *     expect({}).to.be.empty;
   *
   * Because `.empty` does different things based on the target's type, it's
   * important to check the target's type before using `.empty`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.empty`. However, it's often
   * best to assert that the target contains its expected number of values,
   * rather than asserting that it's not empty.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
   *
   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
   *
   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
   *     expect({a: 1}).to.not.be.empty; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var val = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        itemsCount;
    flagMsg = flagMsg ? flagMsg + ': ' : '';

    switch (_.type(val).toLowerCase()) {
      case 'array':
      case 'string':
        itemsCount = val.length;
        break;

      case 'map':
      case 'set':
        itemsCount = val.size;
        break;

      case 'weakmap':
      case 'weakset':
        throw new AssertionError(flagMsg + '.empty was passed a weak collection', undefined, ssfi);

      case 'function':
        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);

        throw new AssertionError(msg.trim(), undefined, ssfi);

      default:
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + '.empty was passed non-string primitive ' + _.inspect(val), undefined, ssfi);
        }

        itemsCount = Object.keys(val).length;
    }

    this.assert(0 === itemsCount, 'expected #{this} to be empty', 'expected #{this} not to be empty');
  });
  /**
   * ### .arguments
   *
   * Asserts that the target is an `arguments` object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   *     test();
   *
   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often
   * best to assert which type the target is expected to be, rather than
   * asserting that its not an `arguments` object.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.arguments; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({}, 'nooo why fail??').to.be.arguments;
   *
   * The alias `.Arguments` can be used interchangeably with `.arguments`.
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments() {
    var obj = flag(this, 'object'),
        type = _.type(obj);

    this.assert('Arguments' === type, 'expected #{this} to be arguments but got ' + type, 'expected #{this} to not be arguments');
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);
  /**
   * ### .equal(val[, msg])
   *
   * Asserts that the target is strictly (`===`) equal to the given `val`.
   *
   *     expect(1).to.equal(1);
   *     expect('foo').to.equal('foo');
   *
   * Add `.deep` earlier in the chain to use deep equality instead. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) equals `[1, 2]`
   *     expect([1, 2]).to.deep.equal([1, 2]);
   *     expect([1, 2]).to.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.equal`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to one of countless unexpected values.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.equal(2); // Not recommended
   *
   * `.equal` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.equal(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.equal(2);
   *
   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual(val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    if (flag(this, 'deep')) {
      var prevLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      this.eql(val);
      flag(this, 'lockSsfi', prevLockSsfi);
    } else {
      this.assert(val === obj, 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{exp}', val, this._obj, true);
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);
  /**
   * ### .eql(obj[, msg])
   *
   * Asserts that the target is deeply equal to the given `obj`. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object is deeply (but not strictly) equal to {a: 1}
   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
   *
   *     // Target array is deeply (but not strictly) equal to [1, 2]
   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best
   * to assert that the target is deeply equal to its expected value, rather
   * than not deeply equal to one of countless unexpected values.
   *
   *     expect({a: 1}).to.eql({a: 1}); // Recommended
   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
   *
   * `.eql` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
   *
   * The alias `.eqls` can be used interchangeably with `.eql`.
   *
   * The `.deep.equal` assertion is almost identical to `.eql` but with one
   * difference: `.deep.equal` causes deep equality comparisons to also be used
   * for any other assertions that follow in the chain.
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} obj
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(_.eql(obj, flag(this, 'object')), 'expected #{this} to deeply equal #{exp}', 'expected #{this} to not deeply equal #{exp}', obj, this._obj, true);
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);
  /**
   * ### .above(n[, msg])
   *
   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.above(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.above(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.above`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(1).to.not.be.above(2); // Not recommended
   *
   * `.above` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.above(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.above(2);
   *
   * The aliases `.gt` and `.greaterThan` can be used interchangeably with
   * `.above`.
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to above must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to above must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount > n, 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' above #{exp}', n, itemsCount);
    } else {
      this.assert(obj > n, 'expected #{this} to be above #{exp}', 'expected #{this} to be at most #{exp}', n);
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);
  /**
   * ### .least(n[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `n` respectively. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.at.least(1); // Not recommended
   *     expect(2).to.be.at.least(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.least`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.at.least(2); // Not recommended
   *
   * `.least` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.at.least(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.at.least(2);
   *
   * The alias `.gte` can be used interchangeably with `.least`.
   *
   * @name least
   * @alias gte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to least must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to least must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount >= n, 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}', 'expected #{this} to have a ' + descriptor + ' below #{exp}', n, itemsCount);
    } else {
      this.assert(obj >= n, 'expected #{this} to be at least #{exp}', 'expected #{this} to be below #{exp}', n);
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);
  /**
   * ### .below(n[, msg])
   *
   * Asserts that the target is a number or a date less than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.below(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.below(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.length(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.below`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.below(1); // Not recommended
   *
   * `.below` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.below(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.below(1);
   *
   * The aliases `.lt` and `.lessThan` can be used interchangeably with
   * `.below`.
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to below must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to below must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount < n, 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' below #{exp}', n, itemsCount);
    } else {
      this.assert(obj < n, 'expected #{this} to be below #{exp}', 'expected #{this} to be at least #{exp}', n);
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);
  /**
   * ### .most(n[, msg])
   *
   * Asserts that the target is a number or a date less than or equal to the given number
   * or date `n` respectively. However, it's often best to assert that the target is equal to its
   * expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.at.most(2); // Not recommended
   *     expect(1).to.be.at.most(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.most`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.at.most(1); // Not recommended
   *
   * `.most` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.at.most(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.at.most(1);
   *
   * The alias `.lte` can be used interchangeably with `.most`.
   *
   * @name most
   * @alias lte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to most must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to most must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount <= n, 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}', 'expected #{this} to have a ' + descriptor + ' above #{exp}', n, itemsCount);
    } else {
      this.assert(obj <= n, 'expected #{this} to be at most #{exp}', 'expected #{this} to be above #{exp}', n);
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);
  /**
   * ### .within(start, finish[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `start`, and less than or equal to the given number or date `finish` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.within(1, 3); // Not recommended
   *     expect(2).to.be.within(2, 3); // Not recommended
   *     expect(2).to.be.within(1, 2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `start`, and less
   * than or equal to the given number `finish`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.within`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.within(2, 4); // Not recommended
   *
   * `.within` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(4).to.be.within(1, 3, 'nooo why fail??');
   *     expect(4, 'nooo why fail??').to.be.within(1, 3);
   *
   * @name within
   * @param {Number} start lower bound inclusive
   * @param {Number} finish upper bound inclusive
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        startType = _.type(start).toLowerCase(),
        finishType = _.type(finish).toLowerCase(),
        errorMessage,
        shouldThrow = true,
        range = startType === 'date' && finishType === 'date' ? start.toUTCString() + '..' + finish.toUTCString() : start + '..' + finish;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && (startType !== 'date' || finishType !== 'date')) {
      errorMessage = msgPrefix + 'the arguments to within must be dates';
    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the arguments to within must be numbers';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount >= start && itemsCount <= finish, 'expected #{this} to have a ' + descriptor + ' within ' + range, 'expected #{this} to not have a ' + descriptor + ' within ' + range);
    } else {
      this.assert(obj >= start && obj <= finish, 'expected #{this} to be within ' + range, 'expected #{this} to not be within ' + range);
    }
  });
  /**
   * ### .instanceof(constructor[, msg])
   *
   * Asserts that the target is an instance of the given `constructor`.
   *
   *     function Cat () { }
   *
   *     expect(new Cat()).to.be.an.instanceof(Cat);
   *     expect([1, 2]).to.be.an.instanceof(Array);
   *
   * Add `.not` earlier in the chain to negate `.instanceof`.
   *
   *     expect({a: 1}).to.not.be.an.instanceof(Array);
   *
   * `.instanceof` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
   *
   * Due to limitations in ES5, `.instanceof` may not always work as expected
   * when using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing built-in object such as
   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} msg _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf(constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var target = flag(this, 'object');
    var ssfi = flag(this, 'ssfi');
    var flagMsg = flag(this, 'message');

    try {
      var isInstanceOf = target instanceof constructor;
    } catch (err) {
      if (err instanceof TypeError) {
        flagMsg = flagMsg ? flagMsg + ': ' : '';
        throw new AssertionError(flagMsg + 'The instanceof assertion needs a constructor but ' + _.type(constructor) + ' was given.', undefined, ssfi);
      }

      throw err;
    }

    var name = _.getName(constructor);

    if (name === null) {
      name = 'an unnamed constructor';
    }

    this.assert(isInstanceOf, 'expected #{this} to be an instance of ' + name, 'expected #{this} to not be an instance of ' + name);
  }
  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);
  /**
   * ### .property(name[, val[, msg]])
   *
   * Asserts that the target has a property with the given key `name`.
   *
   *     expect({a: 1}).to.have.property('a');
   *
   * When `val` is provided, `.property` also asserts that the property's value
   * is equal to the given `val`.
   *
   *     expect({a: 1}).to.have.property('a', 1);
   *
   * By default, strict (`===`) equality is used. Add `.deep` earlier in the
   * chain to use deep equality instead. See the `deep-eql` project page for
   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * The target's enumerable and non-enumerable properties are always included
   * in the search. By default, both own and inherited properties are included.
   * Add `.own` earlier in the chain to exclude inherited properties from the
   * search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.own.property('a', 1);
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}})
   *       .to.have.deep.nested.property('a.b[0]', {c: 3});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.property`.
   *
   *     expect({a: 1}).to.not.have.property('b');
   *
   * However, it's dangerous to negate `.property` when providing `val`. The
   * problem is that it creates uncertain expectations by asserting that the
   * target either doesn't have a property with the given key `name`, or that it
   * does have a property with the given key `name` but its value isn't equal to
   * the given `val`. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property with the given key
   * `name`, it's often best to assert exactly that.
   *
   *     expect({b: 2}).to.not.have.property('a'); // Recommended
   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
   *
   * When the target is expected to have a property with the given key `name`,
   * it's often best to assert that the property has its expected value, rather
   * than asserting that it doesn't have one of many unexpected values.
   *
   *     expect({a: 3}).to.have.property('a', 3); // Recommended
   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
   *
   * `.property` changes the target of any assertions that follow in the chain
   * to be the value of the property from the original target object.
   *
   *     expect({a: 1}).to.have.property('a').that.is.a('number');
   *
   * `.property` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing `val`, only use the
   * second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
   *
   *     // Not recommended
   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `val`. Instead,
   * it's asserting that the target object has a `b` property that's equal to
   * `undefined`.
   *
   * The assertions `.ownProperty` and `.haveOwnProperty` can be used
   * interchangeably with `.own.property`.
   *
   * @name property
   * @param {String} name
   * @param {Mixed} val (optional)
   * @param {String} msg _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  function assertProperty(name, val, msg) {
    if (msg) flag(this, 'message', msg);
    var isNested = flag(this, 'nested'),
        isOwn = flag(this, 'own'),
        flagMsg = flag(this, 'message'),
        obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        nameType = typeof name;
    flagMsg = flagMsg ? flagMsg + ': ' : '';

    if (isNested) {
      if (nameType !== 'string') {
        throw new AssertionError(flagMsg + 'the argument to property must be a string when using nested syntax', undefined, ssfi);
      }
    } else {
      if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {
        throw new AssertionError(flagMsg + 'the argument to property must be a string, number, or symbol', undefined, ssfi);
      }
    }

    if (isNested && isOwn) {
      throw new AssertionError(flagMsg + 'The "nested" and "own" flags cannot be combined.', undefined, ssfi);
    }

    if (obj === null || obj === undefined) {
      throw new AssertionError(flagMsg + 'Target cannot be null or undefined.', undefined, ssfi);
    }

    var isDeep = flag(this, 'deep'),
        negate = flag(this, 'negate'),
        pathInfo = isNested ? _.getPathInfo(obj, name) : null,
        value = isNested ? pathInfo.value : obj[name];
    var descriptor = '';
    if (isDeep) descriptor += 'deep ';
    if (isOwn) descriptor += 'own ';
    if (isNested) descriptor += 'nested ';
    descriptor += 'property ';
    var hasProperty;
    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);else if (isNested) hasProperty = pathInfo.exists;else hasProperty = _.hasProperty(obj, name); // When performing a negated assertion for both name and val, merely having
    // a property with the given name isn't enough to cause the assertion to
    // fail. It must both have a property with the given name, and the value of
    // that property must equal the given val. Therefore, skip this assertion in
    // favor of the next.

    if (!negate || arguments.length === 1) {
      this.assert(hasProperty, 'expected #{this} to have ' + descriptor + _.inspect(name), 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(hasProperty && (isDeep ? _.eql(val, value) : val === value), 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}', 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}', val, value);
    }

    flag(this, 'object', value);
  }

  Assertion.addMethod('property', assertProperty);

  function assertOwnProperty(name, value, msg) {
    flag(this, 'own', true);
    assertProperty.apply(this, arguments);
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);
  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
   *
   * Asserts that the target has its own property descriptor with the given key
   * `name`. Enumerable and non-enumerable properties are included in the
   * search.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
   *
   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that
   * the property's descriptor is deeply equal to the given `descriptor`. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.
   *
   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
   *
   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing
   * a `descriptor`. The problem is that it creates uncertain expectations by
   * asserting that the target either doesn't have a property descriptor with
   * the given key `name`, or that it does have a property descriptor with the
   * given key `name` but its not deeply equal to the given `descriptor`. It's
   * often best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property descriptor with the given
   * key `name`, it's often best to assert exactly that.
   *
   *     // Recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
   *
   *     // Not recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * When the target is expected to have a property descriptor with the given
   * key `name`, it's often best to assert that the property has its expected
   * descriptor, rather than asserting that it doesn't have one of many
   * unexpected descriptors.
   *
   *     // Recommended
   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 3,
   *     });
   *
   *     // Not recommended
   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * `.ownPropertyDescriptor` changes the target of any assertions that follow
   * in the chain to be the value of the property descriptor from the original
   * target object.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
   *       .that.has.property('enumerable', true);
   *
   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a
   * custom error message to show when the assertion fails. The message can also
   * be given as the second argument to `expect`. When not providing
   * `descriptor`, only use the second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     }, 'nooo why fail??');
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     });
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
   *
   *     // Not recommended
   *     expect({a: 1})
   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `descriptor`.
   * Instead, it's asserting that the target object has a `b` property
   * descriptor that's deeply equal to `undefined`.
   *
   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with
   * `.ownPropertyDescriptor`.
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor(name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }

    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);

    if (actualDescriptor && descriptor) {
      this.assert(_.eql(descriptor, actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor), descriptor, actualDescriptor, true);
    } else {
      this.assert(actualDescriptor, 'expected #{this} to have an own property descriptor for ' + _.inspect(name), 'expected #{this} to not have an own property descriptor for ' + _.inspect(name));
    }

    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);
  /**
   * ### .lengthOf(n[, msg])
   *
   * Asserts that the target's `length` or `size` is equal to the given number
   * `n`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *     expect('foo').to.have.lengthOf(3);
   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);
   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
   *
   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often
   * best to assert that the target's `length` property is equal to its expected
   * value, rather than not equal to one of many unexpected values.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.not.have.lengthOf(4); // Not recommended
   *
   * `.lengthOf` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
   *
   * `.lengthOf` can also be used as a language chain, causing all `.above`,
   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the
   * chain to use the target's `length` property as the target. However, it's
   * often best to assert that the target's `length` property is equal to its
   * expected length, rather than asserting that its `length` property falls
   * within some range of values.
   *
   *     // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *
   *     // Not recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2);
   *     expect([1, 2, 3]).to.have.lengthOf.below(4);
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
   *
   * Due to a compatibility issue, the alias `.length` can't be chained directly
   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used
   * interchangeably with `.lengthOf` in every situation. It's recommended to
   * always use `.lengthOf` instead of `.length`.
   *
   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
   *
   * @name lengthOf
   * @alias length
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain() {
    flag(this, 'doLength', true);
  }

  function assertLength(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        objType = _.type(obj).toLowerCase(),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi'),
        descriptor = 'length',
        itemsCount;

    switch (objType) {
      case 'map':
      case 'set':
        descriptor = 'size';
        itemsCount = obj.size;
        break;

      default:
        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        itemsCount = obj.length;
    }

    this.assert(itemsCount == n, 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' of #{act}', n, itemsCount);
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);
  /**
   * ### .match(re[, msg])
   *
   * Asserts that the target matches the given regular expression `re`.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * Add `.not` earlier in the chain to negate `.match`.
   *
   *     expect('foobar').to.not.match(/taco/);
   *
   * `.match` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect('foobar').to.match(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.match(/taco/);
   *
   * The alias `.matches` can be used interchangeably with `.match`.
   *
   * @name match
   * @alias matches
   * @param {RegExp} re
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(re.exec(obj), 'expected #{this} to match ' + re, 'expected #{this} not to match ' + re);
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);
  /**
   * ### .string(str[, msg])
   *
   * Asserts that the target string contains the given substring `str`.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * Add `.not` earlier in the chain to negate `.string`.
   *
   *     expect('foobar').to.not.have.string('taco');
   *
   * `.string` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect('foobar').to.have.string('taco', 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.have.string('taco');
   *
   * @name string
   * @param {String} str
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('string');
    this.assert(~obj.indexOf(str), 'expected #{this} to contain ' + _.inspect(str), 'expected #{this} to not contain ' + _.inspect(str));
  });
  /**
   * ### .keys(key1[, key2[, ...]])
   *
   * Asserts that the target object, array, map, or set has the given keys. Only
   * the target's own inherited properties are included in the search.
   *
   * When the target is an object or array, keys can be provided as one or more
   * string arguments, a single array argument, or a single object argument. In
   * the latter case, only the keys in the given object matter; the values are
   * ignored.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *     expect(['x', 'y']).to.have.all.keys(0, 1);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
   *     expect(['x', 'y']).to.have.all.keys([0, 1]);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
   *
   * When the target is a map or set, each key must be provided as a separate
   * argument.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
   *
   * Because `.keys` does different things based on the target's type, it's
   * important to check the target's type before using `.keys`. See the `.a` doc
   * for info on testing a target's type.
   *
   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
   *
   * By default, strict (`===`) equality is used to compare keys of maps and
   * sets. Add `.deep` earlier in the chain to use deep equality instead. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
   *
   * By default, the target must have all of the given keys and no more. Add
   * `.any` earlier in the chain to only require that the target have at least
   * one of the given keys. Also, add `.not` earlier in the chain to negate
   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use
   * `.all` when asserting `.keys` without negation.
   *
   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts
   * exactly what's expected of the output, whereas `.not.all.keys` creates
   * uncertain expectations.
   *
   *     // Recommended; asserts that target doesn't have any of the given keys
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   *     // Not recommended; asserts that target doesn't have all of the given
   *     // keys but may or may not have some of them
   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
   *
   * When asserting `.keys` without negation, `.all` is preferred because
   * `.all.keys` asserts exactly what's expected of the output, whereas
   * `.any.keys` creates uncertain expectations.
   *
   *     // Recommended; asserts that target has all the given keys
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   *     // Not recommended; asserts that target has at least one of the given
   *     // keys but may or may not have more of them
   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` appear
   * earlier in the chain. However, it's often best to add `.all` anyway because
   * it improves readability.
   *
   *     // Both assertions are identical
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
   *
   * Add `.include` earlier in the chain to require that the target's keys be a
   * superset of the expected keys, rather than identical sets.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   * However, if `.any` and `.include` are combined, only the `.any` takes
   * effect. The `.include` is ignored in this case.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
   *
   * The alias `.key` can be used interchangeably with `.keys`.
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys(keys) {
    var obj = flag(this, 'object'),
        objType = _.type(obj),
        keysType = _.type(keys),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        str,
        deepStr = '',
        actual,
        ok = true,
        flagMsg = flag(this, 'message');

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';

    if (objType === 'Map' || objType === 'Set') {
      deepStr = isDeep ? 'deeply ' : '';
      actual = []; // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.

      obj.forEach(function (val, key) {
        actual.push(key);
      });

      if (keysType !== 'Array') {
        keys = Array.prototype.slice.call(arguments);
      }
    } else {
      actual = _.getOwnEnumerableProperties(obj);

      switch (keysType) {
        case 'Array':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          break;

        case 'Object':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          keys = Object.keys(keys);
          break;

        default:
          keys = Array.prototype.slice.call(arguments);
      } // Only stringify non-Symbols because Symbols would become "Symbol()"


      keys = keys.map(function (val) {
        return typeof val === 'symbol' ? val : String(val);
      });
    }

    if (!keys.length) {
      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);
    }

    var len = keys.length,
        any = flag(this, 'any'),
        all = flag(this, 'all'),
        expected = keys;

    if (!any && !all) {
      all = true;
    } // Has any


    if (any) {
      ok = expected.some(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });
    } // Has all


    if (all) {
      ok = expected.every(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });

      if (!flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    } // Key string


    if (len > 1) {
      keys = keys.map(function (key) {
        return _.inspect(key);
      });
      var last = keys.pop();

      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }

      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    } // Form


    str = (len > 1 ? 'keys ' : 'key ') + str; // Have / include

    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str; // Assertion

    this.assert(ok, 'expected #{this} to ' + deepStr + str, 'expected #{this} to not ' + deepStr + str, expected.slice(0).sort(_.compareByInspect), actual.sort(_.compareByInspect), true);
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);
  /**
   * ### .throw([errorLike], [errMsgMatcher], [msg])
   *
   * When no arguments are provided, `.throw` invokes the target function and
   * asserts that an error is thrown.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw();
   *
   * When one argument is provided, and it's an error constructor, `.throw`
   * invokes the target function and asserts that an error is thrown that's an
   * instance of that error constructor.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError);
   *
   * When one argument is provided, and it's an error instance, `.throw` invokes
   * the target function and asserts that an error is thrown that's strictly
   * (`===`) equal to that error instance.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(err);
   *
   * When one argument is provided, and it's a string, `.throw` invokes the
   * target function and asserts that an error is thrown with a message that
   * contains that string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw('salmon');
   *
   * When one argument is provided, and it's a regular expression, `.throw`
   * invokes the target function and asserts that an error is thrown with a
   * message that matches that regular expression.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(/salmon/);
   *
   * When two arguments are provided, and the first is an error instance or
   * constructor, and the second is a string or regular expression, `.throw`
   * invokes the function and asserts that an error is thrown that fulfills both
   * conditions as described above.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon');
   *     expect(badFn).to.throw(TypeError, /salmon/);
   *     expect(badFn).to.throw(err, 'salmon');
   *     expect(badFn).to.throw(err, /salmon/);
   *
   * Add `.not` earlier in the chain to negate `.throw`.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw();
   *
   * However, it's dangerous to negate `.throw` when providing any arguments.
   * The problem is that it creates uncertain expectations by asserting that the
   * target either doesn't throw an error, or that it throws an error but of a
   * different type than the given type, or that it throws an error of the given
   * type but with a message that doesn't include the given string. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to throw an error, it's often best to assert
   * exactly that.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw(); // Recommended
   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * When the target is expected to throw an error, it's often best to assert
   * that the error is of its expected type, and has a message that includes an
   * expected string, rather than asserting that it doesn't have one of many
   * unexpected types, and doesn't have a message that includes some string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * `.throw` changes the target of any assertions that follow in the chain to
   * be the error object that's thrown.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     err.code = 42;
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError).with.property('code', 42);
   *
   * `.throw` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`. When not providing two arguments, always use
   * the second form.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
   *     expect(goodFn, 'nooo why fail??').to.throw();
   *
   * Due to limitations in ES5, `.throw` may not always work as expected when
   * using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing the built-in `Error` object and
   * then passing the subclassed constructor to `.throw`. See your transpiler's
   * docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * Beware of some common mistakes when using the `throw` assertion. One common
   * mistake is to accidentally invoke the function yourself instead of letting
   * the `throw` assertion invoke the function for you. For example, when
   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as
   * the target for the assertion.
   *
   *     expect(fn).to.throw();     // Good! Tests `fn` as desired
   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
   *
   * If you need to assert that your function `fn` throws when passed certain
   * arguments, then wrap a call to `fn` inside of another function.
   *
   *     expect(function () { fn(42); }).to.throw();  // Function expression
   *     expect(() => fn(42)).to.throw();             // ES6 arrow function
   *
   * Another common mistake is to provide an object method (or any stand-alone
   * function that relies on `this`) as the target of the assertion. Doing so is
   * problematic because the `this` context will be lost when the function is
   * invoked by `.throw`; there's no way for it to know what `this` is supposed
   * to be. There are two ways around this problem. One solution is to wrap the
   * method or function call inside of another function. Another solution is to
   * use `bind`.
   *
   *     expect(function () { cat.meow(); }).to.throw();  // Function expression
   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
   *     expect(cat.meow.bind(cat)).to.throw();           // Bind
   *
   * Finally, it's worth mentioning that it's a best practice in JavaScript to
   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,
   * `TypeError`, and user-defined objects that extend `Error`. No other type of
   * value will generate a stack trace when initialized. With that said, the
   * `throw` assertion does technically support any type of value being thrown,
   * not just `Error` and its derivatives.
   *
   * The aliases `.throws` and `.Throw` can be used interchangeably with
   * `.throw`.
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {Error|ErrorConstructor} errorLike
   * @param {String|RegExp} errMsgMatcher error message
   * @param {String} msg _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows(errorLike, errMsgMatcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate') || false;
    new Assertion(obj, flagMsg, ssfi, true).is.a('function');

    if (errorLike instanceof RegExp || typeof errorLike === 'string') {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var caughtErr;

    try {
      obj();
    } catch (err) {
      caughtErr = err;
    } // If we have the negate flag enabled and at least one valid argument it means we do expect an error
    // but we want it to match a given set of criteria


    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined; // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
    // See Issue #551 and PR #683@GitHub

    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
    var errorLikeFail = false;
    var errMsgMatcherFail = false; // Checking if error was thrown

    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
      // We need this to display results correctly according to their types
      var errorLikeString = 'an error';

      if (errorLike instanceof Error) {
        errorLikeString = '#{exp}';
      } else if (errorLike) {
        errorLikeString = _.checkError.getConstructorName(errorLike);
      }

      this.assert(caughtErr, 'expected #{this} to throw ' + errorLikeString, 'expected #{this} to not throw an error but #{act} was thrown', errorLike && errorLike.toString(), caughtErr instanceof Error ? caughtErr.toString() : typeof caughtErr === 'string' ? caughtErr : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    if (errorLike && caughtErr) {
      // We should compare instances only if `errorLike` is an instance of `Error`
      if (errorLike instanceof Error) {
        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);

        if (isCompatibleInstance === negate) {
          // These checks were created to ensure we won't fail too soon when we've got both args and a negate
          // See Issue #551 and PR #683@GitHub
          if (everyArgIsDefined && negate) {
            errorLikeFail = true;
          } else {
            this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : ''), errorLike.toString(), caughtErr.toString());
          }
        }
      }

      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);

      if (isCompatibleConstructor === negate) {
        if (everyArgIsDefined && negate) {
          errorLikeFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
        }
      }
    }

    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {
      // Here we check compatible messages
      var placeholder = 'including';

      if (errMsgMatcher instanceof RegExp) {
        placeholder = 'matching';
      }

      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);

      if (isCompatibleMessage === negate) {
        if (everyArgIsDefined && negate) {
          errMsgMatcherFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}', 'expected #{this} to throw error not ' + placeholder + ' #{exp}', errMsgMatcher, _.checkError.getMessage(caughtErr));
        }
      }
    } // If both assertions failed and both should've matched we throw an error


    if (errorLikeFail && errMsgMatcherFail) {
      this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    flag(this, 'object', caughtErr);
  }
  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);
  /**
   * ### .respondTo(method[, msg])
   *
   * When the target is a non-function object, `.respondTo` asserts that the
   * target has a method with the given name `method`. The method can be own or
   * inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.respondTo('meow');
   *
   * When the target is a function, `.respondTo` asserts that the target's
   * `prototype` property has a method with the given name `method`. Again, the
   * method can be own or inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(Cat).to.respondTo('meow');
   *
   * Add `.itself` earlier in the chain to force `.respondTo` to treat the
   * target as a non-function object, even if it's a function. Thus, it asserts
   * that the target has a method with the given name `method`, rather than
   * asserting that the target's `prototype` property has a method with the
   * given name `method`.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * When not adding `.itself`, it's important to check the target's type before
   * using `.respondTo`. See the `.a` doc for info on checking a target's type.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
   *
   * Add `.not` earlier in the chain to negate `.respondTo`.
   *
   *     function Dog () {}
   *     Dog.prototype.bark = function () {};
   *
   *     expect(new Dog()).to.not.respondTo('meow');
   *
   * `.respondTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect({}).to.respondTo('meow', 'nooo why fail??');
   *     expect({}, 'nooo why fail??').to.respondTo('meow');
   *
   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo(method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        itself = flag(this, 'itself'),
        context = 'function' === typeof obj && !itself ? obj.prototype[method] : obj[method];
    this.assert('function' === typeof context, 'expected #{this} to respond to ' + _.inspect(method), 'expected #{this} to not respond to ' + _.inspect(method));
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);
  /**
   * ### .itself
   *
   * Forces all `.respondTo` assertions that follow in the chain to behave as if
   * the target is a non-function object, even if it's a function. Thus, it
   * causes `.respondTo` to assert that the target has a method with the given
   * name, rather than asserting that the target's `prototype` property has a
   * method with the given name.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });
  /**
   * ### .satisfy(matcher[, msg])
   *
   * Invokes the given `matcher` function with the target being passed as the
   * first argument, and asserts that the value returned is truthy.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 0;
   *     });
   *
   * Add `.not` earlier in the chain to negate `.satisfy`.
   *
   *     expect(1).to.not.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * `.satisfy` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 2;
   *     }, 'nooo why fail??');
   *
   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * The alias `.satisfies` can be used interchangeably with `.satisfy`.
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy(matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(result, 'expected #{this} to satisfy ' + _.objDisplay(matcher), 'expected #{this} to not satisfy' + _.objDisplay(matcher), flag(this, 'negate') ? false : true, result);
  }

  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);
  /**
   * ### .closeTo(expected, delta[, msg])
   *
   * Asserts that the target is a number that's within a given +/- `delta` range
   * of the given number `expected`. However, it's often best to assert that the
   * target is equal to its expected value.
   *
   *     // Recommended
   *     expect(1.5).to.equal(1.5);
   *
   *     // Not recommended
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *     expect(1.5).to.be.closeTo(2, 0.5);
   *     expect(1.5).to.be.closeTo(1, 1);
   *
   * Add `.not` earlier in the chain to negate `.closeTo`.
   *
   *     expect(1.5).to.equal(1.5); // Recommended
   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
   *
   * `.closeTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
   *
   * The alias `.approximately` can be used interchangeably with `.closeTo`.
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('number');

    if (typeof expected !== 'number' || typeof delta !== 'number') {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      throw new AssertionError(flagMsg + 'the arguments to closeTo or approximately must be numbers', undefined, ssfi);
    }

    this.assert(Math.abs(obj - expected) <= delta, 'expected #{this} to be close to ' + expected + ' +/- ' + delta, 'expected #{this} not to be close to ' + expected + ' +/- ' + delta);
  }

  Assertion.addMethod('closeTo', closeTo);
  Assertion.addMethod('approximately', closeTo); // Note: Duplicates are ignored if testing for inclusion instead of sameness.

  function isSubsetOf(subset, superset, cmp, contains, ordered) {
    if (!contains) {
      if (subset.length !== superset.length) return false;
      superset = superset.slice();
    }

    return subset.every(function (elem, idx) {
      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];

      if (!cmp) {
        var matchIdx = superset.indexOf(elem);
        if (matchIdx === -1) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      }

      return superset.some(function (elem2, matchIdx) {
        if (!cmp(elem, elem2)) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      });
    });
  }
  /**
   * ### .members(set[, msg])
   *
   * Asserts that the target array has the same members as the given array
   * `set`.
   *
   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
   *
   * By default, members are compared using strict (`===`) equality. Add `.deep`
   * earlier in the chain to use deep equality instead. See the `deep-eql`
   * project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   * By default, order doesn't matter. Add `.ordered` earlier in the chain to
   * require that members appear in the same order.
   *
   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
   *     expect([1, 2, 3]).to.have.members([2, 1, 3])
   *       .but.not.ordered.members([2, 1, 3]);
   *
   * By default, both arrays must be the same size. Add `.include` earlier in
   * the chain to require that the target's members be a superset of the
   * expected members. Note that duplicates are ignored in the subset when
   * `.include` is added.
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * `.deep`, `.ordered`, and `.include` can all be combined. However, if
   * `.include` and `.ordered` are combined, the ordering begins at the start of
   * both arrays.
   *
   *     expect([{a: 1}, {b: 2}, {c: 3}])
   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
   *
   * Add `.not` earlier in the chain to negate `.members`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the target array doesn't have all of the same members as
   * the given array `set` but may or may not have some of them. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
   *
   * `.members` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
   *
   * @name members
   * @param {Array} set
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */


  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');
    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');
    var contains = flag(this, 'contains');
    var ordered = flag(this, 'ordered');
    var subject, failMsg, failNegateMsg;

    if (contains) {
      subject = ordered ? 'an ordered superset' : 'a superset';
      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';
      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';
    } else {
      subject = ordered ? 'ordered members' : 'members';
      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';
      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';
    }

    var cmp = flag(this, 'deep') ? _.eql : undefined;
    this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, true);
  });
  /**
   * ### .oneOf(list[, msg])
   *
   * Asserts that the target is a member of the given array `list`. However,
   * it's often best to assert that the target is equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
   *
   * Comparisons are performed using strict (`===`) equality.
   *
   * Add `.not` earlier in the chain to negate `.oneOf`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
   *
   * `.oneOf` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf(list, msg) {
    if (msg) flag(this, 'message', msg);
    var expected = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');
    this.assert(list.indexOf(expected) > -1, 'expected #{this} to be one of #{exp}', 'expected #{this} to not be one of #{exp}', list, expected);
  }

  Assertion.addMethod('oneOf', oneOf);
  /**
   * ### .change(subject[, prop[, msg]])
   *
   * When one argument is provided, `.change` asserts that the given function
   * `subject` returns a different value when it's invoked before the target
   * function compared to when it's invoked afterward. However, it's often best
   * to assert that `subject` is equal to its expected value.
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     // Recommended
   *     expect(getDots()).to.equal('');
   *     addDot();
   *     expect(getDots()).to.equal('.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(getDots);
   *
   * When two arguments are provided, `.change` asserts that the value of the
   * given object `subject`'s `prop` property is different before invoking the
   * target function compared to afterward.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     // Recommended
   *     expect(myObj).to.have.property('dots', '');
   *     addDot();
   *     expect(myObj).to.have.property('dots', '.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(myObj, 'dots');
   *
   * Strict (`===`) equality is used to compare before and after values.
   *
   * Add `.not` earlier in the chain to negate `.change`.
   *
   *     var dots = ''
   *       , noop = function () {}
   *       , getDots = function () { return dots; };
   *
   *     expect(noop).to.not.change(getDots);
   *
   *     var myObj = {dots: ''}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'dots');
   *
   * `.change` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
   *
   * `.change` also causes all `.by` assertions that follow in the chain to
   * assert how much a numeric subject was increased or decreased by. However,
   * it's dangerous to use `.change.by`. The problem is that it creates
   * uncertain expectations by asserting that the subject either increases by
   * the given delta, or that it decreases by the given delta. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * The alias `.changes` can be used interchangeably with `.change`.
   *
   * @name change
   * @alias changes
   * @param {String} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop; // This gets flagged because of the .by(delta) assertion

    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'change');
    flag(this, 'realDelta', final !== initial);
    this.assert(initial !== final, 'expected ' + msgObj + ' to change', 'expected ' + msgObj + ' to not change');
  }

  Assertion.addMethod('change', assertChanges);
  Assertion.addMethod('changes', assertChanges);
  /**
   * ### .increase(subject[, prop[, msg]])
   *
   * When one argument is provided, `.increase` asserts that the given function
   * `subject` returns a greater number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.increase` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * greater of a number is returned. It's often best to assert that the return
   * value increased by the expected amount, rather than asserting it increased
   * by any amount.
   *
   *     var val = 1
   *       , addTwo = function () { val += 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(addTwo).to.increase(getVal).by(2); // Recommended
   *     expect(addTwo).to.increase(getVal); // Not recommended
   *
   * When two arguments are provided, `.increase` asserts that the value of the
   * given object `subject`'s `prop` property is greater after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.increase`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either decreases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to decrease, it's often best to assert that it
   * decreased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
   *
   * `.increase` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.increase(getVal);
   *
   * The alias `.increases` can be used interchangeably with `.increase`.
   *
   * @name increase
   * @alias increases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'increase');
    flag(this, 'realDelta', final - initial);
    this.assert(final - initial > 0, 'expected ' + msgObj + ' to increase', 'expected ' + msgObj + ' to not increase');
  }

  Assertion.addMethod('increase', assertIncreases);
  Assertion.addMethod('increases', assertIncreases);
  /**
   * ### .decrease(subject[, prop[, msg]])
   *
   * When one argument is provided, `.decrease` asserts that the given function
   * `subject` returns a lesser number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.decrease` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * lesser of a number is returned. It's often best to assert that the return
   * value decreased by the expected amount, rather than asserting it decreased
   * by any amount.
   *
   *     var val = 1
   *       , subtractTwo = function () { val -= 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
   *     expect(subtractTwo).to.decrease(getVal); // Not recommended
   *
   * When two arguments are provided, `.decrease` asserts that the value of the
   * given object `subject`'s `prop` property is lesser after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.decrease`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either increases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to increase, it's often best to assert that it
   * increased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * `.decrease` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.decrease(getVal);
   *
   * The alias `.decreases` can be used interchangeably with `.decrease`.
   *
   * @name decrease
   * @alias decreases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'decrease');
    flag(this, 'realDelta', initial - final);
    this.assert(final - initial < 0, 'expected ' + msgObj + ' to decrease', 'expected ' + msgObj + ' to not decrease');
  }

  Assertion.addMethod('decrease', assertDecreases);
  Assertion.addMethod('decreases', assertDecreases);
  /**
   * ### .by(delta[, msg])
   *
   * When following an `.increase` assertion in the chain, `.by` asserts that
   * the subject of the `.increase` assertion increased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   * When following a `.decrease` assertion in the chain, `.by` asserts that the
   * subject of the `.decrease` assertion decreased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
   *
   * When following a `.change` assertion in the chain, `.by` asserts that the
   * subject of the `.change` assertion either increased or decreased by the
   * given `delta`. However, it's dangerous to use `.change.by`. The problem is
   * that it creates uncertain expectations. It's often best to identify the
   * exact output that's expected, and then write an assertion that only accepts
   * that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.by`. However, it's often best
   * to assert that the subject changed by its expected delta, rather than
   * asserting that it didn't change by one of countless unexpected deltas.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     // Recommended
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   *     // Not recommended
   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
   *
   * `.by` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
   *
   * @name by
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDelta(delta, msg) {
    if (msg) flag(this, 'message', msg);
    var msgObj = flag(this, 'deltaMsgObj');
    var initial = flag(this, 'initialDeltaValue');
    var final = flag(this, 'finalDeltaValue');
    var behavior = flag(this, 'deltaBehavior');
    var realDelta = flag(this, 'realDelta');
    var expression;

    if (behavior === 'change') {
      expression = Math.abs(final - initial) === Math.abs(delta);
    } else {
      expression = realDelta === Math.abs(delta);
    }

    this.assert(expression, 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta, 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta);
  }

  Assertion.addMethod('by', assertDelta);
  /**
   * ### .extensible
   *
   * Asserts that the target is extensible, which means that new properties can
   * be added to it. Primitives are never extensible.
   *
   *     expect({a: 1}).to.be.extensible;
   *
   * Add `.not` earlier in the chain to negate `.extensible`.
   *
   *     var nonExtensibleObject = Object.preventExtensions({})
   *       , sealedObject = Object.seal({})
   *       , frozenObject = Object.freeze({});
   *
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *     expect(1).to.not.be.extensible;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(1, 'nooo why fail??').to.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('extensible', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior for ES5 environments.

    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
    this.assert(isExtensible, 'expected #{this} to be extensible', 'expected #{this} to not be extensible');
  });
  /**
   * ### .sealed
   *
   * Asserts that the target is sealed, which means that new properties can't be
   * added to it, and its existing properties can't be reconfigured or deleted.
   * However, it's possible that its existing properties can still be reassigned
   * to different values. Primitives are always sealed.
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect(1).to.be.sealed;
   *
   * Add `.not` earlier in the chain to negate `.sealed`.
   *
   *     expect({a: 1}).to.not.be.sealed;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('sealed', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior for ES5 environments.

    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
    this.assert(isSealed, 'expected #{this} to be sealed', 'expected #{this} to not be sealed');
  });
  /**
   * ### .frozen
   *
   * Asserts that the target is frozen, which means that new properties can't be
   * added to it, and its existing properties can't be reassigned to different
   * values, reconfigured, or deleted. Primitives are always frozen.
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect(1).to.be.frozen;
   *
   * Add `.not` earlier in the chain to negate `.frozen`.
   *
   *     expect({a: 1}).to.not.be.frozen;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('frozen', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior for ES5 environments.

    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
    this.assert(isFrozen, 'expected #{this} to be frozen', 'expected #{this} to not be frozen');
  });
  /**
   * ### .finite
   *
   * Asserts that the target is a number, and isn't `NaN` or positive/negative
   * `Infinity`.
   *
   *     expect(1).to.be.finite;
   *
   * Add `.not` earlier in the chain to negate `.finite`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either isn't a number, or that it's `NaN`, or
   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to be a number, it's often best to assert
   * that it's the expected type, rather than asserting that it isn't one of
   * many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.finite; // Not recommended
   *
   * When the target is expected to be `NaN`, it's often best to assert exactly
   * that.
   *
   *     expect(NaN).to.be.NaN; // Recommended
   *     expect(NaN).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be positive infinity, it's often best to
   * assert exactly that.
   *
   *     expect(Infinity).to.equal(Infinity); // Recommended
   *     expect(Infinity).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be negative infinity, it's often best to
   * assert exactly that.
   *
   *     expect(-Infinity).to.equal(-Infinity); // Recommended
   *     expect(-Infinity).to.not.be.finite; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect('foo', 'nooo why fail??').to.be.finite;
   *
   * @name finite
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('finite', function (msg) {
    var obj = flag(this, 'object');
    this.assert(typeof obj === 'number' && isFinite(obj), 'expected #{this} to be a finite number', 'expected #{this} to not be a finite number');
  });
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var expect = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   *     expect.fail();
   *     expect.fail("custom error message");
   *     expect.fail(1, 2);
   *     expect.fail(1, 2, "custom error message");
   *     expect.fail(1, 2, "custom error message", ">");
   *     expect.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace BDD
   * @api public
   */


  chai.expect.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
      message = actual;
      actual = undefined;
    }

    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, chai.expect.fail);
  };
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var should = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould() {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === 'function' && this instanceof Symbol) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }

      return new Assertion(this, null, shouldGetter);
    }

    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } // modify Object.prototype to have `should`


    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter,
      get: shouldGetter,
      configurable: true
    });
    var should = {};
    /**
     * ### .fail([message])
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     *     should.fail();
     *     should.fail("custom error message");
     *     should.fail(1, 2);
     *     should.fail(1, 2, "custom error message");
     *     should.fail(1, 2, "custom error message", ">");
     *     should.fail(1, 2, undefined, ">");
     *
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace BDD
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      if (arguments.length < 2) {
        message = actual;
        actual = undefined;
      }

      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
        actual: actual,
        expected: expected,
        operator: operator
      }, should.fail);
    };
    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */


    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };
    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */


    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }; // negation


    should.not = {};
    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };
    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */


    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    };

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];
    return should;
  }
  chai.should = loadShould;
  chai.Should = loadShould;
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var assert = function (chai, util) {
  /*!
   * Chai dependencies.
   */
  var Assertion = chai.Assertion,
      flag = util.flag;
  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert, true);
    test.assert(express, errmsg, '[ negation message unavailable ]');
  };
  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   *     assert.fail();
   *     assert.fail("custom error message");
   *     assert.fail(1, 2);
   *     assert.fail(1, 2, "custom error message");
   *     assert.fail(1, 2, "custom error message", ">");
   *     assert.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */


  assert.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
      // Comply with Node's fail([message]) interface
      message = actual;
      actual = undefined;
    }

    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, assert.fail);
  };
  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isOk = function (val, msg) {
    new Assertion(val, msg, assert.isOk, true).is.ok;
  };
  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
  };
  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal, true);
    test.assert(exp == flag(test, 'object'), 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{act}', exp, act, true);
  };
  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual, true);
    test.assert(exp != flag(test, 'object'), 'expected #{this} to not equal #{exp}', 'expected #{this} to equal #{act}', exp, act, true);
  };
  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
  };
  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
  };
  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @alias deepStrictEqual
   * @namespace Assert
   * @api public
   */


  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
  };
  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
  };
  /**
  * ### .isAbove(valueToCheck, valueToBeAbove, [message])
  *
  * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.
  *
  *     assert.isAbove(5, 2, '5 is strictly greater than 2');
  *
  * @name isAbove
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAbove
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
  };
  /**
  * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
  *
  * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.
  *
  *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
  *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
  *
  * @name isAtLeast
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtLeast
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
  };
  /**
  * ### .isBelow(valueToCheck, valueToBeBelow, [message])
  *
  * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.
  *
  *     assert.isBelow(3, 6, '3 is strictly less than 6');
  *
  * @name isBelow
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeBelow
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
  };
  /**
  * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
  *
  * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.
  *
  *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
  *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
  *
  * @name isAtMost
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtMost
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
  };
  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isTrue = function (val, msg) {
    new Assertion(val, msg, assert.isTrue, true).is['true'];
  };
  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
  };
  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFalse = function (val, msg) {
    new Assertion(val, msg, assert.isFalse, true).is['false'];
  };
  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
  };
  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNull = function (val, msg) {
    new Assertion(val, msg, assert.isNull, true).to.equal(null);
  };
  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
  };
  /**
   * ### .isNaN
   *
   * Asserts that value is NaN.
   *
   *     assert.isNaN(NaN, 'NaN is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
  };
  /**
   * ### .isNotNaN
   *
   * Asserts that value is not NaN.
   *
   *     assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;
  };
  /**
   * ### .exists
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi';
   *
   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');
   *
   * @name exists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.exists = function (val, msg) {
    new Assertion(val, msg, assert.exists, true).to.exist;
  };
  /**
   * ### .notExists
   *
   * Asserts that the target is either `null` or `undefined`.
   *
   *     var bar = null
   *       , baz;
   *
   *     assert.notExists(bar);
   *     assert.notExists(baz, 'baz is either null or undefined');
   *
   * @name notExists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notExists = function (val, msg) {
    new Assertion(val, msg, assert.notExists, true).to.not.exist;
  };
  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);
  };
  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isDefined = function (val, msg) {
    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);
  };
  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFunction = function (val, msg) {
    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');
  };
  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');
  };
  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isObject = function (val, msg) {
    new Assertion(val, msg, assert.isObject, true).to.be.a('object');
  };
  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');
  };
  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isArray = function (val, msg) {
    new Assertion(val, msg, assert.isArray, true).to.be.an('array');
  };
  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');
  };
  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isString = function (val, msg) {
    new Assertion(val, msg, assert.isString, true).to.be.a('string');
  };
  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotString = function (val, msg) {
    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');
  };
  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');
  };
  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');
  };
  /**
  * ### .isFinite(value, [message])
  *
  * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.
  *
  *     var cups = 2;
  *     assert.isFinite(cups, 'how many cups');
  *
  *     assert.isFinite(NaN); // throws
  *
  * @name isFinite
  * @param {Number} value
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isFinite = function (val, msg) {
    new Assertion(val, msg, assert.isFinite, true).to.be.finite;
  };
  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');
  };
  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');
  };
  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);
  };
  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);
  };
  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);
  };
  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(type);
  };
  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.include([1,2,3], 2, 'array contains value');
   *     assert.include('foobar', 'foo', 'string contains substring');
   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
   *
   * Strict equality (===) is used. When asserting the inclusion of a value in
   * an array, the array is searched for an element that's strictly equal to the
   * given value. When asserting a subset of properties in an object, the object
   * is searched for the given property keys, checking that each one is present
   * and strictly equal to the given property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.include([obj1, obj2], obj1);
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include, true).include(inc);
  };
  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.notInclude([1,2,3], 4, "array doesn't contain value");
   *     assert.notInclude('foobar', 'baz', "string doesn't contain substring");
   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
   *
   * Strict equality (===) is used. When asserting the absence of a value in an
   * array, the array is searched to confirm the absence of an element that's
   * strictly equal to the given value. When asserting a subset of properties in
   * an object, the object is searched to confirm that at least one of the given
   * property keys is either not present or not strictly equal to the given
   * property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notInclude([obj1, obj2], {a: 1});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
  };
  /**
   * ### .deepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.deepInclude([obj1, obj2], {a: 1});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
   *
   * @name deepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
  };
  /**
   * ### .notDeepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notDeepInclude([obj1, obj2], {a: 9});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
   *
   * @name notDeepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
  };
  /**
   * ### .nestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
   *
   * @name nestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
  };
  /**
   * ### .notNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
   *
   * @name notNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(inc);
  };
  /**
   * ### .deepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
   *
   * @name deepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(inc);
  };
  /**
   * ### .notDeepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
   *
   * @name notDeepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepNestedInclude, true).not.deep.nested.include(inc);
  };
  /**
   * ### .ownInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     assert.ownInclude({ a: 1 }, { a: 1 });
   *
   * @name ownInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.ownInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
  };
  /**
   * ### .notOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     assert.notOwnInclude({ a: 1 }, { b: 2 });
   *
   * @name notOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
  };
  /**
   * ### .deepOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties and checking for deep equality.
   *
   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
   *
   * @name deepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
  };
  /**
  * ### .notDeepOwnInclude(haystack, needle, [message])
  *
  * Asserts that 'haystack' includes 'needle'.
  * Can be used to assert the absence of a subset of properties in an
  * object while ignoring inherited properties and checking for deep equality.
  *
  *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
  *
  * @name notDeepOwnInclude
  * @param {Object} haystack
  * @param {Object} needle
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.notDeepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(inc);
  };
  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg, assert.match, true).to.match(re);
  };
  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
  };
  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *     assert.property({ tea: { green: 'matcha' }}, 'toString');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.property, true).to.have.property(prop);
  };
  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
  };
  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
  };
  /**
   * ### .notPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
   *
   * @name notPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(prop, val);
  };
  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a deep equality check.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(prop, val);
  };
  /**
   * ### .notDeepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a deep equality check.
   *
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *
   * @name notDeepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
  };
  /**
   * ### .ownProperty(object, property, [message])
   *
   * Asserts that `object` has a direct property named by `property`. Inherited
   * properties aren't checked.
   *
   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name ownProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.ownProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
  };
  /**
   * ### .notOwnProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by
   * `property`. Inherited properties aren't checked.
   *
   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
   *     assert.notOwnProperty({}, 'toString');
   *
   * @name notOwnProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.notOwnProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(prop);
  };
  /**
   * ### .ownPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a strict equality check (===).
   * Inherited properties aren't checked.
   *
   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
   *
   * @name ownPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.ownPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(prop, value);
  };
  /**
   * ### .notOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a strict equality check
   * (===). Inherited properties aren't checked.
   *
   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notOwnPropertyVal, true).to.not.have.own.property(prop, value);
  };
  /**
   * ### .deepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a deep equality check. Inherited
   * properties aren't checked.
   *
   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value);
  };
  /**
   * ### .notDeepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a deep equality check.
   * Inherited properties aren't checked.
   *
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notDeepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value);
  };
  /**
   * ### .nestedProperty(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`, which can be a string using dot- and bracket-notation for
   * nested reference.
   *
   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name nestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(prop);
  };
  /**
   * ### .notNestedProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for nested reference. The
   * property cannot exist on the object nor anywhere in its prototype chain.
   *
   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notNestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notNestedProperty, true).to.not.have.nested.property(prop);
  };
  /**
   * ### .nestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a strict equality check (===).
   *
   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name nestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.nestedPropertyVal, true).to.have.nested.property(prop, val);
  };
  /**
   * ### .notNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a strict equality check (===).
   *
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
   *
   * @name notNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
  };
  /**
   * ### .deepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with a value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a deep equality check.
   *
   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
   *
   * @name deepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
  };
  /**
   * ### .notDeepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a deep equality check.
   *
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
   *
   * @name notDeepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
  };
  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` or `size` with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');
   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
  };
  /**
   * ### .hasAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAnyKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
  };
  /**
   * ### .hasAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all and only all of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
  };
  /**
   * ### .containsAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name containsAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.containsAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(keys);
  };
  /**
   * ### .doesNotHaveAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has none of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAnyKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys);
  };
  /**
   * ### .doesNotHaveAllKeys(object, [keys], [message])
   *
   * Asserts that `object` does not have at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(keys);
  };
  /**
   * ### .hasAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(keys);
  };
  /**
    * ### .hasAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has all and only all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name hasAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.hasAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(keys);
  };
  /**
    * ### .containsAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` contains all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name containsAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.containsAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllDeepKeys, true).to.contain.all.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has none of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAnyDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` does not have at least one of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys);
  };
  /**
    * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
    *
    * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an
    * instance of `errorLike`.
    * If `errorLike` is an `Error` instance, asserts that the error thrown is the same
    * instance as `errorLike`.
    * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a
    * message matching `errMsgMatcher`.
    *
    *     assert.throws(fn, 'Error thrown must have this msg');
    *     assert.throws(fn, /Error thrown must have a msg that matches this/);
    *     assert.throws(fn, ReferenceError);
    *     assert.throws(fn, errorInstance);
    *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
    *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
    *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
    *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
    *
    * @name throws
    * @alias throw
    * @alias Throw
    * @param {Function} fn
    * @param {ErrorConstructor|Error} errorLike
    * @param {RegExp|String} errMsgMatcher
    * @param {String} message
    * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
    * @namespace Assert
    * @api public
    */


  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var assertErr = new Assertion(fn, msg, assert.throws, true).to.throw(errorLike, errMsgMatcher);
    return flag(assertErr, 'object');
  };
  /**
   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an
   * instance of `errorLike`.
   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same
   * instance as `errorLike`.
   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a
   * message matching `errMsgMatcher`.
   *
   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
   *     assert.doesNotThrow(fn, Error);
   *     assert.doesNotThrow(fn, errorInstance);
   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
   *     assert.doesNotThrow(fn, Error, /Error must not match this/);
   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
   *
   * @name doesNotThrow
   * @param {Function} fn
   * @param {ErrorConstructor} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */


  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    new Assertion(fn, msg, assert.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
  };
  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.operator = function (val, operator, val2, msg) {
    var ok;

    switch (operator) {
      case '==':
        ok = val == val2;
        break;

      case '===':
        ok = val === val2;
        break;

      case '>':
        ok = val > val2;
        break;

      case '>=':
        ok = val >= val2;
        break;

      case '<':
        ok = val < val2;
        break;

      case '<=':
        ok = val <= val2;
        break;

      case '!=':
        ok = val != val2;
        break;

      case '!==':
        ok = val !== val2;
        break;

      default:
        msg = msg ? msg + ': ' : msg;
        throw new chai.AssertionError(msg + 'Invalid operator "' + operator + '"', undefined, assert.operator);
    }

    var test = new Assertion(ok, msg, assert.operator, true);
    test.assert(true === flag(test, 'object'), 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2), 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2));
  };
  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
  };
  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.approximately, true).to.be.approximately(exp, delta);
  };
  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * strict equality check (===).
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set2);
  };
  /**
   * ### .notSameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a strict equality check (===).
   *
   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
   *
   * @name notSameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameMembers, true).to.not.have.same.members(set2);
  };
  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * deep equality check.
   *
   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepMembers, true).to.have.same.deep.members(set2);
  };
  /**
   * ### .notSameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a deep equality check.
   *
   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
   *
   * @name notSameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
  };
  /**
   * ### .sameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a strict equality check (===).
   *
   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
   *
   * @name sameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameOrderedMembers, true).to.have.same.ordered.members(set2);
  };
  /**
   * ### .notSameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a strict equality check (===).
   *
   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
   *
   * @name notSameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
  };
  /**
   * ### .sameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a deep equality check.
   *
   * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
   *
   * @name sameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .notSameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a deep equality check.
   *
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
   *
   * @name notSameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeMembers, true).to.include.members(subset);
  };
  /**
   * ### .notIncludeMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
   *
   * @name notIncludeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeMembers, true).to.not.include.members(subset);
  };
  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a deep
   * equality check. Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepMembers, true).to.include.deep.members(subset);
  };
  /**
   * ### .notIncludeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * deep equality check. Duplicates are ignored.
   *
   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
   *
   * @name notIncludeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
  };
  /**
   * ### .includeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
   *
   * @name includeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeOrderedMembers, true).to.include.ordered.members(subset);
  };
  /**
   * ### .notIncludeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
   *
   * @name notIncludeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
  };
  /**
   * ### .includeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
   *
   * @name includeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
  };
  /**
   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
   *
   * @name notIncludeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
  };
  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
  };
  /**
   * ### .changes(function, object, property, [message])
   *
   * Asserts that a function changes the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changes = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
  };
  /**
  * ### .changesBy(function, object, property, delta, [message])
  *
  * Asserts that a function changes the value of a property by an amount (delta).
  *
  *     var obj = { val: 10 };
  *     var fn = function() { obj.val += 2 };
  *     assert.changesBy(fn, obj, 'val', 2);
  *
  * @name changesBy
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {Number} change amount (delta)
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.changesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
  };
  /**
  * ### .doesNotChange(function, object, property, [message])
  *
  * Asserts that a function does not change the value of a property.
  *
  *     var obj = { val: 10 };
  *     var fn = function() { console.log('foo'); };
  *     assert.doesNotChange(fn, obj, 'val');
  *
  * @name doesNotChange
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.doesNotChange = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotChange, true).to.not.change(obj, prop);
  };
  /**
   * ### .changesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.changesButNotBy(fn, obj, 'val', 5);
   *
   * @name changesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
  };
  /**
   * ### .increases(function, object, property, [message])
   *
   * Asserts that a function increases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.increases, true).to.increase(obj, prop);
  };
  /**
   * ### .increasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.increasesBy(fn, obj, 'val', 10);
   *
   * @name increasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
  };
  /**
   * ### .doesNotIncrease(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotIncrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotIncrease, true).to.not.increase(obj, prop);
  };
  /**
   * ### .increasesButNotBy(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.increasesButNotBy(fn, obj, 'val', 10);
   *
   * @name increasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
  };
  /**
   * ### .decreases(function, object, property, [message])
   *
   * Asserts that a function decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.decreases, true).to.decrease(obj, prop);
  };
  /**
   * ### .decreasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val -= 5 };
   *     assert.decreasesBy(fn, obj, 'val', 5);
   *
   * @name decreasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
  };
  /**
   * ### .doesNotDecrease(function, object, property, [message])
   *
   * Asserts that a function does not decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecrease, true).to.not.decrease(obj, prop);
  };
  /**
   * ### .doesNotDecreaseBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
  };
  /**
   * ### .decreasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreasesButNotBy(fn, obj, 'val', 1);
   *
   * @name decreasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
  };
  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */


  assert.ifError = function (val) {
    if (val) {
      throw val;
    }
  };
  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
  };
  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
  };
  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
  };
  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
  };
  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
  };
  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
  };
  /**
   * ### .isEmpty(target)
   *
   * Asserts that the target does not contain any values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isEmpty([]);
   *     assert.isEmpty('');
   *     assert.isEmpty(new Map);
   *     assert.isEmpty({});
   *
   * @name isEmpty
   * @alias empty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
  };
  /**
   * ### .isNotEmpty(target)
   *
   * Asserts that the target contains values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isNotEmpty([1, 2]);
   *     assert.isNotEmpty('34');
   *     assert.isNotEmpty(new Set([5, 6]));
   *     assert.isNotEmpty({ key: 7 });
   *
   * @name isNotEmpty
   * @alias notEmpty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
  };
  /*!
   * Aliases.
   */


  (function alias(name, as) {
    assert[as] = assert[name];
    return alias;
  })('isOk', 'ok')('isNotOk', 'notOk')('throws', 'throw')('throws', 'Throw')('isExtensible', 'extensible')('isNotExtensible', 'notExtensible')('isSealed', 'sealed')('isNotSealed', 'notSealed')('isFrozen', 'frozen')('isNotFrozen', 'notFrozen')('isEmpty', 'empty')('isNotEmpty', 'notEmpty');
};var chai = createCommonjsModule(function (module, exports) {
  /*!
   * chai
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   */
  var used = [];
  /*!
   * Chai version
   */

  exports.version = '4.2.0';
  /*!
   * Assertion Error
   */

  exports.AssertionError = assertionError;
  /*!
   * Utils for plugins (not exported)
   */

  /**
   * # .use(function)
   *
   * Provides a way to extend the internals of Chai.
   *
   * @param {Function}
   * @returns {this} for chaining
   * @api public
   */

  exports.use = function (fn) {
    if (!~used.indexOf(fn)) {
      fn(exports, utils);
      used.push(fn);
    }

    return exports;
  };
  /*!
   * Utility Functions
   */


  exports.util = utils;
  /*!
   * Configuration
   */

  exports.config = config;
  /*!
   * Primary `Assertion` prototype
   */

  exports.use(assertion);
  /*!
   * Core Assertions
   */

  exports.use(assertions);
  /*!
   * Expect interface
   */

  exports.use(expect);
  /*!
   * Should interface
   */

  exports.use(should);
  /*!
   * Assert interface
   */

  exports.use(assert);
});
var chai_1 = chai.version;
var chai_2 = chai.AssertionError;
var chai_3 = chai.use;
var chai_4 = chai.util;
var chai_5 = chai.config;var chai$1 = chai;var typeDetect$1 = createCommonjsModule(function (module) {
  /* !
   * type-detect
   * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
   * MIT Licensed
   */

  var getPrototypeOfExists = typeof Object.getPrototypeOf === 'function';
  var promiseExists = typeof Promise === 'function';
  var globalObject = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : self; // eslint-disable-line

  var isDom = 'location' in globalObject && 'document' in globalObject;
  var htmlElementExists = typeof HTMLElement !== 'undefined';
  var isArrayExists = typeof Array.isArray === 'function';
  var symbolExists = typeof Symbol !== 'undefined';
  var mapExists = typeof Map !== 'undefined';
  var setExists = typeof Set !== 'undefined';
  var weakMapExists = typeof WeakMap !== 'undefined';
  var weakSetExists = typeof WeakSet !== 'undefined';
  var dataViewExists = typeof DataView !== 'undefined';
  var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
  var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
  var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
  var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
  var setIteratorPrototype = getPrototypeOfExists && setEntriesExists && Object.getPrototypeOf(new Set().entries());
  var mapIteratorPrototype = getPrototypeOfExists && mapEntriesExists && Object.getPrototypeOf(new Map().entries());
  var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
  var stringIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
  var toStringLeftSliceLength = 8;
  var toStringRightSliceLength = -1;
  /**
   * ### typeOf (obj)
   *
   * Uses `Object.prototype.toString` to determine the type of an object,
   * normalising behaviour across engine versions & well optimised.
   *
   * @param {Mixed} object
   * @return {String} object type
   * @api public
   */

  module.exports = function typeDetect(obj) {
    /* ! Speed optimisation
     * Pre:
     *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
     *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
     *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
     *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
     *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
     * Post:
     *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
     *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
     *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
     *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
     *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
     */
    var typeofObj = typeof obj;

    if (typeofObj !== 'object') {
      return typeofObj;
    }
    /* ! Speed optimisation
     * Pre:
     *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
     * Post:
     *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
     */


    if (obj === null) {
      return 'null';
    }
    /* ! Spec Conformance
     * Test: `Object.prototype.toString.call(window)``
     *  - Node === "[object global]"
     *  - Chrome === "[object global]"
     *  - Firefox === "[object Window]"
     *  - PhantomJS === "[object Window]"
     *  - Safari === "[object Window]"
     *  - IE 11 === "[object Window]"
     *  - IE Edge === "[object Window]"
     * Test: `Object.prototype.toString.call(this)``
     *  - Chrome Worker === "[object global]"
     *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
     *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
     *  - IE 11 Worker === "[object WorkerGlobalScope]"
     *  - IE Edge Worker === "[object WorkerGlobalScope]"
     */


    if (obj === globalObject) {
      return 'global';
    }
    /* ! Speed optimisation
     * Pre:
     *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
     * Post:
     *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
     */


    if (isArrayExists && Array.isArray(obj)) {
      return 'Array';
    }

    if (isDom) {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/browsers.html#location)
       * WhatWG HTML$7.7.3 - The `Location` interface
       * Test: `Object.prototype.toString.call(window.location)``
       *  - IE <=11 === "[object Object]"
       *  - IE Edge <=13 === "[object Object]"
       */
      if (obj === globalObject.location) {
        return 'Location';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#document)
       * WhatWG HTML$3.1.1 - The `Document` object
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       *       WhatWG HTML states:
       *         > For historical reasons, Window objects must also have a
       *         > writable, configurable, non-enumerable property named
       *         > HTMLDocument whose value is the Document interface object.
       * Test: `Object.prototype.toString.call(document)``
       *  - Chrome === "[object HTMLDocument]"
       *  - Firefox === "[object HTMLDocument]"
       *  - Safari === "[object HTMLDocument]"
       *  - IE <=10 === "[object Document]"
       *  - IE 11 === "[object HTMLDocument]"
       *  - IE Edge <=13 === "[object HTMLDocument]"
       */


      if (obj === globalObject.document) {
        return 'Document';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
       *  - IE <=10 === "[object MSMimeTypesCollection]"
       */


      if (obj === (globalObject.navigator || {}).mimeTypes) {
        return 'MimeTypeArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
       * Test: `Object.prototype.toString.call(navigator.plugins)``
       *  - IE <=10 === "[object MSPluginsCollection]"
       */


      if (obj === (globalObject.navigator || {}).plugins) {
        return 'PluginArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
       * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
       *  - IE <=10 === "[object HTMLBlockElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'BLOCKQUOTE') {
        return 'HTMLQuoteElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltabledatacellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('td'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TD') {
        return 'HTMLTableDataCellElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltableheadercellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('th'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TH') {
        return 'HTMLTableHeaderCellElement';
      }
    }
    /* ! Speed optimisation
    * Pre:
    *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
    *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
    *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
    *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
    *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
    *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
    *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
    *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
    *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
    * Post:
    *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
    *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
    *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
    *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
    *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
    *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
    *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
    *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
    *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
    */


    var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];

    if (typeof stringTag === 'string') {
      return stringTag;
    }

    if (getPrototypeOfExists) {
      var objPrototype = Object.getPrototypeOf(obj);
      /* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
      */

      if (objPrototype === RegExp.prototype) {
        return 'RegExp';
      }
      /* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
      */


      if (objPrototype === Date.prototype) {
        return 'Date';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: `Object.prototype.toString.call(Promise.resolve())``
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */


      if (promiseExists && objPrototype === Promise.prototype) {
        return 'Promise';
      }
      /* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
      */


      if (setExists && objPrototype === Set.prototype) {
        return 'Set';
      }
      /* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
      */


      if (mapExists && objPrototype === Map.prototype) {
        return 'Map';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
      */


      if (weakSetExists && objPrototype === WeakSet.prototype) {
        return 'WeakSet';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
      */


      if (weakMapExists && objPrototype === WeakMap.prototype) {
        return 'WeakMap';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
       *  - Edge <=13 === "[object Object]"
       */


      if (dataViewExists && objPrototype === DataView.prototype) {
        return 'DataView';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: `Object.prototype.toString.call(new Map().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (mapExists && objPrototype === mapIteratorPrototype) {
        return 'Map Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: `Object.prototype.toString.call(new Set().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (setExists && objPrototype === setIteratorPrototype) {
        return 'Set Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
        return 'Array Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
        return 'String Iterator';
      }
      /* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
      */


      if (objPrototype === null) {
        return 'Object';
      }
    }

    return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
  };

  module.exports.typeDetect = module.exports;
});
var typeDetect_1 = typeDetect$1.typeDetect;/* globals Symbol: true, Uint8Array: true, WeakMap: true */

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */


function FakeMap$1() {
  this.clear();
}

FakeMap$1.prototype = {
  clear: function clearMap() {
    this.keys = [];
    this.values = [];
    return this;
  },
  set: function setMap(key, value) {
    var index = this.keys.indexOf(key);

    if (index >= 0) {
      this.values[index] = value;
    } else {
      this.keys.push(key);
      this.values.push(value);
    }

    return this;
  },
  get: function getMap(key) {
    return this.values[this.keys.indexOf(key)];
  },
  delete: function deleteMap(key) {
    var index = this.keys.indexOf(key);

    if (index >= 0) {
      this.values = this.values.slice(0, index).concat(this.values.slice(index + 1));
      this.keys = this.keys.slice(0, index).concat(this.keys.slice(index + 1));
    }

    return this;
  }
};
var MemoizeMap$1 = null;

if (typeof WeakMap === 'function') {
  MemoizeMap$1 = WeakMap;
} else {
  MemoizeMap$1 = FakeMap$1;
}
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/


function memoizeCompare$1(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return null;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);

    if (typeof result === 'boolean') {
      return result;
    }
  }

  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/


function memoizeSet$1(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap$1();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
/*!
 * Primary Export
 */


var deepEql$1 = deepEqual$1;
var MemoizeMap_1$1 = MemoizeMap$1;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */

function deepEqual$1(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual$1(leftHandOperand, rightHandOperand);

  if (simpleResult !== null) {
    return simpleResult;
  } // Deeper comparisons are pushed through to a larger function


  return extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */


function simpleEqual$1(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  } // handle NaN cases


  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
      return true;
    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.


  if (isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }

  return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/


function extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap$1();
  var comparator = options && options.comparator; // Check if a memoized result exists.

  var memoizeResultLeft = memoizeCompare$1(leftHandOperand, rightHandOperand, options.memoize);

  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }

  var memoizeResultRight = memoizeCompare$1(rightHandOperand, leftHandOperand, options.memoize);

  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  } // If a comparator is present, use it.


  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.

    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.


    var simpleResult = simpleEqual$1(leftHandOperand, rightHandOperand);

    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = typeDetect$1(leftHandOperand);

  if (leftHandType !== typeDetect$1(rightHandOperand)) {
    memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  } // Temporarily set the operands in the memoize object to prevent blowing the stack


  memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType$1(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType$1(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual$1(leftHandOperand.valueOf(), rightHandOperand.valueOf());

    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;

    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual$1(leftHandOperand, rightHandOperand, options);

    case 'RegExp':
      return regexpEqual$1(leftHandOperand, rightHandOperand);

    case 'Generator':
      return generatorEqual$1(leftHandOperand, rightHandOperand, options);

    case 'DataView':
      return iterableEqual$1(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);

    case 'ArrayBuffer':
      return iterableEqual$1(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);

    case 'Set':
      return entriesEqual$1(leftHandOperand, rightHandOperand, options);

    case 'Map':
      return entriesEqual$1(leftHandOperand, rightHandOperand, options);

    default:
      return objectEqual$1(leftHandOperand, rightHandOperand, options);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */


function regexpEqual$1(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function entriesEqual$1(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }

  if (leftHandOperand.size === 0) {
    return true;
  }

  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  });
  return iterableEqual$1(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function iterableEqual$1(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;

  if (length !== rightHandOperand.length) {
    return false;
  }

  if (length === 0) {
    return true;
  }

  var index = -1;

  while (++index < length) {
    if (deepEqual$1(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function generatorEqual$1(leftHandOperand, rightHandOperand, options) {
  return iterableEqual$1(getGeneratorEntries$1(leftHandOperand), getGeneratorEntries$1(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */


function hasIteratorFunction$1(target) {
  return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */


function getIteratorEntries$1(target) {
  if (hasIteratorFunction$1(target)) {
    try {
      return getGeneratorEntries$1(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }

  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */


function getGeneratorEntries$1(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];

  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }

  return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */


function getEnumerableKeys$1(target) {
  var keys = [];

  for (var key in target) {
    keys.push(key);
  }

  return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function keysEqual$1(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;

  if (length === 0) {
    return true;
  }

  for (var i = 0; i < length; i += 1) {
    if (deepEqual$1(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function objectEqual$1(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys$1(leftHandOperand);
  var rightHandKeys = getEnumerableKeys$1(rightHandOperand);

  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();

    if (iterableEqual$1(leftHandKeys, rightHandKeys) === false) {
      return false;
    }

    return keysEqual$1(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries$1(leftHandOperand);
  var rightHandEntries = getIteratorEntries$1(rightHandOperand);

  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual$1(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }

  return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */


function isPrimitive$1(value) {
  return value === null || typeof value !== 'object';
}
deepEql$1.MemoizeMap = MemoizeMap_1$1;var DEFAULT_TOLERANCE = 1e-6;
/**
 * small utility functions
 */

function isNumber(val) {
  return typeDetect(val) === 'number';
}

function bothNumbers(left, right) {
  return isNumber(right) && isNumber(left);
}

function almostEqual(left, right, tol) {
  return Math.abs(left - right) <= tol;
}
/**
 * Makes a comparator function to be passed to deepEqual.
 * The returned function will return null if both arguments are not numbers,
 * indicating that deepEqual should proceed with other equality checks
 */


function comparator(tolerance) {
  return function (left, right) {
    if (bothNumbers(left, right)) {
      return almostEqual(left, right, tolerance);
    }

    return null;
  };
}
/**
 * Sets global tolerance and returns a function to be passed to chai.use
 * @see http://chaijs.com/guide/plugins/
 */


function chaiAlmost(customTolerance) {
  var standardTolerance = customTolerance || DEFAULT_TOLERANCE;
  return function (chai, utils) {
    var Assertion = chai.Assertion;
    var flag = utils.flag;
    /**
     * Returns a new shallow equality function to override
     * .equal, .equals, .eq that tests 'almost' equality
     * if both values are numbers and a 'tolerance' flag is set.
     * Sends to deep equality check if deep flag is set
     */

    function overrideAssertEqual(_super) {
      return function assertEqual(val, msg) {
        if (msg) flag(this, 'message', msg);
        var deep = flag(this, 'deep');
        var tolerance = flag(this, 'tolerance');

        if (deep) {
          return this.eql(val);
        } else if (tolerance && bothNumbers(val, this._obj)) {
          this.assert(almostEqual(val, this._obj, tolerance), 'expected #{this} to almost equal #{exp}', 'expected #{this} to not almost equal #{exp}', val, this._obj, true);
        } else {
          return _super.apply(this, arguments);
        }
      };
    }
    /**
     * Returns a new deep equality function to override
     * .eql, .eqls that tests 'almost' equality if both corresponding
     * values are numbers and tolerance flag is set
     */


    function overrideAssertEql(_super) {
      return function assertEql(val, msg) {
        if (msg) flag(this, 'message', msg);
        var tolerance = flag(this, 'tolerance');

        if (tolerance) {
          this.assert(deepEql$1(val, this._obj, {
            comparator: comparator(tolerance)
          }), 'expected #{this} to deeply almost equal #{exp}', 'expected #{this} to not deeply almost equal #{exp}', val, this._obj, true);
        } else {
          return _super.apply(this, arguments);
        }
      };
    }
    /**
     * .almost() method. To be used at the end of the chain like:
     * expect(4).to.not.be.almost(5, 1.5). Simply adds tolerance flag then calls
     * .equal. This will redirect to .eql if deep flag set
     */


    function method(val, toleranceOverride) {
      var tolerance = toleranceOverride || standardTolerance;
      flag(this, 'tolerance', tolerance);
      return this.equal(val);
    }
    /**
     * .almost chainable property to be used like:
     * expect(3.99999999).to.almost.equal(4). Simply adds
     * tolerance flag to be read by equality checking methods
     */


    function chainingBehavior() {
      flag(this, 'tolerance', standardTolerance);
    }

    Assertion.addChainableMethod('almost', method, chainingBehavior);
    Assertion.overwriteMethod('equal', overrideAssertEqual);
    Assertion.overwriteMethod('equals', overrideAssertEqual);
    Assertion.overwriteMethod('eq', overrideAssertEqual);
    Assertion.overwriteMethod('eql', overrideAssertEql);
    Assertion.overwriteMethod('eqls', overrideAssertEql);
  };
}

var chaiAlmost_1 = chaiAlmost;var divs, expect$1, i, resetDivs, styles;
chai$1.use(chaiAlmost_1);
mocha.setup('tdd');
mocha.slow(400);
mocha.timeout(12000);

if (!window.__karma__) {
  mocha.bail();
}

expect$1 = chai$1.expect;
divs = $(function () {
  var j, results;
  results = [];

  for (i = j = 1; j <= 3; i = ++j) {
    results.push('<div />');
  }

  return results;
}().join('')).appendTo('body');
styles = divs.toArray().map(function (div) {
  return getComputedStyle(div);
});

resetDivs = function resetDivs() {
  var div, j, len;

  for (j = 0, len = divs.length; j < len; j++) {
    div = divs[j];
    div.removeAttribute('style');

    if (arguments[0] === true) {
      continue;
    }

    div.style.width = '40px';
    div.style.height = '40px';
    div.style.backgroundColor = 'blue';
  }
};

suite("QuickCss", function () {
  setup(resetDivs);
  suiteTeardown(resetDivs);
  test("Apply Basic Styles", function () {
    index(divs[0], 'width', '10px');
    expect$1(styles[0].width).to.equal('10px');
    index(divs[1], 'width', '50vw');
    expect$1(divs[1].style.width).to.equal('50vw');
    return expect$1(Math.round(parseFloat(styles[0].width))).not.to.equal(40);
  });
  test("Suffix unit-less values for length properties", function () {
    index(divs[0], 'width', '10');
    index(divs[1], 'width', 10);
    index(divs[2], 'width', '10%');
    expect$1(divs[0].style.width).to.equal('10px');
    expect$1(divs[1].style.width).to.equal('10px');
    expect$1(divs[2].style.width).to.equal('10%');
    expect$1(styles[0].width).to.equal('10px');
    expect$1(styles[1].width).to.equal('10px');
    expect$1(Math.round(parseFloat(styles[2].width))).not.to.equal(40);
    index(divs[0], 'marginTop', '10');
    index(divs[1], 'marginTop', 10);
    index(divs[2], 'marginTop', '10%');
    expect$1(divs[0].style.marginTop).to.equal('10px');
    expect$1(divs[1].style.marginTop).to.equal('10px');
    expect$1(divs[2].style.marginTop).to.equal('10%');
    index(divs[0], 'fontSize', '10');
    index(divs[1], 'fontSize', 10);
    index(divs[2], 'fontSize', '10%');
    expect$1(divs[0].style.fontSize).to.equal('10px');
    expect$1(divs[1].style.fontSize).to.equal('10px');
    expect$1(divs[2].style.fontSize).to.equal('10%');
    index(divs[0], 'lineHeight', '10');
    index(divs[1], 'lineHeight', 10);
    index(divs[2], 'lineHeight', '10%');
    expect$1(divs[0].style.lineHeight).to.equal('10em');
    expect$1(divs[1].style.lineHeight).to.equal('10em');
    return expect$1(divs[2].style.lineHeight).to.equal('10%');
  });
  test("Suffix won't be added for unit-less values on non-length properties", function () {
    index(divs[0], 'width', 'auto');
    expect$1(divs[0].style.width).to.equal('auto');
    expect$1(Math.round(parseFloat(styles[0].width))).not.to.equal(40);
    index(divs[1], 'opacity', .5);
    expect$1(divs[1].style.opacity).to.equal('0.5');
    return expect$1(styles[1].opacity).to.equal('0.5');
  });
  test("An iterable collection of elements can be passed", function () {
    index(divs, 'width', 15);
    expect$1(divs[0].style.width).to.equal('15px');
    expect$1(divs[1].style.width).to.equal('15px');
    return expect$1(divs[2].style.width).to.equal('15px');
  });
  test("A style object can be passed", function () {
    index(divs[0], {
      'position': 'fixed',
      'width': '55',
      'height': 12,
      'opacity': 0.8
    });
    expect$1(divs[0].style.position).to.equal('fixed');
    expect$1(divs[0].style.width).to.equal('55px');
    expect$1(divs[0].style.height).to.equal('12px');
    return expect$1(divs[0].style.opacity).to.equal('0.8');
  });
  test("An iterable collection of elements can be passed along with a style object", function () {
    index(divs, {
      width: '32px',
      height: '99px'
    });
    expect$1(divs[0].style.width).to.equal('32px');
    expect$1(divs[1].style.width).to.equal('32px');
    expect$1(divs[2].style.width).to.equal('32px');
    expect$1(divs[0].style.height).to.equal('99px');
    expect$1(divs[1].style.height).to.equal('99px');
    return expect$1(divs[2].style.height).to.equal('99px');
  });
  test("Kebab-cased/camel-cased properties will be normalized", function () {
    index(divs[0], 'margin-top', '10px');
    expect$1(divs[0].style.marginTop).to.equal('10px');
    expect$1(styles[0].marginTop).to.equal('10px');
    index(divs[0], 'marginBottom', '12px');
    expect$1(divs[0].style.marginBottom).to.equal('12px');
    return expect$1(styles[0].marginBottom).to.equal('12px');
  });
  test("Invalid properties will be ignored", function () {
    index(divs[1], 'topMargin', '25px');
    expect$1(divs[0].style.topMargin).not.to.exist;
    return expect$1(styles[0].topMargin).not.to.exist;
  });
  test("If a value is not provided, the current computed value for the selected property will be returned", function () {
    var computedValue;
    index(divs[2], 'marginTop', '5vh');
    computedValue = styles[2].marginTop;
    expect$1(index(divs[2], 'marginTop', '5vh')).to.equal(void 0);
    expect$1(index(divs[2], 'marginTop', '5vh')).to.equal(void 0);
    expect$1(index(divs[2], 'marginTop')).to.equal(styles[2].marginTop);
    return expect$1(index(divs[2], 'topMargin')).to.equal(void 0);
  });
  test("If a null value is provided for a property, the property will be deleted", function () {
    index(divs[1], 'marginTop', '10px');
    expect$1(divs[1].style.marginTop).to.equal('10px');
    expect$1(styles[1].marginTop).to.equal('10px');
    index(divs[1], 'marginTop', null);
    expect$1(divs[1].style.marginTop).to.equal('');
    expect$1(styles[1].marginTop).to.equal('0px');
    index(divs[1], 'marginTop', '10px');
    expect$1(divs[1].style.marginTop).to.equal('10px');
    expect$1(styles[1].marginTop).to.equal('10px');
    index(divs[1], {
      'marginTop': null
    });
    expect$1(divs[1].style.marginTop).to.equal('');
    return expect$1(styles[1].marginTop).to.equal('0px');
  });
  test("!important flag will be set when truthy value will be passed as the 4th argument to QuickCss", function () {
    resetDivs(true);
    expect$1(divs[0].getAttribute('style')).to.oneOf(['', null]);
    index(divs[0], 'width', '50px');
    expect$1(divs[0].getAttribute('style')).to.include('50px');
    expect$1(divs[0].getAttribute('style')).not.to.include('50px !important');
    index(divs[0], 'width', '50px', true);
    expect$1(divs[0].getAttribute('style')).to.include('50px !important');
    index(divs[0], 'height', '75px', true);
    expect$1(divs[0].getAttribute('style')).to.include('75px !important');
    return index(divs[0], 'height', '75px');
  }); // expect(divs[0].getAttribute 'style').not.to.include '75px !important'

  test("quickcss.supports & quickcss.supportsProperty", function () {
    expect$1(_typeof(index.supports)).to.equal('function');
    expect$1(_typeof(index.supportsProperty)).to.equal('function');
    expect$1(index.supports('display', 'inline')).to.be["true"];
    expect$1(index.supports('display', 'block')).to.be["true"];
    expect$1(index.supports('display', 'blockl')).to.be["false"];
    expect$1(index.supports('display', '')).to.be["false"];
    expect$1(index.supports('display', null)).to.be["false"];
    expect$1(index.supports('opacity', '0.5')).to.be["true"];
    expect$1(index.supports('opacity', 0.5)).to.be["true"];
    expect$1(index.supportsProperty('opacity')).to.be["true"];
    return expect$1(index.supportsProperty('opacityy')).to.be["false"];
  });
  suite("animation", function () {
    test(".animation(name, keyframes) will create a @keyframes rule", function () {
      var lastEl;
      lastEl = $(document.head).children().last()[0];
      expect$1(lastEl.id).not.to.equal('quickcss');
      index.animation('myAnimation', {
        '0%': {
          transform: 'rotate(0deg)',
          opacity: 1,
          width: 100,
          marginTop: 5
        },
        '50%': {
          width: 150
        },
        '100%': {
          transform: 'rotate(360deg)',
          opacity: 0.5,
          width: 50
        }
      });
      lastEl = $(document.head).children().last()[0];
      expect$1(lastEl.id).to.equal('quickcss');
      expect$1(lastEl.innerHTML).to.include('keyframes myAnimation {');
      expect$1(lastEl.innerHTML).to.include('0% {');
      expect$1(lastEl.innerHTML).to.include('transform:rotate(0deg)');
      expect$1(lastEl.innerHTML).to.include('opacity:1');
      expect$1(lastEl.innerHTML).to.include('width:100px');
      expect$1(lastEl.innerHTML).to.include('margin-top:5px');
      expect$1(lastEl.innerHTML).to.include('50% {');
      expect$1(lastEl.innerHTML).to.include('width:150px');
      expect$1(lastEl.innerHTML).to.include('100% {');
      expect$1(lastEl.innerHTML).to.include('transform:rotate(360deg)');
      expect$1(lastEl.innerHTML).to.include('opacity:0.5');
      return expect$1(lastEl.innerHTML).to.include('width:50px');
    });
    return test("calling .animation() with the same args multiple times should only insert the keyframes once", function () {
      var animation, lastEl, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
      animation = {
        '0%': {
          transform: 'rotate(0deg)'
        },
        '100%': {
          transform: 'rotate(360deg)'
        }
      };
      index.animation('someAnimation', animation);
      lastEl = $(document.head).children().last()[0];
      expect$1(lastEl.innerHTML).to.include('keyframes someAnimation {');
      expect$1((ref = lastEl.innerHTML.match(/someAnimation/g)) != null ? ref.length : void 0).to.equal(1);
      index.animation('someAnimation', animation);
      expect$1((ref1 = lastEl.innerHTML.match(/someAnimation/g)) != null ? ref1.length : void 0).to.equal(1);
      index.animation('someAnimation2', animation);
      expect$1((ref2 = lastEl.innerHTML.match(/someAnimation/g)) != null ? ref2.length : void 0).to.equal(2);
      expect$1((ref3 = lastEl.innerHTML.match(/someAnimation2/g)) != null ? ref3.length : void 0).to.equal(1);
      index.animation('someAnimation2', animation);
      expect$1((ref4 = lastEl.innerHTML.match(/someAnimation/g)) != null ? ref4.length : void 0).to.equal(2);
      expect$1((ref5 = lastEl.innerHTML.match(/someAnimation2/g)) != null ? ref5.length : void 0).to.equal(1);
      index.animation('someAnimation2', {
        'from': {
          width: 50
        },
        'to': {
          width: 100
        }
      });
      expect$1((ref6 = lastEl.innerHTML.match(/someAnimation/g)) != null ? ref6.length : void 0).to.equal(3);
      return expect$1((ref7 = lastEl.innerHTML.match(/someAnimation2/g)) != null ? ref7.length : void 0).to.equal(2);
    });
  });
  return suite("style registration", function () {
    setup(function () {
      return resetDivs(true);
    });
    test("a className will be returned from quickcss.register() for a given rule object which can be applied to elements", function () {
      var className;
      className = index.register({
        width: '150px',
        'margin-top': '25px'
      });
      expect$1(_typeof(className)).to.equal('string');
      expect$1(index(divs[0], 'width')).not.to.equal('150px');
      expect$1(index(divs[0], 'marginTop')).not.to.equal('25px');
      divs[0].className += " ".concat(className);
      expect$1(index(divs[0], 'width')).to.equal('150px');
      return expect$1(index(divs[0], 'marginTop')).to.equal('25px');
    });
    test("values and properties will be normalized", function () {
      var className;
      className = index.register({
        width: 125,
        height: 70,
        zIndex: 12,
        marginTop: 20,
        fontSize: 20,
        position: 'relative'
      });
      expect$1(index(divs[0], 'width')).not.to.equal('125px');
      expect$1(index(divs[0], 'height')).not.to.equal('70px');
      expect$1(index(divs[0], 'marginTop')).not.to.equal('20px');
      expect$1(index(divs[0], 'fontSize')).not.to.equal('20px');
      expect$1(index(divs[0], 'zIndex')).not.to.equal('12');
      divs[0].className += " ".concat(className);
      expect$1(index(divs[0], 'width')).to.equal('125px');
      expect$1(index(divs[0], 'height')).to.equal('70px');
      expect$1(index(divs[0], 'marginTop')).to.equal('20px');
      expect$1(index(divs[0], 'fontSize')).to.equal('20px');
      return expect$1(index(divs[0], 'zIndex')).to.equal('12');
    });
    test("only valid property values will be registered", function () {
      var className, inserted, ref;
      className = index.register({
        width: 20,
        height: {
          value: '20px'
        },
        opacity: 0.5,
        lineHeight: function lineHeight() {
          return '2em';
        },
        fontSize: '12'
      });
      inserted = (ref = document.querySelector('#quickcss').textContent.match(new RegExp("\\.".concat(className, " {(.+?)}")))) != null ? ref[1] : void 0;
      expect$1(_typeof(inserted)).to.equal('string');
      expect$1(inserted).to.include('width:20px');
      expect$1(inserted).to.include('opacity:0.5');
      expect$1(inserted).to.include('font-size:12px');
      expect$1(inserted).not.to.include('height');
      return expect$1(inserted).not.to.include('line-height');
    });
    test("a rule object will be only defined once inside the style element", function () {
      var className1, className2, match;
      className1 = index.register({
        width: 30,
        height: '50'
      });
      className2 = index.register({
        width: 30,
        height: '50'
      });
      expect$1(className1).to.equal(className2);
      match = document.querySelector('#quickcss').textContent.match(new RegExp("".concat(className1), 'g'));
      return expect$1(match.length).to.equal(1);
    });
    test("styles can be registered at different levels for specificity (default=0)", function () {
      var className1, className2;
      className1 = index.register({
        width: 10,
        height: 10
      });
      className2 = index.register({
        width: 20,
        height: 20
      });
      divs[0].className = "".concat(className1);
      expect$1(styles[0].width).to.equal('10px');
      expect$1(styles[0].height).to.equal('10px');
      divs[0].className += " ".concat(className2);
      expect$1(styles[0].width).to.equal('20px');
      expect$1(styles[0].height).to.equal('20px');
      index.register({
        width: 10,
        height: 10
      });
      expect$1(styles[0].width).to.equal('20px');
      expect$1(styles[0].height).to.equal('20px');
      expect$1(document.querySelector('#quickcss1')).to.equal(null);
      index.register({
        width: 10,
        height: 10
      }, 1);
      expect$1(styles[0].width).to.equal('10px');
      expect$1(styles[0].height).to.equal('10px');
      index.register({
        width: 20,
        height: 20
      }, 5);
      expect$1(styles[0].width).to.equal('20px');
      expect$1(styles[0].height).to.equal('20px');
      expect$1(document.querySelector('#quickcss1')).not.to.equal(null);
      expect$1(document.querySelector('#quickcss5')).not.to.equal(null);
      expect$1(document.querySelector('#quickcss').textContent).to.include(className1);
      expect$1(document.querySelector('#quickcss1').textContent).to.include(className1);
      expect$1(document.querySelector('#quickcss5').textContent).not.to.include(className1);
      expect$1(document.querySelector('#quickcss').textContent).to.include(className2);
      expect$1(document.querySelector('#quickcss1').textContent).not.to.include(className2);
      expect$1(document.querySelector('#quickcss5').textContent).to.include(className2);
      index.register({
        width: 10,
        height: 10
      }, 5);
      expect$1(styles[0].width).to.equal('10px');
      expect$1(styles[0].height).to.equal('10px');
      return expect$1(document.querySelector('#quickcss5').textContent).to.include(className1);
    });
    test("styles will be registered with '!important' flag when passed quickcss.register(..., ..., true)", function () {
      var className1, className2, className3, className4, className5, inserted, ref;
      className1 = index.register({
        width: 30,
        height: 30
      }, 0);
      className2 = index.register({
        width: 30,
        height: 30
      }, 0, true);
      className4 = index.register({
        width: 50
      }, 1, true);
      className5 = index.register({
        height: 50
      }, 1);
      className3 = index.register({
        width: 25,
        height: 25
      }, 2);
      expect$1(className1).not.to.equal(className2);
      divs[0].className = "".concat(className3, " ").concat(className4, " ").concat(className5);
      expect$1(styles[0].width).to.equal('50px');
      expect$1(styles[0].height).to.equal('25px');
      inserted = (ref = document.querySelector('#quickcss').textContent.match(new RegExp("\\.".concat(className2, " {(.+?)}")))) != null ? ref[1] : void 0;
      return expect$1(inserted).to.include('!important');
    });
    test("clearing registered", function () {
      var className;
      className = index.register({
        a: '1px',
        b: '2px'
      });
      index.register({
        a: '1px',
        b: '2px'
      }, 1);
      expect$1(document.querySelector('#quickcss').textContent).to.include(className);
      expect$1(document.querySelector('#quickcss1').textContent).to.include(className);
      index.clearRegistered();
      expect$1(document.querySelector('#quickcss').textContent).not.to.include(className);
      expect$1(document.querySelector('#quickcss1').textContent).to.include(className);
      index.register({
        a: '1px',
        b: '2px'
      });
      expect$1(document.querySelector('#quickcss').textContent).to.include(className);
      expect$1(document.querySelector('#quickcss1').textContent).to.include(className);
      index.clearRegistered(1);
      expect$1(document.querySelector('#quickcss').textContent).to.include(className);
      return expect$1(document.querySelector('#quickcss1').textContent).not.to.include(className);
    });
    return suite("the returned className will be the same (i.e. hashsum)", function () {
      test("for the same object", function () {
        var rule;
        rule = {
          width: 125,
          height: 70,
          zIndex: 12
        };
        return expect$1(index.register(rule)).to.equal(index.register(rule));
      });
      test("for diff objects with the same config", function () {
        return expect$1(index.register({
          width: 125,
          height: 70,
          zIndex: 13
        })).to.equal(index.register({
          width: 125,
          height: 70,
          zIndex: 13
        }));
      });
      test("for diff objects with the same config but different notations", function () {
        return expect$1(index.register({
          width: 115,
          height: 70,
          zIndex: 14
        })).to.equal(index.register({
          width: '115px',
          height: 70,
          'z-index': 14
        }));
      });
      test("for diff objects with the same config but different property order", function () {
        expect$1(index.register({
          width: 100,
          height: 70,
          zIndex: 15
        })).to.equal(index.register({
          'z-index': 15,
          width: '100px',
          height: 70
        }));
        return expect$1(index.register({
          width: 100,
          height: 70,
          zIndex: 15
        })).not.to.equal(index.register({
          'z-index': 15,
          width: '100px',
          height: 71
        }));
      });
      return test("for diff object with the same config when some properties are rejected", function () {
        return expect$1(index.register({
          width: 20,
          height: {
            value: '20px'
          },
          opacity: 0.5,
          lineHeight: function lineHeight() {
            return '2em';
          },
          fontSize: '12'
        })).to.equal(index.register({
          width: 20,
          height: {
            value: '20px'
          },
          opacity: 0.5,
          fontSize: '12',
          lineHeight: function lineHeight() {
            return '2em';
          }
        }));
      });
    });
  });
});})));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5qcyIsInNvdXJjZXMiOlsiLi4vYnVpbGQvcXVpY2tjc3MuZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fzc2VydGlvbi1lcnJvci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wYXRodmFsL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZmxhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3Rlc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvdHlwZS1kZXRlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9leHBlY3RUeXBlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEFjdHVhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9nZXQtZnVuYy1uYW1lL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaW5zcGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL29iakRpc3BsYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRNZXNzYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdHJhbnNmZXJGbGFncy5qcyIsIi4uL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2lzUHJveHlFbmFibGVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRMZW5ndGhHdWFyZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3Byb3hpZnkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRNZXRob2QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vdmVyd3JpdGVQcm9wZXJ0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZENoYWluYWJsZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2NvbXBhcmVCeUluc3BlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hlY2stZXJyb3IvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pc05hTi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvYXNzZXJ0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29yZS9hc3NlcnRpb25zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL2V4cGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9zaG91bGQuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2UvYXNzZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLWFsbW9zdC9ub2RlX21vZHVsZXMvZGVlcC1lcWwvbm9kZV9tb2R1bGVzL3R5cGUtZGV0ZWN0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWktYWxtb3N0L25vZGVfbW9kdWxlcy9kZWVwLWVxbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLWFsbW9zdC9pbmRleC5qcyIsInRlc3QuY29mZmVlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59dmFyIFJFR0VYX0xFTl9WQUwgPSAvXlxcZCsoPzpbYS16XXxcXCUpKyQvaTtcbnZhciBSRUdFWF9ESUdJVFMgPSAvXFxkKyQvO1xudmFyIFJFR0VYX1NQQUNFID0gL1xccy87XG52YXIgUkVHRVhfS0VCQUIgPSAvKFtBLVpdKSsvZztcbnZhciBJTVBPUlRBTlQgPSAnaW1wb3J0YW50JztcbnZhciBQT1NTSUJMRV9QUkVGSVhFUyA9IFsnd2Via2l0JywgJ21veicsICdtcycsICdvJ107XG52YXIgUkVRVUlSRVNfVU5JVF9WQUxVRSA9IFsnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICdibG9jay1zaXplJywgJ2JvcmRlci13aWR0aCcsICdjb2x1bW5SdWxlLXdpZHRoJywgJ2N4JywgJ2N5JywgJ2ZvbnQtc2l6ZScsICdncmlkLWNvbHVtbi1nYXAnLCAnZ3JpZC1yb3ctZ2FwJywgJ2hlaWdodCcsICdpbmxpbmUtc2l6ZScsICdsaW5lLWhlaWdodCcsICdtaW5CbG9jay1zaXplJywgJ21pbi1oZWlnaHQnLCAnbWluLWlubGluZS1zaXplJywgJ21pbi13aWR0aCcsICdtYXgtaGVpZ2h0JywgJ21heC13aWR0aCcsICdvdXRsaW5lLW9mZnNldCcsICdvdXRsaW5lLXdpZHRoJywgJ3BlcnNwZWN0aXZlJywgJ3NoYXBlLW1hcmdpbicsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2Utd2lkdGgnLCAndGV4dC1pbmRlbnQnLCAnd2lkdGgnLCAnd29yZC1zcGFjaW5nJywgJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICd4JywgJ3knXTtcbnZhciBRVUFEX1NIT1JUSEFORFMgPSBbJ21hcmdpbicsICdwYWRkaW5nJywgJ2JvcmRlcicsICdib3JkZXItcmFkaXVzJ107XG52YXIgRElSRUNUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J107XG5RVUFEX1NIT1JUSEFORFMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgdmFyIGRpcmVjdGlvbiwgaSwgbGVuO1xuICBSRVFVSVJFU19VTklUX1ZBTFVFLnB1c2gocHJvcGVydHkpO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IERJUkVDVElPTlMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBkaXJlY3Rpb24gPSBESVJFQ1RJT05TW2ldO1xuICAgIFJFUVVJUkVTX1VOSVRfVkFMVUUucHVzaChwcm9wZXJ0eSArICctJyArIGRpcmVjdGlvbik7XG4gIH1cbn0pO3ZhciBTQU1QTEVfU1RZTEUsIHN0eWxlQ29uZmlnO1xuU0FNUExFX1NUWUxFID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG52YXIgaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyh0YXJnZXQsIGl0ZW0pIHtcbiAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59O1xudmFyIGlzSXRlcmFibGUgPSBmdW5jdGlvbiBpc0l0ZXJhYmxlKHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0ICYmIF90eXBlb2YodGFyZ2V0KSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldC5sZW5ndGggPT09ICdudW1iZXInICYmICF0YXJnZXQubm9kZVR5cGU7XG59O1xudmFyIHRvS2ViYWJDYXNlID0gZnVuY3Rpb24gdG9LZWJhYkNhc2Uoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShSRUdFWF9LRUJBQiwgZnVuY3Rpb24gKGUsIGxldHRlcikge1xuICAgIHJldHVybiBcIi1cIi5jb25jYXQobGV0dGVyLnRvTG93ZXJDYXNlKCkpO1xuICB9KTtcbn07XG52YXIgaXNQcm9wU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNQcm9wU3VwcG9ydGVkKHByb3BlcnR5KSB7XG4gIHJldHVybiB0eXBlb2YgU0FNUExFX1NUWUxFW3Byb3BlcnR5XSAhPT0gJ3VuZGVmaW5lZCc7XG59O1xudmFyIGlzVmFsdWVTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1ZhbHVlU3VwcG9ydGVkKHByb3BlcnR5LCB2YWx1ZSkge1xuICBpZiAod2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLnN1cHBvcnRzKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5DU1Muc3VwcG9ydHMocHJvcGVydHksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBTQU1QTEVfU1RZTEVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgcmV0dXJuIFNBTVBMRV9TVFlMRVtwcm9wZXJ0eV0gPT09ICcnICsgdmFsdWU7XG4gIH1cbn07XG52YXIgZ2V0UHJlZml4ID0gZnVuY3Rpb24gZ2V0UHJlZml4KHByb3BlcnR5LCBza2lwSW5pdGlhbENoZWNrKSB7XG4gIHZhciBqLCBsZW4xLCBwcmVmaXg7XG5cbiAgaWYgKHNraXBJbml0aWFsQ2hlY2sgfHwgIWlzUHJvcFN1cHBvcnRlZChwcm9wZXJ0eSkpIHtcbiAgICBmb3IgKGogPSAwLCBsZW4xID0gUE9TU0lCTEVfUFJFRklYRVMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICBwcmVmaXggPSBQT1NTSUJMRV9QUkVGSVhFU1tqXTtcblxuICAgICAgaWYgKGlzUHJvcFN1cHBvcnRlZChcIi1cIi5jb25jYXQocHJlZml4LCBcIi1cIikuY29uY2F0KHByb3BlcnR5KSkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIFwiLVwiLmNvbmNhdChwcmVmaXgsIFwiLVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xudmFyIG5vcm1hbGl6ZVByb3BlcnR5ID0gZnVuY3Rpb24gbm9ybWFsaXplUHJvcGVydHkocHJvcGVydHkpIHtcbiAgcHJvcGVydHkgPSB0b0tlYmFiQ2FzZShwcm9wZXJ0eSk7XG5cbiAgaWYgKGlzUHJvcFN1cHBvcnRlZChwcm9wZXJ0eSkpIHtcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGdldFByZWZpeChwcm9wZXJ0eSwgdHJ1ZSkpLmNvbmNhdChwcm9wZXJ0eSk7XG4gIH1cbn07XG52YXIgbm9ybWFsaXplVmFsdWUgPSBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgaWYgKGluY2x1ZGVzKFJFUVVJUkVTX1VOSVRfVkFMVUUsIHByb3BlcnR5KSAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIGlmIChSRUdFWF9ESUdJVFMudGVzdCh2YWx1ZSkgJiYgIVJFR0VYX0xFTl9WQUwudGVzdCh2YWx1ZSkgJiYgIVJFR0VYX1NQQUNFLnRlc3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSArPSBwcm9wZXJ0eSA9PT0gJ2xpbmUtaGVpZ2h0JyA/ICdlbScgOiAncHgnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgc29ydCA9IGZ1bmN0aW9uIHNvcnQoYXJyYXkpIHtcbiAgdmFyIGdyZWF0LCBpLCBsZW4sIGxlc3MsIHBpdm90O1xuXG4gIGlmIChhcnJheS5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9IGVsc2Uge1xuICAgIHBpdm90ID0gYXJyYXlbMF07XG4gICAgbGVzcyA9IFtdO1xuICAgIGdyZWF0ID0gW107XG4gICAgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKCsraSAhPT0gbGVuKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPD0gcGl2b3QpIHtcbiAgICAgICAgbGVzcy5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyZWF0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3J0KGxlc3MpLmNvbmNhdChwaXZvdCwgc29ydChncmVhdCkpO1xuICB9XG59O1xudmFyIGhhc2ggPSBmdW5jdGlvbiBoYXNoKHN0cmluZykge1xuICB2YXIgaHNoLCBpLCBsZW5ndGg7XG4gIGhzaCA9IDUzODE7XG4gIGkgPSAtMTtcbiAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoKytpICE9PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgaHNoID0gKGhzaCA8PCA1KSAtIGhzaCArIHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIGhzaCB8PSAwO1xuICB9XG5cbiAgcmV0dXJuICdfJyArIChoc2ggPCAwID8gaHNoICogLTIgOiBoc2gpO1xufTtcbnZhciBydWxlVG9TdHJpbmcgPSBmdW5jdGlvbiBydWxlVG9TdHJpbmcocnVsZSwgaW1wb3J0YW50KSB7XG4gIHZhciBqLCBsZW4xLCBvdXRwdXQsIHByb3AsIHByb3BlcnR5LCBwcm9wcywgdmFsdWU7XG4gIG91dHB1dCA9ICcnO1xuICBwcm9wcyA9IHNvcnQoT2JqZWN0LmtleXMocnVsZSkpO1xuXG4gIGZvciAoaiA9IDAsIGxlbjEgPSBwcm9wcy5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICBwcm9wID0gcHJvcHNbal07XG5cbiAgICBpZiAodHlwZW9mIHJ1bGVbcHJvcF0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBydWxlW3Byb3BdID09PSAnbnVtYmVyJykge1xuICAgICAgcHJvcGVydHkgPSBub3JtYWxpemVQcm9wZXJ0eShwcm9wKTtcbiAgICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUocHJvcGVydHksIHJ1bGVbcHJvcF0pO1xuXG4gICAgICBpZiAoaW1wb3J0YW50KSB7XG4gICAgICAgIHZhbHVlICs9IFwiICFpbXBvcnRhbnRcIjtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0ICs9IFwiXCIuY29uY2F0KHByb3BlcnR5LCBcIjpcIikuY29uY2F0KHZhbHVlLCBcIjtcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG52YXIgaW5saW5lU3R5bGVDb25maWcgPSBzdHlsZUNvbmZpZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG52YXIgaW5saW5lU3R5bGUgPSBmdW5jdGlvbiBpbmxpbmVTdHlsZShydWxlLCB2YWx1ZVRvU3RvcmUsIGxldmVsKSB7XG4gIHZhciBjb25maWcsIHN0eWxlRWw7XG5cbiAgaWYgKCEoY29uZmlnID0gc3R5bGVDb25maWdbbGV2ZWxdKSkge1xuICAgIHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlRWwuaWQgPSBcInF1aWNrY3NzXCIuY29uY2F0KGxldmVsIHx8ICcnKTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlRWwpO1xuICAgIHN0eWxlQ29uZmlnW2xldmVsXSA9IGNvbmZpZyA9IHtcbiAgICAgIGVsOiBzdHlsZUVsLFxuICAgICAgY29udGVudDogJycsXG4gICAgICBjYWNoZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH07XG4gIH1cblxuICBpZiAoIWNvbmZpZy5jYWNoZVtydWxlXSkge1xuICAgIGNvbmZpZy5jYWNoZVtydWxlXSA9IHZhbHVlVG9TdG9yZSB8fCB0cnVlO1xuICAgIGNvbmZpZy5lbC50ZXh0Q29udGVudCA9IGNvbmZpZy5jb250ZW50ICs9IHJ1bGU7XG4gIH1cbn07XG52YXIgY2xlYXJJbmxpbmVTdHlsZSA9IGZ1bmN0aW9uIGNsZWFySW5saW5lU3R5bGUobGV2ZWwpIHtcbiAgdmFyIGNvbmZpZywgaiwga2V5LCBrZXlzLCBsZW4xO1xuXG4gIGlmIChjb25maWcgPSBzdHlsZUNvbmZpZ1tsZXZlbF0pIHtcbiAgICBpZiAoIWNvbmZpZy5jb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnLmVsLnRleHRDb250ZW50ID0gY29uZmlnLmNvbnRlbnQgPSAnJztcbiAgICBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnLmNhY2hlKTtcblxuICAgIGZvciAoaiA9IDAsIGxlbjEgPSBrZXlzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAga2V5ID0ga2V5c1tqXTtcbiAgICAgIGNvbmZpZy5jYWNoZVtrZXldID0gbnVsbDtcbiAgICB9XG4gIH1cbn07dmFyIHZlcnNpb24gPSBcIjEuNC40XCI7dmFyIF9xdWlja2NzcztcbnZhciBpbmRleCA9IF9xdWlja2NzcyA9IGZ1bmN0aW9uIHF1aWNrY3NzKHRhcmdldEVsLCBwcm9wZXJ0eSwgdmFsdWUsIGltcG9ydGFudCkge1xuICB2YXIgY29tcHV0ZWRTdHlsZSwgaSwgbGVuLCBzdWJFbCwgc3ViUHJvcGVydHksIHN1YlZhbHVlO1xuXG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICFpc0l0ZXJhYmxlKHRhcmdldEVsKTpcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRhcmdldEVsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN1YkVsID0gdGFyZ2V0RWxbaV07XG5cbiAgICAgICAgX3F1aWNrY3NzKHN1YkVsLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgX3R5cGVvZihwcm9wZXJ0eSkgIT09ICdvYmplY3QnOlxuICAgICAgLy8gUGFzc2VkIGEgc3R5bGUgbWFwXG4gICAgICBmb3IgKHN1YlByb3BlcnR5IGluIHByb3BlcnR5KSB7XG4gICAgICAgIHN1YlZhbHVlID0gcHJvcGVydHlbc3ViUHJvcGVydHldO1xuXG4gICAgICAgIF9xdWlja2Nzcyh0YXJnZXRFbCwgc3ViUHJvcGVydHksIHN1YlZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcGVydHkgPSBub3JtYWxpemVQcm9wZXJ0eShwcm9wZXJ0eSk7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbXB1dGVkU3R5bGUgPSB0YXJnZXRFbC5fY29tcHV0ZWRTdHlsZSB8fCAodGFyZ2V0RWwuX2NvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldEVsKSk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZFN0eWxlW3Byb3BlcnR5XTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHkpIHtcbiAgICAgICAgdGFyZ2V0RWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIG5vcm1hbGl6ZVZhbHVlKHByb3BlcnR5LCB2YWx1ZSksIGltcG9ydGFudCA/IElNUE9SVEFOVCA6IG51bGwpO1xuICAgICAgfVxuXG4gIH1cbn07XG5cbl9xdWlja2Nzcy5hbmltYXRpb24gPSBmdW5jdGlvbiAobmFtZSwgZnJhbWVzKSB7XG4gIHZhciBmcmFtZSwgZ2VuZXJhdGVkLCBwcmVmaXgsIHJ1bGVzO1xuXG4gIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiBmcmFtZXMgJiYgX3R5cGVvZihmcmFtZXMpID09PSAnb2JqZWN0Jykge1xuICAgIHByZWZpeCA9IGdldFByZWZpeCgnYW5pbWF0aW9uJyk7XG4gICAgZ2VuZXJhdGVkID0gJyc7XG5cbiAgICBmb3IgKGZyYW1lIGluIGZyYW1lcykge1xuICAgICAgcnVsZXMgPSBmcmFtZXNbZnJhbWVdO1xuICAgICAgZ2VuZXJhdGVkICs9IFwiXCIuY29uY2F0KGZyYW1lLCBcIiB7XCIpLmNvbmNhdChydWxlVG9TdHJpbmcocnVsZXMpLCBcIn1cIik7XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVkID0gXCJAXCIuY29uY2F0KHByZWZpeCwgXCJrZXlmcmFtZXMgXCIpLmNvbmNhdChuYW1lLCBcIiB7XCIpLmNvbmNhdChnZW5lcmF0ZWQsIFwifVwiKTtcbiAgICByZXR1cm4gaW5saW5lU3R5bGUoZ2VuZXJhdGVkLCB0cnVlLCAwKTtcbiAgfVxufTtcblxuX3F1aWNrY3NzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHJ1bGUsIGxldmVsLCBpbXBvcnRhbnQpIHtcbiAgdmFyIGNsYXNzTmFtZSwgcmVmLCBzdHlsZTtcblxuICBpZiAocnVsZSAmJiBfdHlwZW9mKHJ1bGUpID09PSAnb2JqZWN0Jykge1xuICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgIHJ1bGUgPSBydWxlVG9TdHJpbmcocnVsZSwgaW1wb3J0YW50KTtcblxuICAgIGlmICghKGNsYXNzTmFtZSA9IChyZWYgPSBpbmxpbmVTdHlsZUNvbmZpZ1tsZXZlbF0pICE9IG51bGwgPyByZWZbcnVsZV0gOiB2b2lkIDApKSB7XG4gICAgICBjbGFzc05hbWUgPSBoYXNoKHJ1bGUpO1xuICAgICAgc3R5bGUgPSBcIi5cIi5jb25jYXQoY2xhc3NOYW1lLCBcIiB7XCIpLmNvbmNhdChydWxlLCBcIn1cIik7XG4gICAgICBpbmxpbmVTdHlsZShzdHlsZSwgY2xhc3NOYW1lLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufTtcblxuX3F1aWNrY3NzLmNsZWFyUmVnaXN0ZXJlZCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICByZXR1cm4gY2xlYXJJbmxpbmVTdHlsZShsZXZlbCB8fCAwKTtcbn07XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbl9xdWlja2Nzcy5VTlNFVCA9IGZ1bmN0aW9uICgpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIWlzVmFsdWVTdXBwb3J0ZWQoJ2Rpc3BsYXknLCAndW5zZXQnKTpcbiAgICAgIHJldHVybiAndW5zZXQnO1xuXG4gICAgY2FzZSAhaXNWYWx1ZVN1cHBvcnRlZCgnZGlzcGxheScsICdpbml0aWFsJyk6XG4gICAgICByZXR1cm4gJ2luaXRpYWwnO1xuXG4gICAgY2FzZSAhaXNWYWx1ZVN1cHBvcnRlZCgnZGlzcGxheScsICdpbmhlcml0Jyk6XG4gICAgICByZXR1cm4gJ2luaGVyaXQnO1xuICB9XG59KCk7XG5cbl9xdWlja2Nzcy5zdXBwb3J0cyA9IGlzVmFsdWVTdXBwb3J0ZWQ7XG5fcXVpY2tjc3Muc3VwcG9ydHNQcm9wZXJ0eSA9IGlzUHJvcFN1cHBvcnRlZDtcbl9xdWlja2Nzcy5ub3JtYWxpemVQcm9wZXJ0eSA9IG5vcm1hbGl6ZVByb3BlcnR5O1xuX3F1aWNrY3NzLm5vcm1hbGl6ZVZhbHVlID0gbm9ybWFsaXplVmFsdWU7XG5fcXVpY2tjc3MudmVyc2lvbiA9IHZlcnNpb247ZXhwb3J0IGRlZmF1bHQgaW5kZXg7IiwiLyohXG4gKiBhc3NlcnRpb24tZXJyb3JcbiAqIENvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciA8amFrZUBxdWFsaWFuY3kuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIG9uZSBvYmplY3QgdG8gYW5vdGhlciBleGNsdWRpbmcgYW55IG9yaWdpbmFsbHlcbiAqIGxpc3RlZC4gUmV0dXJuZWQgZnVuY3Rpb24gd2lsbCBjcmVhdGUgYSBuZXcgYHt9YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhjbHVkZWQgcHJvcGVydGllcyAuLi5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGV4Y2x1ZGUgKCkge1xuICB2YXIgZXhjbHVkZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgZnVuY3Rpb24gZXhjbHVkZVByb3BzIChyZXMsIG9iaikge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIX5leGNsdWRlcy5pbmRleE9mKGtleSkpIHJlc1trZXldID0gb2JqW2tleV07XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gZXh0ZW5kRXhjbHVkZSAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICwgaSA9IDBcbiAgICAgICwgcmVzID0ge307XG5cbiAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4Y2x1ZGVQcm9wcyhyZXMsIGFyZ3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQXNzZXJ0aW9uRXJyb3I7XG5cbi8qKlxuICogIyMjIEFzc2VydGlvbkVycm9yXG4gKlxuICogQW4gZXh0ZW5zaW9uIG9mIHRoZSBKYXZhU2NyaXB0IGBFcnJvcmAgY29uc3RydWN0b3IgZm9yXG4gKiBhc3NlcnRpb24gYW5kIHZhbGlkYXRpb24gc2NlbmFyaW9zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyB0byBpbmNsdWRlIChvcHRpb25hbClcbiAqIEBwYXJhbSB7Y2FsbGVlfSBzdGFydCBzdGFjayBmdW5jdGlvbiAob3B0aW9uYWwpXG4gKi9cblxuZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3IgKG1lc3NhZ2UsIF9wcm9wcywgc3NmKSB7XG4gIHZhciBleHRlbmQgPSBleGNsdWRlKCduYW1lJywgJ21lc3NhZ2UnLCAnc3RhY2snLCAnY29uc3RydWN0b3InLCAndG9KU09OJylcbiAgICAsIHByb3BzID0gZXh0ZW5kKF9wcm9wcyB8fCB7fSk7XG5cbiAgLy8gZGVmYXVsdCB2YWx1ZXNcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVW5zcGVjaWZpZWQgQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLnNob3dEaWZmID0gZmFsc2U7XG5cbiAgLy8gY29weSBmcm9tIHByb3BlcnRpZXNcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdGhpc1trZXldID0gcHJvcHNba2V5XTtcbiAgfVxuXG4gIC8vIGNhcHR1cmUgc3RhY2sgdHJhY2VcbiAgc3NmID0gc3NmIHx8IEFzc2VydGlvbkVycm9yO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzc2YpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xuICAgIH1cbiAgfVxufVxuXG4vKiFcbiAqIEluaGVyaXQgZnJvbSBFcnJvci5wcm90b3R5cGVcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbi8qIVxuICogU3RhdGljYWxseSBzZXQgbmFtZVxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcblxuLyohXG4gKiBFbnN1cmUgY29ycmVjdCBjb25zdHJ1Y3RvclxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzc2VydGlvbkVycm9yO1xuXG4vKipcbiAqIEFsbG93IGVycm9ycyB0byBiZSBjb252ZXJ0ZWQgdG8gSlNPTiBmb3Igc3RhdGljIHRyYW5zZmVyLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZSBzdGFjayAoZGVmYXVsdDogYHRydWVgKVxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgdGhhdCBjYW4gYmUgYEpTT04uc3RyaW5naWZ5YFxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgdmFyIGV4dGVuZCA9IGV4Y2x1ZGUoJ2NvbnN0cnVjdG9yJywgJ3RvSlNPTicsICdzdGFjaycpXG4gICAgLCBwcm9wcyA9IGV4dGVuZCh7IG5hbWU6IHRoaXMubmFtZSB9LCB0aGlzKTtcblxuICAvLyBpbmNsdWRlIHN0YWNrIGlmIGV4aXN0cyBhbmQgbm90IHR1cm5lZCBvZmZcbiAgaWYgKGZhbHNlICE9PSBzdGFjayAmJiB0aGlzLnN0YWNrKSB7XG4gICAgcHJvcHMuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogIVxuICogQ2hhaSAtIHBhdGh2YWwgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2xvZ2ljYWxwYXJhZG94L2ZpbHRyXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuaGFzUHJvcGVydHkob2JqZWN0LCBuYW1lKVxuICpcbiAqIFRoaXMgYWxsb3dzIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBvd25cbiAqIG9yIGluaGVyaXRlZCBmcm9tIHByb3RvdHlwZSBjaGFpbiBuYW1lZCBwcm9wZXJ0eS5cbiAqXG4gKiBCYXNpY2FsbHkgZG9lcyB0aGUgc2FtZSB0aGluZyBhcyB0aGUgYGluYFxuICogb3BlcmF0b3IgYnV0IHdvcmtzIHByb3Blcmx5IHdpdGggbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gKiBhbmQgb3RoZXIgcHJpbWl0aXZlcy5cbiAqXG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgYXJyOiBbJ2EnLCAnYicsICdjJ11cbiAqICAgICAgICwgc3RyOiAnSGVsbG8nXG4gKiAgICAgfVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgdGhlIHJlc3VsdHMuXG4gKlxuICogICAgIGhhc1Byb3BlcnR5KG9iaiwgJ3N0cicpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iaiwgJ2NvbnN0cnVjdG9yJyk7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLCAnYmFyJyk7ICAvLyBmYWxzZVxuICpcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouc3RyLCAnbGVuZ3RoJyk7IC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouc3RyLCAxKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouc3RyLCA1KTsgIC8vIGZhbHNlXG4gKlxuICogICAgIGhhc1Byb3BlcnR5KG9iai5hcnIsICdsZW5ndGgnKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouYXJyLCAyKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouYXJyLCAzKTsgIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2hldGhlciBpdCBleGlzdHNcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGhhc1Byb3BlcnR5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc1Byb3BlcnR5KG9iaiwgbmFtZSkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGhlIGBpbmAgb3BlcmF0b3IgZG9lcyBub3Qgd29yayB3aXRoIHByaW1pdGl2ZXMuXG4gIHJldHVybiBuYW1lIGluIE9iamVjdChvYmopO1xufVxuXG4vKiAhXG4gKiAjIyBwYXJzZVBhdGgocGF0aClcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBzdHJpbmcgb2JqZWN0XG4gKiBwYXRocy4gVXNlIGluIGNvbmp1bmN0aW9uIHdpdGggYGludGVybmFsR2V0UGF0aFZhbHVlYC5cbiAqXG4gKiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVBhdGgoJ215b2JqZWN0LnByb3BlcnR5LnN1YnByb3AnKTtcbiAqXG4gKiAjIyMgUGF0aHM6XG4gKlxuICogKiBDYW4gYmUgaW5maW5pdGVseSBkZWVwIGFuZCBuZXN0ZWQuXG4gKiAqIEFycmF5cyBhcmUgYWxzbyB2YWxpZCB1c2luZyB0aGUgZm9ybWFsIGBteW9iamVjdC5kb2N1bWVudFszXS5wcm9wZXJ0eWAuXG4gKiAqIExpdGVyYWwgZG90cyBhbmQgYnJhY2tldHMgKG5vdCBkZWxpbWl0ZXIpIG11c3QgYmUgYmFja3NsYXNoLWVzY2FwZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBhcnNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHN0ciA9IHBhdGgucmVwbGFjZSgvKFteXFxcXF0pXFxbL2csICckMS5bJyk7XG4gIHZhciBwYXJ0cyA9IHN0ci5tYXRjaCgvKFxcXFxcXC58W14uXSs/KSsvZyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24gbWFwTWF0Y2hlcyh2YWx1ZSkge1xuICAgIHZhciByZWdleHAgPSAvXlxcWyhcXGQrKVxcXSQvO1xuICAgIHZhciBtQXJyID0gcmVnZXhwLmV4ZWModmFsdWUpO1xuICAgIHZhciBwYXJzZWQgPSBudWxsO1xuICAgIGlmIChtQXJyKSB7XG4gICAgICBwYXJzZWQgPSB7IGk6IHBhcnNlRmxvYXQobUFyclsxXSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkID0geyBwOiB2YWx1ZS5yZXBsYWNlKC9cXFxcKFsuXFxbXFxdXSkvZywgJyQxJykgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9KTtcbn1cblxuLyogIVxuICogIyMgaW50ZXJuYWxHZXRQYXRoVmFsdWUob2JqLCBwYXJzZWRbLCBwYXRoRGVwdGhdKVxuICpcbiAqIEhlbHBlciBjb21wYW5pb24gZnVuY3Rpb24gZm9yIGAucGFyc2VQYXRoYCB0aGF0IHJldHVybnNcbiAqIHRoZSB2YWx1ZSBsb2NhdGVkIGF0IHRoZSBwYXJzZWQgYWRkcmVzcy5cbiAqXG4gKiAgICAgIHZhciB2YWx1ZSA9IGdldFBhdGhWYWx1ZShvYmosIHBhcnNlZCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZWFyY2ggYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZCBkZWZpbml0aW9uIGZyb20gYHBhcnNlUGF0aGAuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGggKG5lc3RpbmcgbGV2ZWwpIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHJldHJpZXZlXG4gKiBAcmV0dXJucyB7T2JqZWN0fFVuZGVmaW5lZH0gdmFsdWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGludGVybmFsR2V0UGF0aFZhbHVlKG9iaiwgcGFyc2VkLCBwYXRoRGVwdGgpIHtcbiAgdmFyIHRlbXBvcmFyeVZhbHVlID0gb2JqO1xuICB2YXIgcmVzID0gbnVsbDtcbiAgcGF0aERlcHRoID0gKHR5cGVvZiBwYXRoRGVwdGggPT09ICd1bmRlZmluZWQnID8gcGFyc2VkLmxlbmd0aCA6IHBhdGhEZXB0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoRGVwdGg7IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcGFyc2VkW2ldO1xuICAgIGlmICh0ZW1wb3JhcnlWYWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0LnAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRlbXBvcmFyeVZhbHVlID0gdGVtcG9yYXJ5VmFsdWVbcGFydC5pXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBvcmFyeVZhbHVlID0gdGVtcG9yYXJ5VmFsdWVbcGFydC5wXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IChwYXRoRGVwdGggLSAxKSkge1xuICAgICAgICByZXMgPSB0ZW1wb3JhcnlWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG4vKiAhXG4gKiAjIyBpbnRlcm5hbFNldFBhdGhWYWx1ZShvYmosIHZhbHVlLCBwYXJzZWQpXG4gKlxuICogQ29tcGFuaW9uIGZ1bmN0aW9uIGZvciBgcGFyc2VQYXRoYCB0aGF0IHNldHNcbiAqIHRoZSB2YWx1ZSBsb2NhdGVkIGF0IGEgcGFyc2VkIGFkZHJlc3MuXG4gKlxuICogIGludGVybmFsU2V0UGF0aFZhbHVlKG9iaiwgJ3ZhbHVlJywgcGFyc2VkKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIHNlYXJjaCBhbmQgZGVmaW5lIG9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIHRvIHVzZSB1cG9uIHNldFxuICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZCBkZWZpbml0aW9uIGZyb20gYHBhcnNlUGF0aGBcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGludGVybmFsU2V0UGF0aFZhbHVlKG9iaiwgdmFsLCBwYXJzZWQpIHtcbiAgdmFyIHRlbXBPYmogPSBvYmo7XG4gIHZhciBwYXRoRGVwdGggPSBwYXJzZWQubGVuZ3RoO1xuICB2YXIgcGFydCA9IG51bGw7XG4gIC8vIEhlcmUgd2UgaXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IHBhcnQgb2YgdGhlIHBhdGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoRGVwdGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IG51bGw7XG4gICAgdmFyIHByb3BWYWwgPSBudWxsO1xuICAgIHBhcnQgPSBwYXJzZWRbaV07XG5cbiAgICAvLyBJZiBpdCdzIHRoZSBsYXN0IHBhcnQgb2YgdGhlIHBhdGgsIHdlIHNldCB0aGUgJ3Byb3BOYW1lJyB2YWx1ZSB3aXRoIHRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgaWYgKGkgPT09IChwYXRoRGVwdGggLSAxKSkge1xuICAgICAgcHJvcE5hbWUgPSB0eXBlb2YgcGFydC5wID09PSAndW5kZWZpbmVkJyA/IHBhcnQuaSA6IHBhcnQucDtcbiAgICAgIC8vIE5vdyB3ZSBzZXQgdGhlIHByb3BlcnR5IHdpdGggdGhlIG5hbWUgaGVsZCBieSAncHJvcE5hbWUnIG9uIG9iamVjdCB3aXRoIHRoZSBkZXNpcmVkIHZhbFxuICAgICAgdGVtcE9ialtwcm9wTmFtZV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFydC5wICE9PSAndW5kZWZpbmVkJyAmJiB0ZW1wT2JqW3BhcnQucF0pIHtcbiAgICAgIHRlbXBPYmogPSB0ZW1wT2JqW3BhcnQucF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFydC5pICE9PSAndW5kZWZpbmVkJyAmJiB0ZW1wT2JqW3BhcnQuaV0pIHtcbiAgICAgIHRlbXBPYmogPSB0ZW1wT2JqW3BhcnQuaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBvYmogZG9lc24ndCBoYXZlIHRoZSBwcm9wZXJ0eSB3ZSBjcmVhdGUgb25lIHdpdGggdGhhdCBuYW1lIHRvIGRlZmluZSBpdFxuICAgICAgdmFyIG5leHQgPSBwYXJzZWRbaSArIDFdO1xuICAgICAgLy8gSGVyZSB3ZSBzZXQgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdoaWNoIHdpbGwgYmUgZGVmaW5lZFxuICAgICAgcHJvcE5hbWUgPSB0eXBlb2YgcGFydC5wID09PSAndW5kZWZpbmVkJyA/IHBhcnQuaSA6IHBhcnQucDtcbiAgICAgIC8vIEhlcmUgd2UgZGVjaWRlIGlmIHRoaXMgcHJvcGVydHkgd2lsbCBiZSBhbiBhcnJheSBvciBhIG5ldyBvYmplY3RcbiAgICAgIHByb3BWYWwgPSB0eXBlb2YgbmV4dC5wID09PSAndW5kZWZpbmVkJyA/IFtdIDoge307XG4gICAgICB0ZW1wT2JqW3Byb3BOYW1lXSA9IHByb3BWYWw7XG4gICAgICB0ZW1wT2JqID0gdGVtcE9ialtwcm9wTmFtZV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogIyMjIC5nZXRQYXRoSW5mbyhvYmplY3QsIHBhdGgpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBwcm9wZXJ0eSBpbmZvIGluIGFuXG4gKiBvYmplY3QgZ2l2ZW4gYSBzdHJpbmcgcGF0aC5cbiAqXG4gKiBUaGUgcGF0aCBpbmZvIGNvbnNpc3RzIG9mIGFuIG9iamVjdCB3aXRoIHRoZVxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogKiBwYXJlbnQgLSBUaGUgcGFyZW50IG9iamVjdCBvZiB0aGUgcHJvcGVydHkgcmVmZXJlbmNlZCBieSBgcGF0aGBcbiAqICogbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaW5hbCBwcm9wZXJ0eSwgYSBudW1iZXIgaWYgaXQgd2FzIGFuIGFycmF5IGluZGV4ZXJcbiAqICogdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5LCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICogKiBleGlzdHMgLSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBleGlzdHMgb3Igbm90XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IGluZm9cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldFBhdGhJbmZvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldFBhdGhJbmZvKG9iaiwgcGF0aCkge1xuICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKHBhdGgpO1xuICB2YXIgbGFzdCA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMV07XG4gIHZhciBpbmZvID0ge1xuICAgIHBhcmVudDogcGFyc2VkLmxlbmd0aCA+IDEgPyBpbnRlcm5hbEdldFBhdGhWYWx1ZShvYmosIHBhcnNlZCwgcGFyc2VkLmxlbmd0aCAtIDEpIDogb2JqLFxuICAgIG5hbWU6IGxhc3QucCB8fCBsYXN0LmksXG4gICAgdmFsdWU6IGludGVybmFsR2V0UGF0aFZhbHVlKG9iaiwgcGFyc2VkKSxcbiAgfTtcbiAgaW5mby5leGlzdHMgPSBoYXNQcm9wZXJ0eShpbmZvLnBhcmVudCwgaW5mby5uYW1lKTtcblxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiAjIyMgLmdldFBhdGhWYWx1ZShvYmplY3QsIHBhdGgpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiB2YWx1ZXMgaW4gYW5cbiAqIG9iamVjdCBnaXZlbiBhIHN0cmluZyBwYXRoLlxuICpcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICBwcm9wMToge1xuICogICAgICAgICAgICAgYXJyOiBbJ2EnLCAnYicsICdjJ11cbiAqICAgICAgICAgICAsIHN0cjogJ0hlbGxvJ1xuICogICAgICAgICB9XG4gKiAgICAgICAsIHByb3AyOiB7XG4gKiAgICAgICAgICAgICBhcnI6IFsgeyBuZXN0ZWQ6ICdVbml2ZXJzZScgfSBdXG4gKiAgICAgICAgICAgLCBzdHI6ICdIZWxsbyBhZ2FpbiEnXG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogVGhlIGZvbGxvd2luZyB3b3VsZCBiZSB0aGUgcmVzdWx0cy5cbiAqXG4gKiAgICAgZ2V0UGF0aFZhbHVlKG9iaiwgJ3Byb3AxLnN0cicpOyAvLyBIZWxsb1xuICogICAgIGdldFBhdGhWYWx1ZShvYmosICdwcm9wMS5hdHRbMl0nKTsgLy8gYlxuICogICAgIGdldFBhdGhWYWx1ZShvYmosICdwcm9wMi5hcnJbMF0ubmVzdGVkJyk7IC8vIFVuaXZlcnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IHZhbHVlIG9yIGB1bmRlZmluZWRgXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRQYXRoVmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGF0aFZhbHVlKG9iaiwgcGF0aCkge1xuICB2YXIgaW5mbyA9IGdldFBhdGhJbmZvKG9iaiwgcGF0aCk7XG4gIHJldHVybiBpbmZvLnZhbHVlO1xufVxuXG4vKipcbiAqICMjIyAuc2V0UGF0aFZhbHVlKG9iamVjdCwgcGF0aCwgdmFsdWUpXG4gKlxuICogRGVmaW5lIHRoZSB2YWx1ZSBpbiBhbiBvYmplY3QgYXQgYSBnaXZlbiBzdHJpbmcgcGF0aC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG9iaiA9IHtcbiAqICAgICBwcm9wMToge1xuICogICAgICAgICBhcnI6IFsnYScsICdiJywgJ2MnXVxuICogICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICB9XG4gKiAgICwgcHJvcDI6IHtcbiAqICAgICAgICAgYXJyOiBbIHsgbmVzdGVkOiAnVW5pdmVyc2UnIH0gXVxuICogICAgICAgLCBzdHI6ICdIZWxsbyBhZ2FpbiEnXG4gKiAgICAgfVxuICogfTtcbiAqIGBgYFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgYWNjZXB0YWJsZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHByb3BlcnRpZXMgPSByZXF1aXJlKCd0ZWEtcHJvcGVydGllcycpO1xuICogcHJvcGVydGllcy5zZXQob2JqLCAncHJvcDEuc3RyJywgJ0hlbGxvIFVuaXZlcnNlIScpO1xuICogcHJvcGVydGllcy5zZXQob2JqLCAncHJvcDEuYXJyWzJdJywgJ0InKTtcbiAqIHByb3BlcnRpZXMuc2V0KG9iaiwgJ3Byb3AyLmFyclswXS5uZXN0ZWQudmFsdWUnLCB7IGhlbGxvOiAndW5pdmVyc2UnIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXRQYXRoVmFsdWUob2JqLCBwYXRoLCB2YWwpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aChwYXRoKTtcbiAgaW50ZXJuYWxTZXRQYXRoVmFsdWUob2JqLCB2YWwsIHBhcnNlZCk7XG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBoYXNQcm9wZXJ0eTogaGFzUHJvcGVydHksXG4gIGdldFBhdGhJbmZvOiBnZXRQYXRoSW5mbyxcbiAgZ2V0UGF0aFZhbHVlOiBnZXRQYXRoVmFsdWUsXG4gIHNldFBhdGhWYWx1ZTogc2V0UGF0aFZhbHVlLFxufTtcbiIsIi8qIVxuICogQ2hhaSAtIGZsYWcgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5mbGFnKG9iamVjdCwga2V5LCBbdmFsdWVdKVxuICpcbiAqIEdldCBvciBzZXQgYSBmbGFnIHZhbHVlIG9uIGFuIG9iamVjdC4gSWYgYVxuICogdmFsdWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBzZXQsIGVsc2UgaXQgd2lsbFxuICogcmV0dXJuIHRoZSBjdXJyZW50bHkgc2V0IHZhbHVlIG9yIGB1bmRlZmluZWRgIGlmXG4gKiB0aGUgdmFsdWUgaXMgbm90IHNldC5cbiAqXG4gKiAgICAgdXRpbHMuZmxhZyh0aGlzLCAnZm9vJywgJ2JhcicpOyAvLyBzZXR0ZXJcbiAqICAgICB1dGlscy5mbGFnKHRoaXMsICdmb28nKTsgLy8gZ2V0dGVyLCByZXR1cm5zIGBiYXJgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBjb25zdHJ1Y3RlZCBBc3NlcnRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIChvcHRpb25hbClcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGZsYWdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmxhZyhvYmosIGtleSwgdmFsdWUpIHtcbiAgdmFyIGZsYWdzID0gb2JqLl9fZmxhZ3MgfHwgKG9iai5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgZmxhZ3Nba2V5XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmbGFnc1trZXldO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdGVzdCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxuLyoqXG4gKiAjIyMgLnRlc3Qob2JqZWN0LCBleHByZXNzaW9uKVxuICpcbiAqIFRlc3QgYW5kIG9iamVjdCBmb3IgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIHRlc3RcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlc3Qob2JqLCBhcmdzKSB7XG4gIHZhciBuZWdhdGUgPSBmbGFnKG9iaiwgJ25lZ2F0ZScpXG4gICAgLCBleHByID0gYXJnc1swXTtcbiAgcmV0dXJuIG5lZ2F0ZSA/ICFleHByIDogZXhwcjtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwudHlwZURldGVjdCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLyogIVxuICogdHlwZS1kZXRlY3RcbiAqIENvcHlyaWdodChjKSAyMDEzIGpha2UgbHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cbnZhciBwcm9taXNlRXhpc3RzID0gdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbic7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG52YXIgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnID8gc2VsZiA6IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpZC1ibGFja2xpc3RcblxudmFyIHN5bWJvbEV4aXN0cyA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xudmFyIG1hcEV4aXN0cyA9IHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnO1xudmFyIHNldEV4aXN0cyA9IHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnO1xudmFyIHdlYWtNYXBFeGlzdHMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgd2Vha1NldEV4aXN0cyA9IHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJztcbnZhciBkYXRhVmlld0V4aXN0cyA9IHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc3ltYm9sSXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xFeGlzdHMgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgPSBzeW1ib2xFeGlzdHMgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc2V0RW50cmllc0V4aXN0cyA9IHNldEV4aXN0cyAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nO1xudmFyIG1hcEVudHJpZXNFeGlzdHMgPSBtYXBFeGlzdHMgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBzZXRJdGVyYXRvclByb3RvdHlwZSA9IHNldEVudHJpZXNFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBTZXQoKS5lbnRyaWVzKCkpO1xudmFyIG1hcEl0ZXJhdG9yUHJvdG90eXBlID0gbWFwRW50cmllc0V4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IE1hcCgpLmVudHJpZXMoKSk7XG52YXIgYXJyYXlJdGVyYXRvckV4aXN0cyA9IHN5bWJvbEl0ZXJhdG9yRXhpc3RzICYmIHR5cGVvZiBBcnJheS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBhcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gYXJyYXlJdGVyYXRvckV4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoW11bU3ltYm9sLml0ZXJhdG9yXSgpKTtcbnZhciBzdHJpbmdJdGVyYXRvckV4aXN0cyA9IHN5bWJvbEl0ZXJhdG9yRXhpc3RzICYmIHR5cGVvZiBTdHJpbmcucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgc3RyaW5nSXRlcmF0b3JQcm90b3R5cGUgPSBzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJydbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbnZhciB0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCA9IDg7XG52YXIgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoID0gLTE7XG4vKipcbiAqICMjIyB0eXBlT2YgKG9iailcbiAqXG4gKiBVc2VzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LFxuICogbm9ybWFsaXNpbmcgYmVoYXZpb3VyIGFjcm9zcyBlbmdpbmUgdmVyc2lvbnMgJiB3ZWxsIG9wdGltaXNlZC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEByZXR1cm4ge1N0cmluZ30gb2JqZWN0IHR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHR5cGVEZXRlY3Qob2JqKSB7XG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBzdHJpbmcgbGl0ZXJhbCAgICAgeCAzLDAzOSwwMzUgb3BzL3NlYyDCsTEuNjIlICg3OCBydW5zIHNhbXBsZWQpXG4gICAqICAgYm9vbGVhbiBsaXRlcmFsICAgIHggMSw0MjQsMTM4IG9wcy9zZWMgwrE0LjU0JSAoNzUgcnVucyBzYW1wbGVkKVxuICAgKiAgIG51bWJlciBsaXRlcmFsICAgICB4IDEsNjUzLDE1MyBvcHMvc2VjIMKxMS45MSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogICB1bmRlZmluZWQgICAgICAgICAgeCA5LDk3OCw2NjAgb3BzL3NlYyDCsTEuOTIlICg3NSBydW5zIHNhbXBsZWQpXG4gICAqICAgZnVuY3Rpb24gICAgICAgICAgIHggMiw1NTYsNzY5IG9wcy9zZWMgwrExLjczJSAoNzcgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIHN0cmluZyBsaXRlcmFsICAgICB4IDM4LDU2NCw3OTYgb3BzL3NlYyDCsTEuMTUlICg3OSBydW5zIHNhbXBsZWQpXG4gICAqICAgYm9vbGVhbiBsaXRlcmFsICAgIHggMzEsMTQ4LDk0MCBvcHMvc2VjIMKxMS4xMCUgKDc5IHJ1bnMgc2FtcGxlZClcbiAgICogICBudW1iZXIgbGl0ZXJhbCAgICAgeCAzMiw2NzksMzMwIG9wcy9zZWMgwrExLjkwJSAoNzggcnVucyBzYW1wbGVkKVxuICAgKiAgIHVuZGVmaW5lZCAgICAgICAgICB4IDMyLDM2MywzNjggb3BzL3NlYyDCsTEuMDclICg4MiBydW5zIHNhbXBsZWQpXG4gICAqICAgZnVuY3Rpb24gICAgICAgICAgIHggMzEsMjk2LDg3MCBvcHMvc2VjIMKxMC45NiUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgICovXG4gIHZhciB0eXBlb2ZPYmogPSB0eXBlb2Ygb2JqO1xuICBpZiAodHlwZW9mT2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlb2ZPYmo7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgKiBQcmU6XG4gICAqICAgbnVsbCAgICAgICAgICAgICAgIHggMjgsNjQ1LDc2NSBvcHMvc2VjIMKxMS4xNyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogUG9zdDpcbiAgICogICBudWxsICAgICAgICAgICAgICAgeCAzNiw0MjgsOTYyIG9wcy9zZWMgwrExLjM3JSAoODQgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cpYGBcbiAgICogIC0gTm9kZSA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBnbG9iYWxdXCJcbiAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBQaGFudG9tSlMgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIElFIDExID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIElFIEVkZ2UgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKWBgXG4gICAqICAtIENocm9tZSBXb3JrZXIgPT09IFwiW29iamVjdCBnbG9iYWxdXCJcbiAgICogIC0gRmlyZWZveCBXb3JrZXIgPT09IFwiW29iamVjdCBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBTYWZhcmkgV29ya2VyID09PSBcIltvYmplY3QgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICogIC0gSUUgMTEgV29ya2VyID09PSBcIltvYmplY3QgV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICogIC0gSUUgRWRnZSBXb3JrZXIgPT09IFwiW29iamVjdCBXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKi9cbiAgaWYgKG9iaiA9PT0gZ2xvYmFsT2JqZWN0KSB7XG4gICAgcmV0dXJuICdnbG9iYWwnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIGFycmF5IGxpdGVyYWwgICAgICB4IDIsODg4LDM1MiBvcHMvc2VjIMKxMC42NyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogUG9zdDpcbiAgICogICBhcnJheSBsaXRlcmFsICAgICAgeCAyMiw0NzksNjUwIG9wcy9zZWMgwrEwLjk2JSAoODEgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgaWYgKFxuICAgIEFycmF5LmlzQXJyYXkob2JqKSAmJlxuICAgIChzeW1ib2xUb1N0cmluZ1RhZ0V4aXN0cyA9PT0gZmFsc2UgfHwgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gb2JqKSlcbiAgKSB7XG4gICAgcmV0dXJuICdBcnJheSc7XG4gIH1cblxuICAvLyBOb3QgY2FjaGluZyBleGlzdGVuY2Ugb2YgYHdpbmRvd2AgYW5kIHJlbGF0ZWQgcHJvcGVydGllcyBkdWUgdG8gcG90ZW50aWFsXG4gIC8vIGZvciBgd2luZG93YCB0byBiZSB1bnNldCBiZWZvcmUgdGVzdHMgaW4gcXVhc2ktYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cgIT09IG51bGwpIHtcbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvYnJvd3NlcnMuaHRtbCNsb2NhdGlvbilcbiAgICAgKiBXaGF0V0cgSFRNTCQ3LjcuMyAtIFRoZSBgTG9jYXRpb25gIGludGVyZmFjZVxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LmxvY2F0aW9uKWBgXG4gICAgICogIC0gSUUgPD0xMSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqICAtIElFIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmICh0eXBlb2Ygd2luZG93LmxvY2F0aW9uID09PSAnb2JqZWN0JyAmJiBvYmogPT09IHdpbmRvdy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuICdMb2NhdGlvbic7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2RvY3VtZW50KVxuICAgICAqIFdoYXRXRyBIVE1MJDMuMS4xIC0gVGhlIGBEb2N1bWVudGAgb2JqZWN0XG4gICAgICogTm90ZTogTW9zdCBicm93c2VycyBjdXJyZW50bHkgYWRoZXIgdG8gdGhlIFczQyBET00gTGV2ZWwgMiBzcGVjXG4gICAgICogICAgICAgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1IVE1ML2h0bWwuaHRtbCNJRC0yNjgwOTI2OClcbiAgICAgKiAgICAgICB3aGljaCBzdWdnZXN0cyB0aGF0IGJyb3dzZXJzIHNob3VsZCB1c2UgSFRNTFRhYmxlQ2VsbEVsZW1lbnQgZm9yXG4gICAgICogICAgICAgYm90aCBURCBhbmQgVEggZWxlbWVudHMuIFdoYXRXRyBzZXBhcmF0ZXMgdGhlc2UuXG4gICAgICogICAgICAgV2hhdFdHIEhUTUwgc3RhdGVzOlxuICAgICAqICAgICAgICAgPiBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCBXaW5kb3cgb2JqZWN0cyBtdXN0IGFsc28gaGF2ZSBhXG4gICAgICogICAgICAgICA+IHdyaXRhYmxlLCBjb25maWd1cmFibGUsIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVkXG4gICAgICogICAgICAgICA+IEhUTUxEb2N1bWVudCB3aG9zZSB2YWx1ZSBpcyB0aGUgRG9jdW1lbnQgaW50ZXJmYWNlIG9iamVjdC5cbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50KWBgXG4gICAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBEb2N1bWVudF1cIlxuICAgICAqICAtIElFIDExID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgRWRnZSA8PTEzID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgPT09ICdvYmplY3QnICYmIG9iaiA9PT0gd2luZG93LmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gJ0RvY3VtZW50JztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgPT09ICdvYmplY3QnKSB7XG4gICAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjbWltZXR5cGVhcnJheSlcbiAgICAgICAqIFdoYXRXRyBIVE1MJDguNi4xLjUgLSBQbHVnaW5zIC0gSW50ZXJmYWNlIE1pbWVUeXBlQXJyYXlcbiAgICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmF2aWdhdG9yLm1pbWVUeXBlcylgYFxuICAgICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IE1TTWltZVR5cGVzQ29sbGVjdGlvbl1cIlxuICAgICAgICovXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IubWltZVR5cGVzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIG9iaiA9PT0gd2luZG93Lm5hdmlnYXRvci5taW1lVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuICdNaW1lVHlwZUFycmF5JztcbiAgICAgIH1cblxuICAgICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3BsdWdpbmFycmF5KVxuICAgICAgICogV2hhdFdHIEhUTUwkOC42LjEuNSAtIFBsdWdpbnMgLSBJbnRlcmZhY2UgUGx1Z2luQXJyYXlcbiAgICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmF2aWdhdG9yLnBsdWdpbnMpYGBcbiAgICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBNU1BsdWdpbnNDb2xsZWN0aW9uXVwiXG4gICAgICAgKi9cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvci5wbHVnaW5zID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIG9iaiA9PT0gd2luZG93Lm5hdmlnYXRvci5wbHVnaW5zKSB7XG4gICAgICAgIHJldHVybiAnUGx1Z2luQXJyYXknO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgodHlwZW9mIHdpbmRvdy5IVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2Ygd2luZG93LkhUTUxFbGVtZW50ID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgb2JqIGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbGVtZW50KSB7XG4gICAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNwbHVnaW5hcnJheSlcbiAgICAgICogV2hhdFdHIEhUTUwkNC40LjQgLSBUaGUgYGJsb2NrcXVvdGVgIGVsZW1lbnQgLSBJbnRlcmZhY2UgYEhUTUxRdW90ZUVsZW1lbnRgXG4gICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYmxvY2txdW90ZScpKWBgXG4gICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBIVE1MQmxvY2tFbGVtZW50XVwiXG4gICAgICAqL1xuICAgICAgaWYgKG9iai50YWdOYW1lID09PSAnQkxPQ0tRVU9URScpIHtcbiAgICAgICAgcmV0dXJuICdIVE1MUXVvdGVFbGVtZW50JztcbiAgICAgIH1cblxuICAgICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaHRtbHRhYmxlZGF0YWNlbGxlbGVtZW50KVxuICAgICAgICogV2hhdFdHIEhUTUwkNC45LjkgLSBUaGUgYHRkYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MVGFibGVEYXRhQ2VsbEVsZW1lbnRgXG4gICAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgICAqICAgICAgIChodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwjSUQtODI5MTUwNzUpXG4gICAgICAgKiAgICAgICB3aGljaCBzdWdnZXN0cyB0aGF0IGJyb3dzZXJzIHNob3VsZCB1c2UgSFRNTFRhYmxlQ2VsbEVsZW1lbnQgZm9yXG4gICAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgICAqIFRlc3Q6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpKVxuICAgICAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgICAqL1xuICAgICAgaWYgKG9iai50YWdOYW1lID09PSAnVEQnKSB7XG4gICAgICAgIHJldHVybiAnSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50JztcbiAgICAgIH1cblxuICAgICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaHRtbHRhYmxlaGVhZGVyY2VsbGVsZW1lbnQpXG4gICAgICAgKiBXaGF0V0cgSFRNTCQ0LjkuOSAtIFRoZSBgdGRgIGVsZW1lbnQgLSBJbnRlcmZhY2UgYEhUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50YFxuICAgICAgICogTm90ZTogTW9zdCBicm93c2VycyBjdXJyZW50bHkgYWRoZXIgdG8gdGhlIFczQyBET00gTGV2ZWwgMiBzcGVjXG4gICAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTgyOTE1MDc1KVxuICAgICAgICogICAgICAgd2hpY2ggc3VnZ2VzdHMgdGhhdCBicm93c2VycyBzaG91bGQgdXNlIEhUTUxUYWJsZUNlbGxFbGVtZW50IGZvclxuICAgICAgICogICAgICAgYm90aCBURCBhbmQgVEggZWxlbWVudHMuIFdoYXRXRyBzZXBhcmF0ZXMgdGhlc2UuXG4gICAgICAgKiBUZXN0OiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKSlcbiAgICAgICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICAgKi9cbiAgICAgIGlmIChvYmoudGFnTmFtZSA9PT0gJ1RIJykge1xuICAgICAgICByZXR1cm4gJ0hUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50JztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIEZsb2F0NjRBcnJheSAgICAgICB4IDYyNSw2NDQgb3BzL3NlYyDCsTEuNTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCAxLDI3OSw4NTIgb3BzL3NlYyDCsTIuOTElICg3NyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MzJBcnJheSAgICAgICAgeCAxLDE3OCwxODUgb3BzL3NlYyDCsTEuOTUlICg4MyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MTZBcnJheSAgICAgICAgeCAxLDAwOCwzODAgb3BzL3NlYyDCsTIuMjUlICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCAxLDEyOCwwNDAgb3BzL3NlYyDCsTIuMTElICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQzMkFycmF5ICAgICAgICAgeCAxLDE3MCwxMTkgb3BzL3NlYyDCsTIuODglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBJbnQxNkFycmF5ICAgICAgICAgeCAxLDE3NiwzNDggb3BzL3NlYyDCsTUuNzklICg4NiBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCAxLDA1OCw3MDcgb3BzL3NlYyDCsTQuOTQlICg3NyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OENsYW1wZWRBcnJheSAgeCAxLDExMCw2MzMgb3BzL3NlYyDCsTQuMjAlICg4MCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIEZsb2F0NjRBcnJheSAgICAgICB4IDcsMTA1LDY3MSBvcHMvc2VjIMKxMTMuNDclICg2NCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCA1LDg4Nyw5MTIgb3BzL3NlYyDCsTEuNDYlICg4MiBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MzJBcnJheSAgICAgICAgeCA2LDQ5MSw2NjEgb3BzL3NlYyDCsTEuNzYlICg3OSBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MTZBcnJheSAgICAgICAgeCA2LDU1OSw3OTUgb3BzL3NlYyDCsTEuNjclICg4MiBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCA2LDQ2Myw5NjYgb3BzL3NlYyDCsTEuNDMlICg4NSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQzMkFycmF5ICAgICAgICAgeCA1LDY0MSw4NDEgb3BzL3NlYyDCsTMuNDklICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQxNkFycmF5ICAgICAgICAgeCA2LDU4Myw1MTEgb3BzL3NlYyDCsTEuOTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCA2LDYwNiwwNzggb3BzL3NlYyDCsTEuNzQlICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OENsYW1wZWRBcnJheSAgeCA2LDYwMiwyMjQgb3BzL3NlYyDCsTEuNzclICg4MyBydW5zIHNhbXBsZWQpXG4gICovXG4gIHZhciBzdHJpbmdUYWcgPSAoc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgJiYgb2JqW1N5bWJvbC50b1N0cmluZ1RhZ10pO1xuICBpZiAodHlwZW9mIHN0cmluZ1RhZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyaW5nVGFnO1xuICB9XG5cbiAgdmFyIG9ialByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIHJlZ2V4IGxpdGVyYWwgICAgICB4IDEsNzcyLDM4NSBvcHMvc2VjIMKxMS44NSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgKiAgIHJlZ2V4IGNvbnN0cnVjdG9yICB4IDIsMTQzLDYzNCBvcHMvc2VjIMKxMi40NiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgcmVnZXggbGl0ZXJhbCAgICAgIHggMyw5MjgsMDA5IG9wcy9zZWMgwrEwLjY1JSAoNzggcnVucyBzYW1wbGVkKVxuICAqICAgcmVnZXggY29uc3RydWN0b3IgIHggMyw5MzEsMTA4IG9wcy9zZWMgwrEwLjU4JSAoODQgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAob2JqUHJvdG90eXBlID09PSBSZWdFeHAucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdSZWdFeHAnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBkYXRlICAgICAgICAgICAgICAgeCAyLDEzMCwwNzQgb3BzL3NlYyDCsTQuNDIlICg2OCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIGRhdGUgICAgICAgICAgICAgICB4IDMsOTUzLDc3OSBvcHMvc2VjIMKxMS4zNSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKG9ialByb3RvdHlwZSA9PT0gRGF0ZS5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ0RhdGUnO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLXByb21pc2UucHJvdG90eXBlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyNS40LjUuNCAtIFByb21pc2UucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIlByb21pc2VcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQcm9taXNlLnJlc29sdmUoKSlgYFxuICAgKiAgLSBDaHJvbWUgPD00NyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgKiAgLSBFZGdlIDw9MjAgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICogIC0gRmlyZWZveCAyOS1MYXRlc3QgPT09IFwiW29iamVjdCBQcm9taXNlXVwiXG4gICAqICAtIFNhZmFyaSA3LjEtTGF0ZXN0ID09PSBcIltvYmplY3QgUHJvbWlzZV1cIlxuICAgKi9cbiAgaWYgKHByb21pc2VFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBQcm9taXNlLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnUHJvbWlzZSc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIHNldCAgICAgICAgICAgICAgICB4IDIsMjIyLDE4NiBvcHMvc2VjIMKxMS4zMSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgc2V0ICAgICAgICAgICAgICAgIHggNCw1NDUsODc5IG9wcy9zZWMgwrExLjEzJSAoODMgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAoc2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gU2V0LnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnU2V0JztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgbWFwICAgICAgICAgICAgICAgIHggMiwzOTYsODQyIG9wcy9zZWMgwrExLjU5JSAoODEgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBtYXAgICAgICAgICAgICAgICAgeCA0LDE4Myw5NDUgb3BzL3NlYyDCsTYuNTklICg4MiBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmIChtYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBNYXAucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdNYXAnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICB3ZWFrc2V0ICAgICAgICAgICAgeCAxLDMyMywyMjAgb3BzL3NlYyDCsTIuMTclICg3NiBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHdlYWtzZXQgICAgICAgICAgICB4IDQsMjM3LDUxMCBvcHMvc2VjIMKxMi4wMSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKHdlYWtTZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBXZWFrU2V0LnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnV2Vha1NldCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIHdlYWttYXAgICAgICAgICAgICB4IDEsNTAwLDI2MCBvcHMvc2VjIMKxMi4wMiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgd2Vha21hcCAgICAgICAgICAgIHggMyw4ODEsMzg0IG9wcy9zZWMgwrExLjQ1JSAoODIgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAod2Vha01hcEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFdlYWtNYXAucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdXZWFrTWFwJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy1kYXRhdmlldy5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDI0LjIuNC4yMSAtIERhdGFWaWV3LnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJEYXRhVmlld1wiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKWBgXG4gICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgKi9cbiAgaWYgKGRhdGFWaWV3RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gRGF0YVZpZXcucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdEYXRhVmlldyc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJW1hcGl0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjMuMS41LjIuMiAtICVNYXBJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiTWFwIEl0ZXJhdG9yXCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IE1hcCgpLmVudHJpZXMoKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChtYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBtYXBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnTWFwIEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lc2V0aXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyMy4yLjUuMi4yIC0gJVNldEl0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJTZXQgSXRlcmF0b3JcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgU2V0KCkuZW50cmllcygpKWBgXG4gICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgKi9cbiAgaWYgKHNldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IHNldEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdTZXQgSXRlcmF0b3InO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjIuMS41LjIuMiAtICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJBcnJheSBJdGVyYXRvclwiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChhcnJheUl0ZXJhdG9yRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gYXJyYXlJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnQXJyYXkgSXRlcmF0b3InO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDIxLjEuNS4yLjIgLSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIlN0cmluZyBJdGVyYXRvclwiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IHN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdTdHJpbmcgSXRlcmF0b3InO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBvYmplY3QgZnJvbSBudWxsICAgeCAyLDQyNCwzMjAgb3BzL3NlYyDCsTEuNjclICg3NiBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIG9iamVjdCBmcm9tIG51bGwgICB4IDUsODM4LDAwMCBvcHMvc2VjIMKxMC45OSUgKDg0IHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKG9ialByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxuXG4gIHJldHVybiBPYmplY3RcbiAgICAucHJvdG90eXBlXG4gICAgLnRvU3RyaW5nXG4gICAgLmNhbGwob2JqKVxuICAgIC5zbGljZSh0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCwgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoKTtcbn1cblxucmV0dXJuIHR5cGVEZXRlY3Q7XG5cbn0pKSk7XG4iLCIvKiFcbiAqIENoYWkgLSBleHBlY3RUeXBlcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmV4cGVjdFR5cGVzKG9iaiwgdHlwZXMpXG4gKlxuICogRW5zdXJlcyB0aGF0IHRoZSBvYmplY3QgYmVpbmcgdGVzdGVkIGFnYWluc3QgaXMgb2YgYSB2YWxpZCB0eXBlLlxuICpcbiAqICAgICB1dGlscy5leHBlY3RUeXBlcyh0aGlzLCBbJ2FycmF5JywgJ29iamVjdCcsICdzdHJpbmcnXSk7XG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqIGNvbnN0cnVjdGVkIEFzc2VydGlvblxuICogQHBhcmFtIHtBcnJheX0gdHlwZSBBIGxpc3Qgb2YgYWxsb3dlZCB0eXBlcyBmb3IgdGhpcyBhc3NlcnRpb25cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGV4cGVjdFR5cGVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBBc3NlcnRpb25FcnJvciA9IHJlcXVpcmUoJ2Fzc2VydGlvbi1lcnJvcicpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHBlY3RUeXBlcyhvYmosIHR5cGVzKSB7XG4gIHZhciBmbGFnTXNnID0gZmxhZyhvYmosICdtZXNzYWdlJyk7XG4gIHZhciBzc2ZpID0gZmxhZyhvYmosICdzc2ZpJyk7XG5cbiAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuXG4gIG9iaiA9IGZsYWcob2JqLCAnb2JqZWN0Jyk7XG4gIHR5cGVzID0gdHlwZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnRvTG93ZXJDYXNlKCk7IH0pO1xuICB0eXBlcy5zb3J0KCk7XG5cbiAgLy8gVHJhbnNmb3JtcyBbJ2xvcmVtJywgJ2lwc3VtJ10gaW50byAnYSBsb3JlbSwgb3IgYW4gaXBzdW0nXG4gIHZhciBzdHIgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHQsIGluZGV4KSB7XG4gICAgdmFyIGFydCA9IH5bICdhJywgJ2UnLCAnaScsICdvJywgJ3UnIF0uaW5kZXhPZih0LmNoYXJBdCgwKSkgPyAnYW4nIDogJ2EnO1xuICAgIHZhciBvciA9IHR5cGVzLmxlbmd0aCA+IDEgJiYgaW5kZXggPT09IHR5cGVzLmxlbmd0aCAtIDEgPyAnb3IgJyA6ICcnO1xuICAgIHJldHVybiBvciArIGFydCArICcgJyArIHQ7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgdmFyIG9ialR5cGUgPSB0eXBlKG9iaikudG9Mb3dlckNhc2UoKTtcblxuICBpZiAoIXR5cGVzLnNvbWUoZnVuY3Rpb24gKGV4cGVjdGVkKSB7IHJldHVybiBvYmpUeXBlID09PSBleHBlY3RlZDsgfSkpIHtcbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICBmbGFnTXNnICsgJ29iamVjdCB0ZXN0ZWQgbXVzdCBiZSAnICsgc3RyICsgJywgYnV0ICcgKyBvYmpUeXBlICsgJyBnaXZlbicsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBzc2ZpXG4gICAgKTtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldEFjdHVhbCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldEFjdHVhbChvYmplY3QsIFthY3R1YWxdKVxuICpcbiAqIFJldHVybnMgdGhlIGBhY3R1YWxgIHZhbHVlIGZvciBhbiBBc3NlcnRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRBY3R1YWxcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEFjdHVhbChvYmosIGFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MubGVuZ3RoID4gNCA/IGFyZ3NbNF0gOiBvYmouX29iajtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qICFcbiAqIENoYWkgLSBnZXRGdW5jTmFtZSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE2IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldEZ1bmNOYW1lKGNvbnN0cnVjdG9yRm4pXG4gKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uLlxuICogV2hlbiBhIG5vbi1mdW5jdGlvbiBpbnN0YW5jZSBpcyBwYXNzZWQsIHJldHVybnMgYG51bGxgLlxuICogVGhpcyBhbHNvIGluY2x1ZGVzIGEgcG9seWZpbGwgZnVuY3Rpb24gaWYgYGFGdW5jLm5hbWVgIGlzIG5vdCBkZWZpbmVkLlxuICpcbiAqIEBuYW1lIGdldEZ1bmNOYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY3Rpb25OYW1lTWF0Y2ggPSAvXFxzKmZ1bmN0aW9uKD86XFxzfFxccypcXC9cXCpbXig/OipcXC8pXStcXCpcXC9cXHMqKSooW15cXHNcXChcXC9dKykvO1xuZnVuY3Rpb24gZ2V0RnVuY05hbWUoYUZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBhRnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG5hbWUgPSAnJztcbiAgaWYgKHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGUubmFtZSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGFGdW5jLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gSGVyZSB3ZSBydW4gYSBwb2x5ZmlsbCBpZiBGdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgbmFtZWAgcHJvcGVydHkgYW5kIGlmIGFGdW5jLm5hbWUgaXMgbm90IGRlZmluZWRcbiAgICB2YXIgbWF0Y2ggPSB0b1N0cmluZy5jYWxsKGFGdW5jKS5tYXRjaChmdW5jdGlvbk5hbWVNYXRjaCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlJ3ZlIGdvdCBhIGBuYW1lYCBwcm9wZXJ0eSB3ZSBqdXN0IHVzZSBpdFxuICAgIG5hbWUgPSBhRnVuYy5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RnVuY05hbWU7XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0UHJvcGVydGllcyhvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsIGVudW1lcmFibGUgb3Igbm90LFxuICogaW5oZXJpdGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UHJvcGVydGllcyhvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCk7XG5cbiAgZnVuY3Rpb24gYWRkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICBpZiAocmVzdWx0LmluZGV4T2YocHJvcGVydHkpID09PSAtMSkge1xuICAgICAgcmVzdWx0LnB1c2gocHJvcGVydHkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICB3aGlsZSAocHJvdG8gIT09IG51bGwpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChhZGRQcm9wZXJ0eSk7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldEVudW1lcmFibGVQcm9wZXJ0aWVzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LFxuICogaW5oZXJpdGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRFbnVtZXJhYmxlUHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy5pbmNsdWRlU3RhY2tcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGluZmx1ZW5jZXMgd2hldGhlciBzdGFjayB0cmFjZVxuICAgKiBpcyBpbmNsdWRlZCBpbiBBc3NlcnRpb24gZXJyb3IgbWVzc2FnZS4gRGVmYXVsdCBvZiBmYWxzZVxuICAgKiBzdXBwcmVzc2VzIHN0YWNrIHRyYWNlIGluIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgKlxuICAgKiAgICAgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrID0gdHJ1ZTsgIC8vIGVuYWJsZSBzdGFjayBvbiBlcnJvclxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGluY2x1ZGVTdGFjazogZmFsc2UsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuc2hvd0RpZmZcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGluZmx1ZW5jZXMgd2hldGhlciBvciBub3RcbiAgICogdGhlIGBzaG93RGlmZmAgZmxhZyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHRocm93blxuICAgKiBBc3NlcnRpb25FcnJvcnMuIGBmYWxzZWAgd2lsbCBhbHdheXMgYmUgYGZhbHNlYDsgYHRydWVgXG4gICAqIHdpbGwgYmUgdHJ1ZSB3aGVuIHRoZSBhc3NlcnRpb24gaGFzIHJlcXVlc3RlZCBhIGRpZmZcbiAgICogYmUgc2hvd24uXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgc2hvd0RpZmY6IHRydWUsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGRcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIHNldHMgbGVuZ3RoIHRocmVzaG9sZCBmb3IgYWN0dWFsIGFuZFxuICAgKiBleHBlY3RlZCB2YWx1ZXMgaW4gYXNzZXJ0aW9uIGVycm9ycy4gSWYgdGhpcyB0aHJlc2hvbGQgaXMgZXhjZWVkZWQsIGZvclxuICAgKiBleGFtcGxlIGZvciBsYXJnZSBkYXRhIHN0cnVjdHVyZXMsIHRoZSB2YWx1ZSBpcyByZXBsYWNlZCB3aXRoIHNvbWV0aGluZ1xuICAgKiBsaWtlIGBbIEFycmF5KDMpIF1gIG9yIGB7IE9iamVjdCAocHJvcDEsIHByb3AyKSB9YC5cbiAgICpcbiAgICogU2V0IGl0IHRvIHplcm8gaWYgeW91IHdhbnQgdG8gZGlzYWJsZSB0cnVuY2F0aW5nIGFsdG9nZXRoZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgZXNwZWNpYWxseSB1c2VyZnVsIHdoZW4gZG9pbmcgYXNzZXJ0aW9ucyBvbiBhcnJheXM6IGhhdmluZyB0aGlzXG4gICAqIHNldCB0byBhIHJlYXNvbmFibGUgbGFyZ2UgdmFsdWUgbWFrZXMgdGhlIGZhaWx1cmUgbWVzc2FnZXMgcmVhZGlseVxuICAgKiBpbnNwZWN0YWJsZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLnRydW5jYXRlVGhyZXNob2xkID0gMDsgIC8vIGRpc2FibGUgdHJ1bmNhdGluZ1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdHJ1bmNhdGVUaHJlc2hvbGQ6IDQwLFxuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLnVzZVByb3h5XG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBkZWZpbmVzIGlmIGNoYWkgd2lsbCB1c2UgYSBQcm94eSB0byB0aHJvd1xuICAgKiBhbiBlcnJvciB3aGVuIGEgbm9uLWV4aXN0ZW50IHByb3BlcnR5IGlzIHJlYWQsIHdoaWNoIHByb3RlY3RzIHVzZXJzXG4gICAqIGZyb20gdHlwb3Mgd2hlbiB1c2luZyBwcm9wZXJ0eS1iYXNlZCBhc3NlcnRpb25zLlxuICAgKlxuICAgKiBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZGlzYWJsZSB0aGlzIGZlYXR1cmUuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy51c2VQcm94eSA9IGZhbHNlOyAgLy8gZGlzYWJsZSB1c2Ugb2YgUHJveHlcbiAgICpcbiAgICogVGhpcyBmZWF0dXJlIGlzIGF1dG9tYXRpY2FsbHkgZGlzYWJsZWQgcmVnYXJkbGVzcyBvZiB0aGlzIGNvbmZpZyB2YWx1ZVxuICAgKiBpbiBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBzdXBwb3J0IHByb3hpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdXNlUHJveHk6IHRydWUsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcucHJveHlFeGNsdWRlZEtleXNcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGRlZmluZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgaWdub3JlZFxuICAgKiBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yIGlmIHRoZXkgZG8gbm90IGV4aXN0IG9uIHRoZSBhc3NlcnRpb24uXG4gICAqIFRoaXMgaXMgb25seSBhcHBsaWVkIGlmIHRoZSBlbnZpcm9ubWVudCBDaGFpIGlzIHJ1bm5pbmcgaW4gc3VwcG9ydHMgcHJveGllcyBhbmRcbiAgICogaWYgdGhlIGB1c2VQcm94eWAgY29uZmlndXJhdGlvbiBzZXR0aW5nIGlzIGVuYWJsZWQuXG4gICAqIEJ5IGRlZmF1bHQsIGB0aGVuYCBhbmQgYGluc3BlY3RgIHdpbGwgbm90IHRocm93IGFuIGVycm9yIGlmIHRoZXkgZG8gbm90IGV4aXN0IG9uIHRoZVxuICAgKiBhc3NlcnRpb24gb2JqZWN0IGJlY2F1c2UgdGhlIGAuaW5zcGVjdGAgcHJvcGVydHkgaXMgcmVhZCBieSBgdXRpbC5pbnNwZWN0YCAoZm9yIGV4YW1wbGUsIHdoZW5cbiAgICogdXNpbmcgYGNvbnNvbGUubG9nYCBvbiB0aGUgYXNzZXJ0aW9uIG9iamVjdCkgYW5kIGAudGhlbmAgaXMgbmVjZXNzYXJ5IGZvciBwcm9taXNlIHR5cGUtY2hlY2tpbmcuXG4gICAqXG4gICAqICAgICAvLyBCeSBkZWZhdWx0IHRoZXNlIGtleXMgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgaWYgdGhleSBkbyBub3QgZXhpc3Qgb24gdGhlIGFzc2VydGlvbiBvYmplY3RcbiAgICogICAgIGNoYWkuY29uZmlnLnByb3h5RXhjbHVkZWRLZXlzID0gWyd0aGVuJywgJ2luc3BlY3QnXTtcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcHJveHlFeGNsdWRlZEtleXM6IFsndGhlbicsICdjYXRjaCcsICdpbnNwZWN0JywgJ3RvSlNPTiddXG59O1xuIiwiLy8gVGhpcyBpcyAoYWxtb3N0KSBkaXJlY3RseSBmcm9tIE5vZGUuanMgdXRpbHNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9ibG9iL2Y4YzMzNWQwY2FmNDdmMTZkMzE0MTNmODlhYTI4ZWRhMzg3OGUzYWEvbGliL3V0aWwuanNcblxudmFyIGdldE5hbWUgPSByZXF1aXJlKCdnZXQtZnVuYy1uYW1lJyk7XG52YXIgZ2V0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0UHJvcGVydGllcycpO1xudmFyIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRFbnVtZXJhYmxlUHJvcGVydGllcycpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3BlY3Q7XG5cbi8qKlxuICogIyMjIC5pbnNwZWN0KG9iaiwgW3Nob3dIaWRkZW5dLCBbZGVwdGhdLCBbY29sb3JzXSlcbiAqXG4gKiBFY2hvZXMgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyaWVzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dIaWRkZW4gRmxhZyB0aGF0IHNob3dzIGhpZGRlbiAobm90IGVudW1lcmFibGUpXG4gKiAgICBwcm9wZXJ0aWVzIG9mIG9iamVjdHMuIERlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGggRGVwdGggaW4gd2hpY2ggdG8gZGVzY2VuZCBpbiBvYmplY3QuIERlZmF1bHQgaXMgMi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sb3JzIEZsYWcgdG8gdHVybiBvbiBBTlNJIGVzY2FwZSBjb2RlcyB0byBjb2xvciB0aGVcbiAqICAgIG91dHB1dC4gRGVmYXVsdCBpcyBmYWxzZSAobm8gY29sb3JpbmcpLlxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgaW5zcGVjdFxuICovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycykge1xuICB2YXIgY3R4ID0ge1xuICAgIHNob3dIaWRkZW46IHNob3dIaWRkZW4sXG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyOyB9XG4gIH07XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyAyIDogZGVwdGgpKTtcbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBhIERPTSBlbGVtZW50LlxudmFyIGlzRE9NRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iamVjdCAmJlxuICAgICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICdub2RlVHlwZScgaW4gb2JqZWN0ICYmXG4gICAgICBvYmplY3Qubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIElmIHRoaXMgaXMgYSBET00gZWxlbWVudCwgdHJ5IHRvIGdldCB0aGUgb3V0ZXIgSFRNTC5cbiAgaWYgKGlzRE9NRWxlbWVudCh2YWx1ZSkpIHtcbiAgICBpZiAoJ291dGVySFRNTCcgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5vdXRlckhUTUw7XG4gICAgICAvLyBUaGlzIHZhbHVlIGRvZXMgbm90IGhhdmUgYW4gb3V0ZXJIVE1MIGF0dHJpYnV0ZSxcbiAgICAgIC8vICAgaXQgY291bGQgc3RpbGwgYmUgYW4gWE1MIGVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXR0ZW1wdCB0byBzZXJpYWxpemUgaXRcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChkb2N1bWVudC54bWxWZXJzaW9uKSB7XG4gICAgICAgICAgdmFyIHhtbFNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICAgICAgICAgIHJldHVybiB4bWxTZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGaXJlZm94IDExLSBkbyBub3Qgc3VwcG9ydCBvdXRlckhUTUxcbiAgICAgICAgICAvLyAgIEl0IGRvZXMsIGhvd2V2ZXIsIHN1cHBvcnQgaW5uZXJIVE1MXG4gICAgICAgICAgLy8gICBVc2UgdGhlIGZvbGxvd2luZyB0byByZW5kZXIgdGhlIGVsZW1lbnRcbiAgICAgICAgICB2YXIgbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAnXycpO1xuXG4gICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHZhbHVlLmNsb25lTm9kZShmYWxzZSkpO1xuICAgICAgICAgIHZhciBodG1sID0gY29udGFpbmVyLmlubmVySFRNTFxuICAgICAgICAgICAgLnJlcGxhY2UoJz48JywgJz4nICsgdmFsdWUuaW5uZXJIVE1MICsgJzwnKTtcbiAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGEgbm9uLW5hdGl2ZSBET00gaW1wbGVtZW50YXRpb24sXG4gICAgICAgIC8vICAgY29udGludWUgd2l0aCB0aGUgbm9ybWFsIGZsb3c6XG4gICAgICAgIC8vICAgcHJpbnRpbmcgdGhlIGVsZW1lbnQgYXMgaWYgaXQgaXMgYW4gb2JqZWN0LlxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIHZpc2libGVLZXlzID0gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXModmFsdWUpO1xuICB2YXIga2V5cyA9IGN0eC5zaG93SGlkZGVuID8gZ2V0UHJvcGVydGllcyh2YWx1ZSkgOiB2aXNpYmxlS2V5cztcblxuICB2YXIgbmFtZSwgbmFtZVN1ZmZpeDtcblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXQuXG4gIC8vIEluIElFLCBlcnJvcnMgaGF2ZSBhIHNpbmdsZSBgc3RhY2tgIHByb3BlcnR5LCBvciBpZiB0aGV5IGFyZSB2YW5pbGxhIGBFcnJvcmAsXG4gIC8vIGEgYHN0YWNrYCBwbHVzIGBkZXNjcmlwdGlvbmAgcHJvcGVydHk7IGlnbm9yZSB0aG9zZSBmb3IgY29uc2lzdGVuY3kuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCB8fCAoaXNFcnJvcih2YWx1ZSkgJiYgKFxuICAgICAgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdzdGFjaycpIHx8XG4gICAgICAoa2V5cy5sZW5ndGggPT09IDIgJiYga2V5c1swXSA9PT0gJ2Rlc2NyaXB0aW9uJyAmJiBrZXlzWzFdID09PSAnc3RhY2snKVxuICAgICApKSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5hbWUgPSBnZXROYW1lKHZhbHVlKTtcbiAgICAgIG5hbWVTdWZmaXggPSBuYW1lID8gJzogJyArIG5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWVTdWZmaXggKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnXG4gICAgLCBhcnJheSA9IGZhbHNlXG4gICAgLCB0eXBlZEFycmF5ID0gZmFsc2VcbiAgICAsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgaWYgKGlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICB0eXBlZEFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbmFtZSA9IGdldE5hbWUodmFsdWUpO1xuICAgIG5hbWVTdWZmaXggPSBuYW1lID8gJzogJyArIG5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbmFtZVN1ZmZpeCArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIGlmICh0eXBlZEFycmF5KSB7XG4gICAgcmV0dXJuIGZvcm1hdFR5cGVkQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiAoMS92YWx1ZSkgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoJy0wJywgJ251bWJlcicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKHZhbHVlLnRvU3RyaW5nKCksICdzeW1ib2wnKTtcbiAgfVxuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VHlwZWRBcnJheSh2YWx1ZSkge1xuICB2YXIgc3RyID0gJ1sgJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPj0gY29uZmlnLnRydW5jYXRlVGhyZXNob2xkIC0gNykge1xuICAgICAgc3RyICs9ICcuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN0ciArPSB2YWx1ZVtpXSArICcsICc7XG4gIH1cbiAgc3RyICs9ICcgXSc7XG5cbiAgLy8gUmVtb3ZpbmcgdHJhaWxpbmcgYCwgYCBpZiB0aGUgYXJyYXkgd2FzIG5vdCB0cnVuY2F0ZWRcbiAgaWYgKHN0ci5pbmRleE9mKCcsICBdJykgIT09IC0xKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoJywgIF0nLCAnIF0nKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWU7XG4gIHZhciBwcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSk7XG4gIHZhciBzdHI7XG5cbiAgaWYgKHByb3BEZXNjcmlwdG9yKSB7XG4gICAgaWYgKHByb3BEZXNjcmlwdG9yLmdldCkge1xuICAgICAgaWYgKHByb3BEZXNjcmlwdG9yLnNldCkge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wRGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZpc2libGVLZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YodmFsdWVba2V5XSkgPCAwKSB7XG4gICAgICBpZiAocmVjdXJzZVRpbWVzID09PSBudWxsKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgdmFsdWVba2V5XSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlW2tleV0sIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkoYXIpIHtcbiAgLy8gVW5mb3J0dW5hdGVseSB0aGVyZSdzIG5vIHdheSB0byBjaGVjayBpZiBhbiBvYmplY3QgaXMgYSBUeXBlZEFycmF5XG4gIC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgaXQncyBvbmUgb2YgdGhlc2UgdHlwZXNcbiAgcmV0dXJuICh0eXBlb2YgYXIgPT09ICdvYmplY3QnICYmIC9cXHcrQXJyYXldJC8udGVzdChvYmplY3RUb1N0cmluZyhhcikpKTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcikgfHxcbiAgICAgICAgICh0eXBlb2YgYXIgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGFyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiB0eXBlb2YgcmUgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiB0eXBlb2YgZCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXSc7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8qIVxuICogQ2hhaSAtIGZsYWcgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0Jyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qKlxuICogIyMjIC5vYmpEaXNwbGF5KG9iamVjdClcbiAqXG4gKiBEZXRlcm1pbmVzIGlmIGFuIG9iamVjdCBvciBhbiBhcnJheSBtYXRjaGVzXG4gKiBjcml0ZXJpYSB0byBiZSBpbnNwZWN0ZWQgaW4tbGluZSBmb3IgZXJyb3JcbiAqIG1lc3NhZ2VzIG9yIHNob3VsZCBiZSB0cnVuY2F0ZWQuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gamF2YXNjcmlwdCBvYmplY3QgdG8gaW5zcGVjdFxuICogQG5hbWUgb2JqRGlzcGxheVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG9iakRpc3BsYXkob2JqKSB7XG4gIHZhciBzdHIgPSBpbnNwZWN0KG9iailcbiAgICAsIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcblxuICBpZiAoY29uZmlnLnRydW5jYXRlVGhyZXNob2xkICYmIHN0ci5sZW5ndGggPj0gY29uZmlnLnRydW5jYXRlVGhyZXNob2xkKSB7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgIHJldHVybiAhb2JqLm5hbWUgfHwgb2JqLm5hbWUgPT09ICcnXG4gICAgICAgID8gJ1tGdW5jdGlvbl0nXG4gICAgICAgIDogJ1tGdW5jdGlvbjogJyArIG9iai5uYW1lICsgJ10nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuICdbIEFycmF5KCcgKyBvYmoubGVuZ3RoICsgJykgXSc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgICAgICwga3N0ciA9IGtleXMubGVuZ3RoID4gMlxuICAgICAgICAgID8ga2V5cy5zcGxpY2UoMCwgMikuam9pbignLCAnKSArICcsIC4uLidcbiAgICAgICAgICA6IGtleXMuam9pbignLCAnKTtcbiAgICAgIHJldHVybiAneyBPYmplY3QgKCcgKyBrc3RyICsgJykgfSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBtZXNzYWdlIGNvbXBvc2l0aW9uIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpXG4gICwgZ2V0QWN0dWFsID0gcmVxdWlyZSgnLi9nZXRBY3R1YWwnKVxuICAsIG9iakRpc3BsYXkgPSByZXF1aXJlKCcuL29iakRpc3BsYXknKTtcblxuLyoqXG4gKiAjIyMgLmdldE1lc3NhZ2Uob2JqZWN0LCBtZXNzYWdlLCBuZWdhdGVNZXNzYWdlKVxuICpcbiAqIENvbnN0cnVjdCB0aGUgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiBmbGFnc1xuICogYW5kIHRlbXBsYXRlIHRhZ3MuIFRlbXBsYXRlIHRhZ3Mgd2lsbCByZXR1cm5cbiAqIGEgc3RyaW5naWZpZWQgaW5zcGVjdGlvbiBvZiB0aGUgb2JqZWN0IHJlZmVyZW5jZWQuXG4gKlxuICogTWVzc2FnZSB0ZW1wbGF0ZSB0YWdzOlxuICogLSBgI3t0aGlzfWAgY3VycmVudCBhc3NlcnRlZCBvYmplY3RcbiAqIC0gYCN7YWN0fWAgYWN0dWFsIHZhbHVlXG4gKiAtIGAje2V4cH1gIGV4cGVjdGVkIHZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRNZXNzYWdlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0TWVzc2FnZShvYmosIGFyZ3MpIHtcbiAgdmFyIG5lZ2F0ZSA9IGZsYWcob2JqLCAnbmVnYXRlJylcbiAgICAsIHZhbCA9IGZsYWcob2JqLCAnb2JqZWN0JylcbiAgICAsIGV4cGVjdGVkID0gYXJnc1szXVxuICAgICwgYWN0dWFsID0gZ2V0QWN0dWFsKG9iaiwgYXJncylcbiAgICAsIG1zZyA9IG5lZ2F0ZSA/IGFyZ3NbMl0gOiBhcmdzWzFdXG4gICAgLCBmbGFnTXNnID0gZmxhZyhvYmosICdtZXNzYWdlJyk7XG5cbiAgaWYodHlwZW9mIG1zZyA9PT0gXCJmdW5jdGlvblwiKSBtc2cgPSBtc2coKTtcbiAgbXNnID0gbXNnIHx8ICcnO1xuICBtc2cgPSBtc2dcbiAgICAucmVwbGFjZSgvI1xce3RoaXNcXH0vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqRGlzcGxheSh2YWwpOyB9KVxuICAgIC5yZXBsYWNlKC8jXFx7YWN0XFx9L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iakRpc3BsYXkoYWN0dWFsKTsgfSlcbiAgICAucmVwbGFjZSgvI1xce2V4cFxcfS9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmpEaXNwbGF5KGV4cGVjdGVkKTsgfSk7XG5cbiAgcmV0dXJuIGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyArIG1zZyA6IG1zZztcbn07XG4iLCIvKiFcbiAqIENoYWkgLSB0cmFuc2ZlckZsYWdzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG9iamVjdCwgaW5jbHVkZUFsbCA9IHRydWUpXG4gKlxuICogVHJhbnNmZXIgYWxsIHRoZSBmbGFncyBmb3IgYGFzc2VydGlvbmAgdG8gYG9iamVjdGAuIElmXG4gKiBgaW5jbHVkZUFsbGAgaXMgc2V0IHRvIGBmYWxzZWAsIHRoZW4gdGhlIGJhc2UgQ2hhaVxuICogYXNzZXJ0aW9uIGZsYWdzIChuYW1lbHkgYG9iamVjdGAsIGBzc2ZpYCwgYGxvY2tTc2ZpYCxcbiAqIGFuZCBgbWVzc2FnZWApIHdpbGwgbm90IGJlIHRyYW5zZmVycmVkLlxuICpcbiAqXG4gKiAgICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBBc3NlcnRpb24oKTtcbiAqICAgICB1dGlscy50cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgbmV3QXNzZXJ0aW9uKTtcbiAqXG4gKiAgICAgdmFyIGFub3RoZXJBc3NlcnRpb24gPSBuZXcgQXNzZXJ0aW9uKG15T2JqKTtcbiAqICAgICB1dGlscy50cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgYW5vdGhlckFzc2VydGlvbiwgZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7QXNzZXJ0aW9ufSBhc3NlcnRpb24gdGhlIGFzc2VydGlvbiB0byB0cmFuc2ZlciB0aGUgZmxhZ3MgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0aGUgb2JqZWN0IHRvIHRyYW5zZmVyIHRoZSBmbGFncyB0bzsgdXN1YWxseSBhIG5ldyBhc3NlcnRpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZUFsbFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgdHJhbnNmZXJGbGFnc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgb2JqZWN0LCBpbmNsdWRlQWxsKSB7XG4gIHZhciBmbGFncyA9IGFzc2VydGlvbi5fX2ZsYWdzIHx8IChhc3NlcnRpb24uX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gIGlmICghb2JqZWN0Ll9fZmxhZ3MpIHtcbiAgICBvYmplY3QuX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBpbmNsdWRlQWxsID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IGluY2x1ZGVBbGwgOiB0cnVlO1xuXG4gIGZvciAodmFyIGZsYWcgaW4gZmxhZ3MpIHtcbiAgICBpZiAoaW5jbHVkZUFsbCB8fFxuICAgICAgICAoZmxhZyAhPT0gJ29iamVjdCcgJiYgZmxhZyAhPT0gJ3NzZmknICYmIGZsYWcgIT09ICdsb2NrU3NmaScgJiYgZmxhZyAhPSAnbWVzc2FnZScpKSB7XG4gICAgICBvYmplY3QuX19mbGFnc1tmbGFnXSA9IGZsYWdzW2ZsYWddO1xuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbHMgU3ltYm9sOiBmYWxzZSwgVWludDhBcnJheTogZmFsc2UsIFdlYWtNYXA6IGZhbHNlICovXG4vKiFcbiAqIGRlZXAtZXFsXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcbmZ1bmN0aW9uIEZha2VNYXAoKSB7XG4gIHRoaXMuX2tleSA9ICdjaGFpL2RlZXAtZXFsX18nICsgTWF0aC5yYW5kb20oKSArIERhdGUubm93KCk7XG59XG5cbkZha2VNYXAucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldE1hcChrZXkpIHtcbiAgICByZXR1cm4ga2V5W3RoaXMuX2tleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0TWFwKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLl9rZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG59O1xuXG52YXIgTWVtb2l6ZU1hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IEZha2VNYXA7XG4vKiFcbiAqIENoZWNrIHRvIHNlZSBpZiB0aGUgTWVtb2l6ZU1hcCBoYXMgcmVjb3JkZWQgYSByZXN1bHQgb2YgdGhlIHR3byBvcGVyYW5kc1xuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNZW1vaXplTWFwfSBtZW1vaXplTWFwXG4gKiBAcmV0dXJucyB7Qm9vbGVhbnxudWxsfSByZXN1bHRcbiovXG5mdW5jdGlvbiBtZW1vaXplQ29tcGFyZShsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG1lbW9pemVNYXApIHtcbiAgLy8gVGVjaG5pY2FsbHksIFdlYWtNYXAga2V5cyBjYW4gKm9ubHkqIGJlIG9iamVjdHMsIG5vdCBwcmltaXRpdmVzLlxuICBpZiAoIW1lbW9pemVNYXAgfHwgaXNQcmltaXRpdmUobGVmdEhhbmRPcGVyYW5kKSB8fCBpc1ByaW1pdGl2ZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBsZWZ0SGFuZE1hcCA9IG1lbW9pemVNYXAuZ2V0KGxlZnRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZE1hcCkge1xuICAgIHZhciByZXN1bHQgPSBsZWZ0SGFuZE1hcC5nZXQocmlnaHRIYW5kT3BlcmFuZCk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qIVxuICogU2V0IHRoZSByZXN1bHQgb2YgdGhlIGVxdWFsaXR5IGludG8gdGhlIE1lbW9pemVNYXBcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWVtb2l6ZU1hcH0gbWVtb2l6ZU1hcFxuICogQHBhcmFtIHtCb29sZWFufSByZXN1bHRcbiovXG5mdW5jdGlvbiBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbWVtb2l6ZU1hcCwgcmVzdWx0KSB7XG4gIC8vIFRlY2huaWNhbGx5LCBXZWFrTWFwIGtleXMgY2FuICpvbmx5KiBiZSBvYmplY3RzLCBub3QgcHJpbWl0aXZlcy5cbiAgaWYgKCFtZW1vaXplTWFwIHx8IGlzUHJpbWl0aXZlKGxlZnRIYW5kT3BlcmFuZCkgfHwgaXNQcmltaXRpdmUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGxlZnRIYW5kTWFwID0gbWVtb2l6ZU1hcC5nZXQobGVmdEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kTWFwKSB7XG4gICAgbGVmdEhhbmRNYXAuc2V0KHJpZ2h0SGFuZE9wZXJhbmQsIHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgbGVmdEhhbmRNYXAgPSBuZXcgTWVtb2l6ZU1hcCgpO1xuICAgIGxlZnRIYW5kTWFwLnNldChyaWdodEhhbmRPcGVyYW5kLCByZXN1bHQpO1xuICAgIG1lbW9pemVNYXAuc2V0KGxlZnRIYW5kT3BlcmFuZCwgbGVmdEhhbmRNYXApO1xuICB9XG59XG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBFcXVhbDtcbm1vZHVsZS5leHBvcnRzLk1lbW9pemVNYXAgPSBNZW1vaXplTWFwO1xuXG4vKipcbiAqIEFzc2VydCBkZWVwbHkgbmVzdGVkIHNhbWVWYWx1ZSBlcXVhbGl0eSBiZXR3ZWVuIHR3byBvYmplY3RzIG9mIGFueSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAob3B0aW9uYWwpIEFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuY29tcGFyYXRvcl0gKG9wdGlvbmFsKSBPdmVycmlkZSBkZWZhdWx0IGFsZ29yaXRobSwgZGV0ZXJtaW5pbmcgY3VzdG9tIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWVtb2l6ZV0gKG9wdGlvbmFsKSBQcm92aWRlIGEgY3VzdG9tIG1lbW9pemF0aW9uIG9iamVjdCB3aGljaCB3aWxsIGNhY2hlIHRoZSByZXN1bHRzIG9mXG4gICAgY29tcGxleCBvYmplY3RzIGZvciBhIHNwZWVkIGJvb3N0LiBCeSBwYXNzaW5nIGBmYWxzZWAgeW91IGNhbiBkaXNhYmxlIG1lbW9pemF0aW9uLCBidXQgdGhpcyB3aWxsIGNhdXNlIGNpcmN1bGFyXG4gICAgcmVmZXJlbmNlcyB0byBibG93IHRoZSBzdGFjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVxdWFsIG1hdGNoXG4gKi9cbmZ1bmN0aW9uIGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgLy8gSWYgd2UgaGF2ZSBhIGNvbXBhcmF0b3IsIHdlIGNhbid0IGFzc3VtZSBhbnl0aGluZzsgc28gYmFpbCB0byBpdHMgY2hlY2sgZmlyc3QuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29tcGFyYXRvcikge1xuICAgIHJldHVybiBleHRlbnNpdmVEZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBzaW1wbGVSZXN1bHQgPSBzaW1wbGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAoc2ltcGxlUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNpbXBsZVJlc3VsdDtcbiAgfVxuXG4gIC8vIERlZXBlciBjb21wYXJpc29ucyBhcmUgcHVzaGVkIHRocm91Z2ggdG8gYSBsYXJnZXIgZnVuY3Rpb25cbiAgcmV0dXJuIGV4dGVuc2l2ZURlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIE1hbnkgY29tcGFyaXNvbnMgY2FuIGJlIGNhbmNlbGVkIG91dCBlYXJseSB2aWEgc2ltcGxlIGVxdWFsaXR5IG9yIHByaW1pdGl2ZSBjaGVja3MuXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEByZXR1cm4ge0Jvb2xlYW58bnVsbH0gZXF1YWwgbWF0Y2hcbiAqL1xuZnVuY3Rpb24gc2ltcGxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKSB7XG4gIC8vIEVxdWFsIHJlZmVyZW5jZXMgKGV4Y2VwdCBmb3IgTnVtYmVycykgY2FuIGJlIHJldHVybmVkIGVhcmx5XG4gIGlmIChsZWZ0SGFuZE9wZXJhbmQgPT09IHJpZ2h0SGFuZE9wZXJhbmQpIHtcbiAgICAvLyBIYW5kbGUgKy0wIGNhc2VzXG4gICAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZCAhPT0gMCB8fCAxIC8gbGVmdEhhbmRPcGVyYW5kID09PSAxIC8gcmlnaHRIYW5kT3BlcmFuZDtcbiAgfVxuXG4gIC8vIGhhbmRsZSBOYU4gY2FzZXNcbiAgaWYgKFxuICAgIGxlZnRIYW5kT3BlcmFuZCAhPT0gbGVmdEhhbmRPcGVyYW5kICYmIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmlnaHRIYW5kT3BlcmFuZCAhPT0gcmlnaHRIYW5kT3BlcmFuZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEFueXRoaW5nIHRoYXQgaXMgbm90IGFuICdvYmplY3QnLCBpLmUuIHN5bWJvbHMsIGZ1bmN0aW9ucywgYm9vbGVhbnMsIG51bWJlcnMsXG4gIC8vIHN0cmluZ3MsIGFuZCB1bmRlZmluZWQsIGNhbiBiZSBjb21wYXJlZCBieSByZWZlcmVuY2UuXG4gIGlmIChpc1ByaW1pdGl2ZShsZWZ0SGFuZE9wZXJhbmQpIHx8IGlzUHJpbWl0aXZlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgLy8gRWFzeSBvdXQgYi9jIGl0IHdvdWxkIGhhdmUgcGFzc2VkIHRoZSBmaXJzdCBlcXVhbGl0eSBjaGVja1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyohXG4gKiBUaGUgbWFpbiBsb2dpYyBvZiB0aGUgYGRlZXBFcXVhbGAgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChvcHRpb25hbCkgQWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jb21wYXJhdG9yXSAob3B0aW9uYWwpIE92ZXJyaWRlIGRlZmF1bHQgYWxnb3JpdGhtLCBkZXRlcm1pbmluZyBjdXN0b20gZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tZW1vaXplXSAob3B0aW9uYWwpIFByb3ZpZGUgYSBjdXN0b20gbWVtb2l6YXRpb24gb2JqZWN0IHdoaWNoIHdpbGwgY2FjaGUgdGhlIHJlc3VsdHMgb2ZcbiAgICBjb21wbGV4IG9iamVjdHMgZm9yIGEgc3BlZWQgYm9vc3QuIEJ5IHBhc3NpbmcgYGZhbHNlYCB5b3UgY2FuIGRpc2FibGUgbWVtb2l6YXRpb24sIGJ1dCB0aGlzIHdpbGwgY2F1c2UgY2lyY3VsYXJcbiAgICByZWZlcmVuY2VzIHRvIGJsb3cgdGhlIHN0YWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiovXG5mdW5jdGlvbiBleHRlbnNpdmVEZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLm1lbW9pemUgPSBvcHRpb25zLm1lbW9pemUgPT09IGZhbHNlID8gZmFsc2UgOiBvcHRpb25zLm1lbW9pemUgfHwgbmV3IE1lbW9pemVNYXAoKTtcbiAgdmFyIGNvbXBhcmF0b3IgPSBvcHRpb25zICYmIG9wdGlvbnMuY29tcGFyYXRvcjtcblxuICAvLyBDaGVjayBpZiBhIG1lbW9pemVkIHJlc3VsdCBleGlzdHMuXG4gIHZhciBtZW1vaXplUmVzdWx0TGVmdCA9IG1lbW9pemVDb21wYXJlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplKTtcbiAgaWYgKG1lbW9pemVSZXN1bHRMZWZ0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG1lbW9pemVSZXN1bHRMZWZ0O1xuICB9XG4gIHZhciBtZW1vaXplUmVzdWx0UmlnaHQgPSBtZW1vaXplQ29tcGFyZShyaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSk7XG4gIGlmIChtZW1vaXplUmVzdWx0UmlnaHQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbWVtb2l6ZVJlc3VsdFJpZ2h0O1xuICB9XG5cbiAgLy8gSWYgYSBjb21wYXJhdG9yIGlzIHByZXNlbnQsIHVzZSBpdC5cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgY29tcGFyYXRvclJlc3VsdCA9IGNvbXBhcmF0b3IobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgICAvLyBDb21wYXJhdG9ycyBtYXkgcmV0dXJuIG51bGwsIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBnbyBiYWNrIHRvIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgaWYgKGNvbXBhcmF0b3JSZXN1bHQgPT09IGZhbHNlIHx8IGNvbXBhcmF0b3JSZXN1bHQgPT09IHRydWUpIHtcbiAgICAgIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIGNvbXBhcmF0b3JSZXN1bHQpO1xuICAgICAgcmV0dXJuIGNvbXBhcmF0b3JSZXN1bHQ7XG4gICAgfVxuICAgIC8vIFRvIGFsbG93IGNvbXBhcmF0b3JzIHRvIG92ZXJyaWRlICphbnkqIGJlaGF2aW9yLCB3ZSByYW4gdGhlbSBmaXJzdC4gU2luY2UgaXQgZGlkbid0IGRlY2lkZVxuICAgIC8vIHdoYXQgdG8gZG8sIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRvIHJldHVybiB0aGUgYmFzaWMgdGVzdHMgZmlyc3QgYmVmb3JlIHdlIG1vdmUgb24uXG4gICAgdmFyIHNpbXBsZVJlc3VsdCA9IHNpbXBsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gICAgaWYgKHNpbXBsZVJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgLy8gRG9uJ3QgbWVtb2l6ZSB0aGlzLCBpdCB0YWtlcyBsb25nZXIgdG8gc2V0L3JldHJpZXZlIHRoYW4gdG8ganVzdCBjb21wYXJlLlxuICAgICAgcmV0dXJuIHNpbXBsZVJlc3VsdDtcbiAgICB9XG4gIH1cblxuICB2YXIgbGVmdEhhbmRUeXBlID0gdHlwZShsZWZ0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRUeXBlICE9PSB0eXBlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgZmFsc2UpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlbXBvcmFyaWx5IHNldCB0aGUgb3BlcmFuZHMgaW4gdGhlIG1lbW9pemUgb2JqZWN0IHRvIHByZXZlbnQgYmxvd2luZyB0aGUgc3RhY2tcbiAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgdHJ1ZSk7XG5cbiAgdmFyIHJlc3VsdCA9IGV4dGVuc2l2ZURlZXBFcXVhbEJ5VHlwZShsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kVHlwZSwgb3B0aW9ucyk7XG4gIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGV4dGVuc2l2ZURlZXBFcXVhbEJ5VHlwZShsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kVHlwZSwgb3B0aW9ucykge1xuICBzd2l0Y2ggKGxlZnRIYW5kVHlwZSkge1xuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICBjYXNlICdEYXRlJzpcbiAgICAgIC8vIElmIHRoZXNlIHR5cGVzIGFyZSB0aGVpciBpbnN0YW5jZSB0eXBlcyAoZS5nLiBgbmV3IE51bWJlcmApIHRoZW4gcmUtZGVlcEVxdWFsIGFnYWluc3QgdGhlaXIgdmFsdWVzXG4gICAgICByZXR1cm4gZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZC52YWx1ZU9mKCksIHJpZ2h0SGFuZE9wZXJhbmQudmFsdWVPZigpKTtcbiAgICBjYXNlICdQcm9taXNlJzpcbiAgICBjYXNlICdTeW1ib2wnOlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdXZWFrTWFwJzpcbiAgICBjYXNlICdXZWFrU2V0JzpcbiAgICBjYXNlICdFcnJvcic6XG4gICAgICByZXR1cm4gbGVmdEhhbmRPcGVyYW5kID09PSByaWdodEhhbmRPcGVyYW5kO1xuICAgIGNhc2UgJ0FyZ3VtZW50cyc6XG4gICAgY2FzZSAnSW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6XG4gICAgY2FzZSAnSW50MTZBcnJheSc6XG4gICAgY2FzZSAnVWludDE2QXJyYXknOlxuICAgIGNhc2UgJ0ludDMyQXJyYXknOlxuICAgIGNhc2UgJ1VpbnQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOlxuICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6XG4gICAgY2FzZSAnQXJyYXknOlxuICAgICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdSZWdFeHAnOlxuICAgICAgcmV0dXJuIHJlZ2V4cEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gICAgY2FzZSAnR2VuZXJhdG9yJzpcbiAgICAgIHJldHVybiBnZW5lcmF0b3JFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ0RhdGFWaWV3JzpcbiAgICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKG5ldyBVaW50OEFycmF5KGxlZnRIYW5kT3BlcmFuZC5idWZmZXIpLCBuZXcgVWludDhBcnJheShyaWdodEhhbmRPcGVyYW5kLmJ1ZmZlciksIG9wdGlvbnMpO1xuICAgIGNhc2UgJ0FycmF5QnVmZmVyJzpcbiAgICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKG5ldyBVaW50OEFycmF5KGxlZnRIYW5kT3BlcmFuZCksIG5ldyBVaW50OEFycmF5KHJpZ2h0SGFuZE9wZXJhbmQpLCBvcHRpb25zKTtcbiAgICBjYXNlICdTZXQnOlxuICAgICAgcmV0dXJuIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ01hcCc6XG4gICAgICByZXR1cm4gZW50cmllc0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBvYmplY3RFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgZXF1YWxpdHkuXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtSZWdFeHB9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIHJlZ2V4cEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCkge1xuICByZXR1cm4gbGVmdEhhbmRPcGVyYW5kLnRvU3RyaW5nKCkgPT09IHJpZ2h0SGFuZE9wZXJhbmQudG9TdHJpbmcoKTtcbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byBTZXRzL01hcHMgZm9yIGVxdWFsaXR5LiBGYXN0ZXIgdGhhbiBvdGhlciBlcXVhbGl0eSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtTZXR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtTZXR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZW50cmllc0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICAvLyBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBTZXQjZW50cmllcyBvciBTZXQjQEBpdGVyYXRvciwgc28gd2UgbmVlZCBtYW51YWxseSBwb3B1bGF0ZSB1c2luZyBTZXQjZm9yRWFjaFxuICBpZiAobGVmdEhhbmRPcGVyYW5kLnNpemUgIT09IHJpZ2h0SGFuZE9wZXJhbmQuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobGVmdEhhbmRPcGVyYW5kLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgbGVmdEhhbmRJdGVtcyA9IFtdO1xuICB2YXIgcmlnaHRIYW5kSXRlbXMgPSBbXTtcbiAgbGVmdEhhbmRPcGVyYW5kLmZvckVhY2goZnVuY3Rpb24gZ2F0aGVyRW50cmllcyhrZXksIHZhbHVlKSB7XG4gICAgbGVmdEhhbmRJdGVtcy5wdXNoKFsga2V5LCB2YWx1ZSBdKTtcbiAgfSk7XG4gIHJpZ2h0SGFuZE9wZXJhbmQuZm9yRWFjaChmdW5jdGlvbiBnYXRoZXJFbnRyaWVzKGtleSwgdmFsdWUpIHtcbiAgICByaWdodEhhbmRJdGVtcy5wdXNoKFsga2V5LCB2YWx1ZSBdKTtcbiAgfSk7XG4gIHJldHVybiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kSXRlbXMuc29ydCgpLCByaWdodEhhbmRJdGVtcy5zb3J0KCksIG9wdGlvbnMpO1xufVxuXG4vKiFcbiAqIFNpbXBsZSBlcXVhbGl0eSBmb3IgZmxhdCBpdGVyYWJsZSBvYmplY3RzIHN1Y2ggYXMgQXJyYXlzLCBUeXBlZEFycmF5cyBvciBOb2RlLmpzIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtJdGVyYWJsZX0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHZhciBsZW5ndGggPSBsZWZ0SGFuZE9wZXJhbmQubGVuZ3RoO1xuICBpZiAobGVuZ3RoICE9PSByaWdodEhhbmRPcGVyYW5kLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTE7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmRbaW5kZXhdLCByaWdodEhhbmRPcGVyYW5kW2luZGV4XSwgb3B0aW9ucykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiFcbiAqIFNpbXBsZSBlcXVhbGl0eSBmb3IgZ2VuZXJhdG9yIG9iamVjdHMgc3VjaCBhcyB0aG9zZSByZXR1cm5lZCBieSBnZW5lcmF0b3IgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtJdGVyYWJsZX0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBnZW5lcmF0b3JFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwoZ2V0R2VuZXJhdG9yRW50cmllcyhsZWZ0SGFuZE9wZXJhbmQpLCBnZXRHZW5lcmF0b3JFbnRyaWVzKHJpZ2h0SGFuZE9wZXJhbmQpLCBvcHRpb25zKTtcbn1cblxuLyohXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgYW4gQEBpdGVyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBoYXMgYW4gQEBpdGVyYXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gaGFzSXRlcmF0b3JGdW5jdGlvbih0YXJnZXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB0YXJnZXRbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyohXG4gKiBHZXRzIGFsbCBpdGVyYXRvciBlbnRyaWVzIGZyb20gdGhlIGdpdmVuIE9iamVjdC4gSWYgdGhlIE9iamVjdCBoYXMgbm8gQEBpdGVyYXRvciBmdW5jdGlvbiwgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cbiAqIFRoaXMgd2lsbCBjb25zdW1lIHRoZSBpdGVyYXRvciAtIHdoaWNoIGNvdWxkIGhhdmUgc2lkZSBlZmZlY3RzIGRlcGVuZGluZyBvbiB0aGUgQEBpdGVyYXRvciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIGVudHJpZXMgZnJvbSB0aGUgQEBpdGVyYXRvciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckVudHJpZXModGFyZ2V0KSB7XG4gIGlmIChoYXNJdGVyYXRvckZ1bmN0aW9uKHRhcmdldCkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdldEdlbmVyYXRvckVudHJpZXModGFyZ2V0W1N5bWJvbC5pdGVyYXRvcl0oKSk7XG4gICAgfSBjYXRjaCAoaXRlcmF0b3JFcnJvcikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW107XG59XG5cbi8qIVxuICogR2V0cyBhbGwgZW50cmllcyBmcm9tIGEgR2VuZXJhdG9yLiBUaGlzIHdpbGwgY29uc3VtZSB0aGUgZ2VuZXJhdG9yIC0gd2hpY2ggY291bGQgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gKlxuICogQHBhcmFtIHtHZW5lcmF0b3J9IHRhcmdldFxuICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBlbnRyaWVzIGZyb20gdGhlIEdlbmVyYXRvci5cbiAqL1xuZnVuY3Rpb24gZ2V0R2VuZXJhdG9yRW50cmllcyhnZW5lcmF0b3IpIHtcbiAgdmFyIGdlbmVyYXRvclJlc3VsdCA9IGdlbmVyYXRvci5uZXh0KCk7XG4gIHZhciBhY2N1bXVsYXRvciA9IFsgZ2VuZXJhdG9yUmVzdWx0LnZhbHVlIF07XG4gIHdoaWxlIChnZW5lcmF0b3JSZXN1bHQuZG9uZSA9PT0gZmFsc2UpIHtcbiAgICBnZW5lcmF0b3JSZXN1bHQgPSBnZW5lcmF0b3IubmV4dCgpO1xuICAgIGFjY3VtdWxhdG9yLnB1c2goZ2VuZXJhdG9yUmVzdWx0LnZhbHVlKTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qIVxuICogR2V0cyBhbGwgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBrZXlzIGZyb20gYSB0YXJnZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIGtleXMgZnJvbSB0aGUgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlS2V5cyh0YXJnZXQpIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG4vKiFcbiAqIERldGVybWluZXMgaWYgdHdvIG9iamVjdHMgaGF2ZSBtYXRjaGluZyB2YWx1ZXMsIGdpdmVuIGEgc2V0IG9mIGtleXMuIERlZmVycyB0byBkZWVwRXF1YWwgZm9yIHRoZSBlcXVhbGl0eSBjaGVjayBvZlxuICogZWFjaCBrZXkuIElmIGFueSB2YWx1ZSBvZiB0aGUgZ2l2ZW4ga2V5IGlzIG5vdCBlcXVhbCwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGZhbHNlIChlYXJseSkuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBrZXlzIEFuIGFycmF5IG9mIGtleXMgdG8gY29tcGFyZSB0aGUgdmFsdWVzIG9mIGxlZnRIYW5kT3BlcmFuZCBhbmQgcmlnaHRIYW5kT3BlcmFuZCBhZ2FpbnN0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5mdW5jdGlvbiBrZXlzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZFtrZXlzW2ldXSwgcmlnaHRIYW5kT3BlcmFuZFtrZXlzW2ldXSwgb3B0aW9ucykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiFcbiAqIFJlY3Vyc2l2ZWx5IGNoZWNrIHRoZSBlcXVhbGl0eSBvZiB0d28gT2JqZWN0cy4gT25jZSBiYXNpYyBzYW1lbmVzcyBoYXMgYmVlbiBlc3RhYmxpc2hlZCBpdCB3aWxsIGRlZmVyIHRvIGBkZWVwRXF1YWxgXG4gKiBmb3IgZWFjaCBlbnVtZXJhYmxlIGtleSBpbiB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBvYmplY3RFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlZnRIYW5kS2V5cyA9IGdldEVudW1lcmFibGVLZXlzKGxlZnRIYW5kT3BlcmFuZCk7XG4gIHZhciByaWdodEhhbmRLZXlzID0gZ2V0RW51bWVyYWJsZUtleXMocmlnaHRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZEtleXMubGVuZ3RoICYmIGxlZnRIYW5kS2V5cy5sZW5ndGggPT09IHJpZ2h0SGFuZEtleXMubGVuZ3RoKSB7XG4gICAgbGVmdEhhbmRLZXlzLnNvcnQoKTtcbiAgICByaWdodEhhbmRLZXlzLnNvcnQoKTtcbiAgICBpZiAoaXRlcmFibGVFcXVhbChsZWZ0SGFuZEtleXMsIHJpZ2h0SGFuZEtleXMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5c0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRLZXlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBsZWZ0SGFuZEVudHJpZXMgPSBnZXRJdGVyYXRvckVudHJpZXMobGVmdEhhbmRPcGVyYW5kKTtcbiAgdmFyIHJpZ2h0SGFuZEVudHJpZXMgPSBnZXRJdGVyYXRvckVudHJpZXMocmlnaHRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZEVudHJpZXMubGVuZ3RoICYmIGxlZnRIYW5kRW50cmllcy5sZW5ndGggPT09IHJpZ2h0SGFuZEVudHJpZXMubGVuZ3RoKSB7XG4gICAgbGVmdEhhbmRFbnRyaWVzLnNvcnQoKTtcbiAgICByaWdodEhhbmRFbnRyaWVzLnNvcnQoKTtcbiAgICByZXR1cm4gaXRlcmFibGVFcXVhbChsZWZ0SGFuZEVudHJpZXMsIHJpZ2h0SGFuZEVudHJpZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGxlZnRIYW5kS2V5cy5sZW5ndGggPT09IDAgJiZcbiAgICAgIGxlZnRIYW5kRW50cmllcy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHJpZ2h0SGFuZEtleXMubGVuZ3RoID09PSAwICYmXG4gICAgICByaWdodEhhbmRFbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiFcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSBwcmltaXRpdmUuXG4gKlxuICogVGhpcyBpbnRlbnRpb25hbGx5IHJldHVybnMgdHJ1ZSBmb3IgYWxsIG9iamVjdHMgdGhhdCBjYW4gYmUgY29tcGFyZWQgYnkgcmVmZXJlbmNlLFxuICogaW5jbHVkaW5nIGZ1bmN0aW9ucyBhbmQgc3ltYm9scy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnO1xufVxuIiwidmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKiFcbiAqIENoYWkgLSBpc1Byb3h5RW5hYmxlZCBoZWxwZXJcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuaXNQcm94eUVuYWJsZWQoKVxuICpcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBDaGFpJ3MgcHJveHkgcHJvdGVjdGlvbiBmZWF0dXJlIGlzIGVuYWJsZWQuIElmXG4gKiBwcm94aWVzIGFyZSB1bnN1cHBvcnRlZCBvciBkaXNhYmxlZCB2aWEgdGhlIHVzZXIncyBDaGFpIGNvbmZpZywgdGhlbiByZXR1cm5cbiAqIGZhbHNlLiBPdGhlcndpc2UsIHJldHVybiB0cnVlLlxuICpcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGlzUHJveHlFbmFibGVkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1Byb3h5RW5hYmxlZCgpIHtcbiAgcmV0dXJuIGNvbmZpZy51c2VQcm94eSAmJlxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gYWRkUHJvcGVydHkgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBpc1Byb3h5RW5hYmxlZCA9IHJlcXVpcmUoJy4vaXNQcm94eUVuYWJsZWQnKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qKlxuICogIyMjIC5hZGRQcm9wZXJ0eShjdHgsIG5hbWUsIGdldHRlcilcbiAqXG4gKiBBZGRzIGEgcHJvcGVydHkgdG8gdGhlIHByb3RvdHlwZSBvZiBhbiBvYmplY3QuXG4gKlxuICogICAgIHV0aWxzLmFkZFByb3BlcnR5KGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmluc3RhbmNlb2YoRm9vKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmJlLmZvbztcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgcHJvcGVydHkgaXMgYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHByb3BlcnR5IHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGFkZFByb3BlcnR5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkUHJvcGVydHkoY3R4LCBuYW1lLCBnZXR0ZXIpIHtcbiAgZ2V0dGVyID0gZ2V0dGVyID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7fSA6IGdldHRlcjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiBwcm9wZXJ0eUdldHRlcigpIHtcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgYHNzZmlgIGZsYWcgdG8gYHByb3BlcnR5R2V0dGVyYCBjYXVzZXMgdGhpcyBmdW5jdGlvbiB0b1xuICAgICAgICAvLyBiZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uIGZyYW1lcyBmcm9tIHRoZVxuICAgICAgICAvLyBzdGFjayB0cmFjZSBvZiBhIGZhaWxlZCBhc3NlcnRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgaWZcbiAgICAgICAgLy8gdGhlIGBsb2NrU3NmaWAgZmxhZyBpc24ndCBzZXQgYW5kIHByb3h5IHByb3RlY3Rpb24gaXMgZGlzYWJsZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aGVuIGVpdGhlciB0aGlzIGFzc2VydGlvbiBoYXMgYmVlblxuICAgICAgICAvLyBvdmVyd3JpdHRlbiBieSBhbm90aGVyIGFzc2VydGlvbiwgb3IgdGhpcyBhc3NlcnRpb24gaXMgYmVpbmcgaW52b2tlZFxuICAgICAgICAvLyBmcm9tIGluc2lkZSBvZiBhbm90aGVyIGFzc2VydGlvbi4gSW4gdGhlIGZpcnN0IGNhc2UsIHRoZSBgc3NmaWAgZmxhZ1xuICAgICAgICAvLyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3ZlcndyaXRpbmcgYXNzZXJ0aW9uLiBJbiB0aGUgc2Vjb25kXG4gICAgICAgIC8vIGNhc2UsIHRoZSBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3V0ZXIgYXNzZXJ0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBwcm94eSBwcm90ZWN0aW9uIGlzIGVuYWJsZWQsIHRoZW4gdGhlIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW5cbiAgICAgICAgLy8gc2V0IGJ5IHRoZSBwcm94eSBnZXR0ZXIuXG4gICAgICAgIGlmICghaXNQcm94eUVuYWJsZWQoKSAmJiAhZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBwcm9wZXJ0eUdldHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgICAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsInZhciBmbkxlbmd0aERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZ1bmN0aW9uICgpIHt9LCAnbGVuZ3RoJyk7XG5cbi8qIVxuICogQ2hhaSAtIGFkZExlbmd0aEd1YXJkIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuYWRkTGVuZ3RoR3VhcmQoZm4sIGFzc2VydGlvbk5hbWUsIGlzQ2hhaW5hYmxlKVxuICpcbiAqIERlZmluZSBgbGVuZ3RoYCBhcyBhIGdldHRlciBvbiB0aGUgZ2l2ZW4gdW5pbnZva2VkIG1ldGhvZCBhc3NlcnRpb24uIFRoZVxuICogZ2V0dGVyIGFjdHMgYXMgYSBndWFyZCBhZ2FpbnN0IGNoYWluaW5nIGBsZW5ndGhgIGRpcmVjdGx5IG9mZiBvZiBhbiB1bmludm9rZWRcbiAqIG1ldGhvZCBhc3NlcnRpb24sIHdoaWNoIGlzIGEgcHJvYmxlbSBiZWNhdXNlIGl0IHJlZmVyZW5jZXMgYGZ1bmN0aW9uYCdzXG4gKiBidWlsdC1pbiBgbGVuZ3RoYCBwcm9wZXJ0eSBpbnN0ZWFkIG9mIENoYWkncyBgbGVuZ3RoYCBhc3NlcnRpb24uIFdoZW4gdGhlXG4gKiBnZXR0ZXIgY2F0Y2hlcyB0aGUgdXNlciBtYWtpbmcgdGhpcyBtaXN0YWtlLCBpdCB0aHJvd3MgYW4gZXJyb3Igd2l0aCBhXG4gKiBoZWxwZnVsIG1lc3NhZ2UuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIGluIHdoaWNoIHRoaXMgbWlzdGFrZSBjYW4gYmUgbWFkZS4gVGhlIGZpcnN0IHdheSBpcyBieVxuICogY2hhaW5pbmcgdGhlIGBsZW5ndGhgIGFzc2VydGlvbiBkaXJlY3RseSBvZmYgb2YgYW4gdW5pbnZva2VkIGNoYWluYWJsZVxuICogbWV0aG9kLiBJbiB0aGlzIGNhc2UsIENoYWkgc3VnZ2VzdHMgdGhhdCB0aGUgdXNlciB1c2UgYGxlbmd0aE9mYCBpbnN0ZWFkLiBUaGVcbiAqIHNlY29uZCB3YXkgaXMgYnkgY2hhaW5pbmcgdGhlIGBsZW5ndGhgIGFzc2VydGlvbiBkaXJlY3RseSBvZmYgb2YgYW4gdW5pbnZva2VkXG4gKiBub24tY2hhaW5hYmxlIG1ldGhvZC4gTm9uLWNoYWluYWJsZSBtZXRob2RzIG11c3QgYmUgaW52b2tlZCBwcmlvciB0b1xuICogY2hhaW5pbmcuIEluIHRoaXMgY2FzZSwgQ2hhaSBzdWdnZXN0cyB0aGF0IHRoZSB1c2VyIGNvbnN1bHQgdGhlIGRvY3MgZm9yIHRoZVxuICogZ2l2ZW4gYXNzZXJ0aW9uLlxuICpcbiAqIElmIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgdW5jb25maWd1cmFibGUsIHRoZW4gcmV0dXJuIGBmbmBcbiAqIHdpdGhvdXQgbW9kaWZpY2F0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCBpbiBFUzYsIHRoZSBmdW5jdGlvbidzIGBsZW5ndGhgIHByb3BlcnR5IGlzIGNvbmZpZ3VyYWJsZSwgc28gb25jZVxuICogc3VwcG9ydCBmb3IgbGVnYWN5IGVudmlyb25tZW50cyBpcyBkcm9wcGVkLCBDaGFpJ3MgYGxlbmd0aGAgcHJvcGVydHkgY2FuXG4gKiByZXBsYWNlIHRoZSBidWlsdC1pbiBmdW5jdGlvbidzIGBsZW5ndGhgIHByb3BlcnR5LCBhbmQgdGhpcyBsZW5ndGggZ3VhcmQgd2lsbFxuICogbm8gbG9uZ2VyIGJlIG5lY2Vzc2FyeS4gSW4gdGhlIG1lYW4gdGltZSwgbWFpbnRhaW5pbmcgY29uc2lzdGVuY3kgYWNyb3NzIGFsbFxuICogZW52aXJvbm1lbnRzIGlzIHRoZSBwcmlvcml0eS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtTdHJpbmd9IGFzc2VydGlvbk5hbWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDaGFpbmFibGVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGFkZExlbmd0aEd1YXJkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhZGRMZW5ndGhHdWFyZCAoZm4sIGFzc2VydGlvbk5hbWUsIGlzQ2hhaW5hYmxlKSB7XG4gIGlmICghZm5MZW5ndGhEZXNjLmNvbmZpZ3VyYWJsZSkgcmV0dXJuIGZuO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ2xlbmd0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0NoYWluYWJsZSkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBDaGFpIHByb3BlcnR5OiAnICsgYXNzZXJ0aW9uTmFtZSArICcubGVuZ3RoLiBEdWUnICtcbiAgICAgICAgICAnIHRvIGEgY29tcGF0aWJpbGl0eSBpc3N1ZSwgXCJsZW5ndGhcIiBjYW5ub3QgZGlyZWN0bHkgZm9sbG93IFwiJyArXG4gICAgICAgICAgYXNzZXJ0aW9uTmFtZSArICdcIi4gVXNlIFwiJyArIGFzc2VydGlvbk5hbWUgKyAnLmxlbmd0aE9mXCIgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgQ2hhaSBwcm9wZXJ0eTogJyArIGFzc2VydGlvbk5hbWUgKyAnLmxlbmd0aC4gU2VlJyArXG4gICAgICAgICcgZG9jcyBmb3IgcHJvcGVyIHVzYWdlIG9mIFwiJyArIGFzc2VydGlvbk5hbWUgKyAnXCIuJyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZm47XG59O1xuIiwidmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBnZXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRQcm9wZXJ0aWVzJyk7XG52YXIgaXNQcm94eUVuYWJsZWQgPSByZXF1aXJlKCcuL2lzUHJveHlFbmFibGVkJyk7XG5cbi8qIVxuICogQ2hhaSAtIHByb3hpZnkgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5wcm94aWZ5KG9iamVjdClcbiAqXG4gKiBSZXR1cm4gYSBwcm94eSBvZiBnaXZlbiBvYmplY3QgdGhhdCB0aHJvd3MgYW4gZXJyb3Igd2hlbiBhIG5vbi1leGlzdGVudFxuICogcHJvcGVydHkgaXMgcmVhZC4gQnkgZGVmYXVsdCwgdGhlIHJvb3QgY2F1c2UgaXMgYXNzdW1lZCB0byBiZSBhIG1pc3NwZWxsZWRcbiAqIHByb3BlcnR5LCBhbmQgdGh1cyBhbiBhdHRlbXB0IGlzIG1hZGUgdG8gb2ZmZXIgYSByZWFzb25hYmxlIHN1Z2dlc3Rpb24gZnJvbVxuICogdGhlIGxpc3Qgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gSG93ZXZlciwgaWYgYSBub25DaGFpbmFibGVNZXRob2ROYW1lIGlzXG4gKiBwcm92aWRlZCwgdGhlbiB0aGUgcm9vdCBjYXVzZSBpcyBpbnN0ZWFkIGEgZmFpbHVyZSB0byBpbnZva2UgYSBub24tY2hhaW5hYmxlXG4gKiBtZXRob2QgcHJpb3IgdG8gcmVhZGluZyB0aGUgbm9uLWV4aXN0ZW50IHByb3BlcnR5LlxuICpcbiAqIElmIHByb3hpZXMgYXJlIHVuc3VwcG9ydGVkIG9yIGRpc2FibGVkIHZpYSB0aGUgdXNlcidzIENoYWkgY29uZmlnLCB0aGVuXG4gKiByZXR1cm4gb2JqZWN0IHdpdGhvdXQgbW9kaWZpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBub25DaGFpbmFibGVNZXRob2ROYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBwcm94aWZ5XG4gKi9cblxudmFyIGJ1aWx0aW5zID0gWydfX2ZsYWdzJywgJ19fbWV0aG9kcycsICdfb2JqJywgJ2Fzc2VydCddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHByb3hpZnkob2JqLCBub25DaGFpbmFibGVNZXRob2ROYW1lKSB7XG4gIGlmICghaXNQcm94eUVuYWJsZWQoKSkgcmV0dXJuIG9iajtcblxuICByZXR1cm4gbmV3IFByb3h5KG9iaiwge1xuICAgIGdldDogZnVuY3Rpb24gcHJveHlHZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgLy8gVGhpcyBjaGVjayBpcyBoZXJlIGJlY2F1c2Ugd2Ugc2hvdWxkIG5vdCB0aHJvdyBlcnJvcnMgb24gU3ltYm9sIHByb3BlcnRpZXNcbiAgICAgIC8vIHN1Y2ggYXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AuXG4gICAgICAvLyBUaGUgdmFsdWVzIGZvciB3aGljaCBhbiBlcnJvciBzaG91bGQgYmUgdGhyb3duIGNhbiBiZSBjb25maWd1cmVkIHVzaW5nXG4gICAgICAvLyB0aGUgYGNvbmZpZy5wcm94eUV4Y2x1ZGVkS2V5c2Agc2V0dGluZy5cbiAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgY29uZmlnLnByb3h5RXhjbHVkZWRLZXlzLmluZGV4T2YocHJvcGVydHkpID09PSAtMSAmJlxuICAgICAgICAgICFSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5KSkge1xuICAgICAgICAvLyBTcGVjaWFsIG1lc3NhZ2UgZm9yIGludmFsaWQgcHJvcGVydHkgYWNjZXNzIG9mIG5vbi1jaGFpbmFibGUgbWV0aG9kcy5cbiAgICAgICAgaWYgKG5vbkNoYWluYWJsZU1ldGhvZE5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBDaGFpIHByb3BlcnR5OiAnICsgbm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSArICcuJyArXG4gICAgICAgICAgICBwcm9wZXJ0eSArICcuIFNlZSBkb2NzIGZvciBwcm9wZXIgdXNhZ2Ugb2YgXCInICtcbiAgICAgICAgICAgIG5vbkNoYWluYWJsZU1ldGhvZE5hbWUgKyAnXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgcmVhc29uYWJseSBjbG9zZSB0byBhbiBleGlzdGluZyBDaGFpIHByb3BlcnR5LFxuICAgICAgICAvLyBzdWdnZXN0IHRoYXQgcHJvcGVydHkgdG8gdGhlIHVzZXIuIE9ubHkgc3VnZ2VzdCBwcm9wZXJ0aWVzIHdpdGggYVxuICAgICAgICAvLyBkaXN0YW5jZSBsZXNzIHRoYW4gNC5cbiAgICAgICAgdmFyIHN1Z2dlc3Rpb24gPSBudWxsO1xuICAgICAgICB2YXIgc3VnZ2VzdGlvbkRpc3RhbmNlID0gNDtcbiAgICAgICAgZ2V0UHJvcGVydGllcyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApICYmXG4gICAgICAgICAgICBidWlsdGlucy5pbmRleE9mKHByb3ApID09PSAtMVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBzdHJpbmdEaXN0YW5jZUNhcHBlZChcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgIHN1Z2dlc3Rpb25EaXN0YW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChkaXN0IDwgc3VnZ2VzdGlvbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgIHN1Z2dlc3Rpb24gPSBwcm9wO1xuICAgICAgICAgICAgICBzdWdnZXN0aW9uRGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHN1Z2dlc3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBDaGFpIHByb3BlcnR5OiAnICsgcHJvcGVydHkgK1xuICAgICAgICAgICAgJy4gRGlkIHlvdSBtZWFuIFwiJyArIHN1Z2dlc3Rpb24gKyAnXCI/Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgQ2hhaSBwcm9wZXJ0eTogJyArIHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVc2UgdGhpcyBwcm94eSBnZXR0ZXIgYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gZnJhbWVzIGZyb20gdGhlIHN0YWNrIHRyYWNlIG9mIGEgZmFpbGVkIGFzc2VydGlvbi4gRm9yIHByb3BlcnR5XG4gICAgICAvLyBhc3NlcnRpb25zLCB0aGlzIHByZXZlbnRzIHRoZSBwcm94eSBnZXR0ZXIgZnJvbSBzaG93aW5nIHVwIGluIHRoZSBzdGFja1xuICAgICAgLy8gdHJhY2Ugc2luY2UgaXQncyBpbnZva2VkIGJlZm9yZSB0aGUgcHJvcGVydHkgZ2V0dGVyLiBGb3IgbWV0aG9kIGFuZFxuICAgICAgLy8gY2hhaW5hYmxlIG1ldGhvZCBhc3NlcnRpb25zLCB0aGlzIGZsYWcgd2lsbCBlbmQgdXAgZ2V0dGluZyBjaGFuZ2VkIHRvXG4gICAgICAvLyB0aGUgbWV0aG9kIHdyYXBwZXIsIHdoaWNoIGlzIGdvb2Qgc2luY2UgdGhpcyBmcmFtZSB3aWxsIG5vIGxvbmdlciBiZSBpblxuICAgICAgLy8gdGhlIHN0YWNrIG9uY2UgdGhlIG1ldGhvZCBpcyBpbnZva2VkLiBOb3RlIHRoYXQgQ2hhaSBidWlsdGluIGFzc2VydGlvblxuICAgICAgLy8gcHJvcGVydGllcyBzdWNoIGFzIGBfX2ZsYWdzYCBhcmUgc2tpcHBlZCBzaW5jZSB0aGlzIGlzIG9ubHkgbWVhbnQgdG9cbiAgICAgIC8vIGNhcHR1cmUgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIGFuIGFzc2VydGlvbi4gVGhpcyBzdGVwIGlzIGFsc28gc2tpcHBlZFxuICAgICAgLy8gaWYgdGhlIGBsb2NrU3NmaWAgZmxhZyBpcyBzZXQsIHRodXMgaW5kaWNhdGluZyB0aGF0IHRoaXMgYXNzZXJ0aW9uIGlzXG4gICAgICAvLyBiZWluZyBjYWxsZWQgZnJvbSB3aXRoaW4gYW5vdGhlciBhc3NlcnRpb24uIEluIHRoYXQgY2FzZSwgdGhlIGBzc2ZpYFxuICAgICAgLy8gZmxhZyBpcyBhbHJlYWR5IHNldCB0byB0aGUgb3V0ZXIgYXNzZXJ0aW9uJ3Mgc3RhcnRpbmcgcG9pbnQuXG4gICAgICBpZiAoYnVpbHRpbnMuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xICYmICFmbGFnKHRhcmdldCwgJ2xvY2tTc2ZpJykpIHtcbiAgICAgICAgZmxhZyh0YXJnZXQsICdzc2ZpJywgcHJveHlHZXR0ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogIyBzdHJpbmdEaXN0YW5jZUNhcHBlZChzdHJBLCBzdHJCLCBjYXApXG4gKiBSZXR1cm4gdGhlIExldmVuc2h0ZWluIGRpc3RhbmNlIGJldHdlZW4gdHdvIHN0cmluZ3MsIGJ1dCBubyBtb3JlIHRoYW4gY2FwLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ckFcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJCXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG1pbihzdHJpbmcgZGlzdGFuY2UgYmV0d2VlbiBzdHJBIGFuZCBzdHJCLCBjYXApXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdEaXN0YW5jZUNhcHBlZChzdHJBLCBzdHJCLCBjYXApIHtcbiAgaWYgKE1hdGguYWJzKHN0ckEubGVuZ3RoIC0gc3RyQi5sZW5ndGgpID49IGNhcCkge1xuICAgIHJldHVybiBjYXA7XG4gIH1cblxuICB2YXIgbWVtbyA9IFtdO1xuICAvLyBgbWVtb2AgaXMgYSB0d28tZGltZW5zaW9uYWwgYXJyYXkgY29udGFpbmluZyBkaXN0YW5jZXMuXG4gIC8vIG1lbW9baV1bal0gaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gc3RyQS5zbGljZSgwLCBpKSBhbmRcbiAgLy8gc3RyQi5zbGljZSgwLCBqKS5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc3RyQS5sZW5ndGg7IGkrKykge1xuICAgIG1lbW9baV0gPSBBcnJheShzdHJCLmxlbmd0aCArIDEpLmZpbGwoMCk7XG4gICAgbWVtb1tpXVswXSA9IGk7XG4gIH1cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHJCLmxlbmd0aDsgaisrKSB7XG4gICAgbWVtb1swXVtqXSA9IGo7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzdHJBLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoID0gc3RyQS5jaGFyQ29kZUF0KGkgLSAxKTtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBzdHJCLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoaSAtIGopID49IGNhcCkge1xuICAgICAgICBtZW1vW2ldW2pdID0gY2FwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1lbW9baV1bal0gPSBNYXRoLm1pbihcbiAgICAgICAgbWVtb1tpIC0gMV1bal0gKyAxLFxuICAgICAgICBtZW1vW2ldW2ogLSAxXSArIDEsXG4gICAgICAgIG1lbW9baSAtIDFdW2ogLSAxXSArXG4gICAgICAgICAgKGNoID09PSBzdHJCLmNoYXJDb2RlQXQoaiAtIDEpID8gMCA6IDEpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZW1vW3N0ckEubGVuZ3RoXVtzdHJCLmxlbmd0aF07XG59XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBhZGRMZW5ndGhHdWFyZCA9IHJlcXVpcmUoJy4vYWRkTGVuZ3RoR3VhcmQnKTtcbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBwcm94aWZ5ID0gcmVxdWlyZSgnLi9wcm94aWZ5Jyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKipcbiAqICMjIyAuYWRkTWV0aG9kKGN0eCwgbmFtZSwgbWV0aG9kKVxuICpcbiAqIEFkZHMgYSBtZXRob2QgdG8gdGhlIHByb3RvdHlwZSBvZiBhbiBvYmplY3QuXG4gKlxuICogICAgIHV0aWxzLmFkZE1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5lcXVhbChzdHIpO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28oJ2JhcicpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBtZXRob2QgaXMgYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBhZGRNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhZGRNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QpIHtcbiAgdmFyIG1ldGhvZFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2V0dGluZyB0aGUgYHNzZmlgIGZsYWcgdG8gYG1ldGhvZFdyYXBwZXJgIGNhdXNlcyB0aGlzIGZ1bmN0aW9uIHRvIGJlIHRoZVxuICAgIC8vIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvbiBmcmFtZXMgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2ZcbiAgICAvLyBhIGZhaWxlZCBhc3NlcnRpb24uXG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGlmIHRoZVxuICAgIC8vIGBsb2NrU3NmaWAgZmxhZyBpc24ndCBzZXQuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGhlbiBlaXRoZXIgdGhpcyBhc3NlcnRpb24gaGFzIGJlZW5cbiAgICAvLyBvdmVyd3JpdHRlbiBieSBhbm90aGVyIGFzc2VydGlvbiwgb3IgdGhpcyBhc3NlcnRpb24gaXMgYmVpbmcgaW52b2tlZCBmcm9tXG4gICAgLy8gaW5zaWRlIG9mIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGUgZmlyc3QgY2FzZSwgdGhlIGBzc2ZpYCBmbGFnIGhhc1xuICAgIC8vIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi4gSW4gdGhlIHNlY29uZCBjYXNlLCB0aGVcbiAgICAvLyBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3V0ZXIgYXNzZXJ0aW9uLlxuICAgIGlmICghZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIG1ldGhvZFdyYXBwZXIpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICB9O1xuXG4gIGFkZExlbmd0aEd1YXJkKG1ldGhvZFdyYXBwZXIsIG5hbWUsIGZhbHNlKTtcbiAgY3R4W25hbWVdID0gcHJveGlmeShtZXRob2RXcmFwcGVyLCBuYW1lKTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIGlzUHJveHlFbmFibGVkID0gcmVxdWlyZSgnLi9pc1Byb3h5RW5hYmxlZCcpO1xudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyoqXG4gKiAjIyMgLm92ZXJ3cml0ZVByb3BlcnR5KGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndyaXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIHByb3BlcnR5IGdldHRlciBhbmQgcHJvdmlkZXNcbiAqIGFjY2VzcyB0byBwcmV2aW91cyB2YWx1ZS4gTXVzdCByZXR1cm4gZnVuY3Rpb24gdG8gdXNlIGFzIGdldHRlci5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnb2snLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICogICAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBGb28pIHtcbiAqICAgICAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqLm5hbWUpLnRvLmVxdWFsKCdiYXInKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5KCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmJlLm9rO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIHByb3BlcnR5IGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBwcm9wZXJ0eSB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBnZXR0ZXIgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgb3ZlcndyaXRlUHJvcGVydHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvdmVyd3JpdGVQcm9wZXJ0eShjdHgsIG5hbWUsIGdldHRlcikge1xuICB2YXIgX2dldCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3R4LCBuYW1lKVxuICAgICwgX3N1cGVyID0gZnVuY3Rpb24gKCkge307XG5cbiAgaWYgKF9nZXQgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIF9nZXQuZ2V0KVxuICAgIF9zdXBlciA9IF9nZXQuZ2V0XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gb3ZlcndyaXRpbmdQcm9wZXJ0eUdldHRlcigpIHtcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgYHNzZmlgIGZsYWcgdG8gYG92ZXJ3cml0aW5nUHJvcGVydHlHZXR0ZXJgIGNhdXNlcyB0aGlzXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIGJlIHRoZSBzdGFydGluZyBwb2ludCBmb3IgcmVtb3ZpbmcgaW1wbGVtZW50YXRpb24gZnJhbWVzXG4gICAgICAgIC8vIGZyb20gdGhlIHN0YWNrIHRyYWNlIG9mIGEgZmFpbGVkIGFzc2VydGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGFzIHRoZSBzdGFydGluZyBwb2ludCBpZlxuICAgICAgICAvLyB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzbid0IHNldCBhbmQgcHJveHkgcHJvdGVjdGlvbiBpcyBkaXNhYmxlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlIGBsb2NrU3NmaWAgZmxhZyBpcyBzZXQsIHRoZW4gZWl0aGVyIHRoaXMgYXNzZXJ0aW9uIGhhcyBiZWVuXG4gICAgICAgIC8vIG92ZXJ3cml0dGVuIGJ5IGFub3RoZXIgYXNzZXJ0aW9uLCBvciB0aGlzIGFzc2VydGlvbiBpcyBiZWluZyBpbnZva2VkXG4gICAgICAgIC8vIGZyb20gaW5zaWRlIG9mIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGUgZmlyc3QgY2FzZSwgdGhlIGBzc2ZpYCBmbGFnXG4gICAgICAgIC8vIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdmVyd3JpdGluZyBhc3NlcnRpb24uIEluIHRoZSBzZWNvbmRcbiAgICAgICAgLy8gY2FzZSwgdGhlIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdXRlciBhc3NlcnRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHByb3h5IHByb3RlY3Rpb24gaXMgZW5hYmxlZCwgdGhlbiB0aGUgYHNzZmlgIGZsYWcgaGFzIGFscmVhZHkgYmVlblxuICAgICAgICAvLyBzZXQgYnkgdGhlIHByb3h5IGdldHRlci5cbiAgICAgICAgaWYgKCFpc1Byb3h5RW5hYmxlZCgpICYmICFmbGFnKHRoaXMsICdsb2NrU3NmaScpKSB7XG4gICAgICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIG92ZXJ3cml0aW5nUHJvcGVydHlHZXR0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0dGluZyB0aGUgYGxvY2tTc2ZpYCBmbGFnIHRvIGB0cnVlYCBwcmV2ZW50cyB0aGUgb3ZlcndyaXR0ZW5cbiAgICAgICAgLy8gYXNzZXJ0aW9uIGZyb20gY2hhbmdpbmcgdGhlIGBzc2ZpYCBmbGFnLiBCeSB0aGlzIHBvaW50LCB0aGUgYHNzZmlgXG4gICAgICAgIC8vIGZsYWcgaXMgYWxyZWFkeSBzZXQgdG8gdGhlIGNvcnJlY3Qgc3RhcnRpbmcgcG9pbnQgZm9yIHRoaXMgYXNzZXJ0aW9uLlxuICAgICAgICB2YXIgb3JpZ0xvY2tTc2ZpID0gZmxhZyh0aGlzLCAnbG9ja1NzZmknKTtcbiAgICAgICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCB0cnVlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldHRlcihfc3VwZXIpLmNhbGwodGhpcyk7XG4gICAgICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgb3JpZ0xvY2tTc2ZpKTtcblxuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgICAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gb3ZlcndyaXRlTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgYWRkTGVuZ3RoR3VhcmQgPSByZXF1aXJlKCcuL2FkZExlbmd0aEd1YXJkJyk7XG52YXIgY2hhaSA9IHJlcXVpcmUoJy4uLy4uL2NoYWknKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgcHJveGlmeSA9IHJlcXVpcmUoJy4vcHJveGlmeScpO1xudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyoqXG4gKiAjIyMgLm92ZXJ3cml0ZU1ldGhvZChjdHgsIG5hbWUsIGZuKVxuICpcbiAqIE92ZXJ3cml0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBtZXRob2QgYW5kIHByb3ZpZGVzXG4gKiBhY2Nlc3MgdG8gcHJldmlvdXMgZnVuY3Rpb24uIE11c3QgcmV0dXJuIGZ1bmN0aW9uXG4gKiB0byBiZSB1c2VkIGZvciBuYW1lLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZXF1YWwnLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBGb28pIHtcbiAqICAgICAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqLnZhbHVlKS50by5lcXVhbChzdHIpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uZXF1YWwoJ2JhcicpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIG1ldGhvZCBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIG92ZXJ3cml0ZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG92ZXJ3cml0ZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICB2YXIgX21ldGhvZCA9IGN0eFtuYW1lXVxuICAgICwgX3N1cGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfTtcblxuICBpZiAoX21ldGhvZCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgX21ldGhvZClcbiAgICBfc3VwZXIgPSBfbWV0aG9kO1xuXG4gIHZhciBvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2V0dGluZyB0aGUgYHNzZmlgIGZsYWcgdG8gYG92ZXJ3cml0aW5nTWV0aG9kV3JhcHBlcmAgY2F1c2VzIHRoaXNcbiAgICAvLyBmdW5jdGlvbiB0byBiZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uIGZyYW1lcyBmcm9tXG4gICAgLy8gdGhlIHN0YWNrIHRyYWNlIG9mIGEgZmFpbGVkIGFzc2VydGlvbi5cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgaWYgdGhlXG4gICAgLy8gYGxvY2tTc2ZpYCBmbGFnIGlzbid0IHNldC5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aGVuIGVpdGhlciB0aGlzIGFzc2VydGlvbiBoYXMgYmVlblxuICAgIC8vIG92ZXJ3cml0dGVuIGJ5IGFub3RoZXIgYXNzZXJ0aW9uLCBvciB0aGlzIGFzc2VydGlvbiBpcyBiZWluZyBpbnZva2VkIGZyb21cbiAgICAvLyBpbnNpZGUgb2YgYW5vdGhlciBhc3NlcnRpb24uIEluIHRoZSBmaXJzdCBjYXNlLCB0aGUgYHNzZmlgIGZsYWcgaGFzXG4gICAgLy8gYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3ZlcndyaXRpbmcgYXNzZXJ0aW9uLiBJbiB0aGUgc2Vjb25kIGNhc2UsIHRoZVxuICAgIC8vIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdXRlciBhc3NlcnRpb24uXG4gICAgaWYgKCFmbGFnKHRoaXMsICdsb2NrU3NmaScpKSB7XG4gICAgICBmbGFnKHRoaXMsICdzc2ZpJywgb3ZlcndyaXRpbmdNZXRob2RXcmFwcGVyKTtcbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIHRoZSBgbG9ja1NzZmlgIGZsYWcgdG8gYHRydWVgIHByZXZlbnRzIHRoZSBvdmVyd3JpdHRlbiBhc3NlcnRpb25cbiAgICAvLyBmcm9tIGNoYW5naW5nIHRoZSBgc3NmaWAgZmxhZy4gQnkgdGhpcyBwb2ludCwgdGhlIGBzc2ZpYCBmbGFnIGlzIGFscmVhZHlcbiAgICAvLyBzZXQgdG8gdGhlIGNvcnJlY3Qgc3RhcnRpbmcgcG9pbnQgZm9yIHRoaXMgYXNzZXJ0aW9uLlxuICAgIHZhciBvcmlnTG9ja1NzZmkgPSBmbGFnKHRoaXMsICdsb2NrU3NmaScpO1xuICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgdHJ1ZSk7XG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZChfc3VwZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCBvcmlnTG9ja1NzZmkpO1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgfVxuXG4gIGFkZExlbmd0aEd1YXJkKG92ZXJ3cml0aW5nTWV0aG9kV3JhcHBlciwgbmFtZSwgZmFsc2UpO1xuICBjdHhbbmFtZV0gPSBwcm94aWZ5KG92ZXJ3cml0aW5nTWV0aG9kV3JhcHBlciwgbmFtZSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gYWRkQ2hhaW5pbmdNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBhZGRMZW5ndGhHdWFyZCA9IHJlcXVpcmUoJy4vYWRkTGVuZ3RoR3VhcmQnKTtcbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBwcm94aWZ5ID0gcmVxdWlyZSgnLi9wcm94aWZ5Jyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKiFcbiAqIE1vZHVsZSB2YXJpYWJsZXNcbiAqL1xuXG4vLyBDaGVjayB3aGV0aGVyIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIGlzIHN1cHBvcnRlZFxudmFyIGNhblNldFByb3RvdHlwZSA9IHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPT09ICdmdW5jdGlvbic7XG5cbi8vIFdpdGhvdXQgYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgc3VwcG9ydCwgdGhpcyBtb2R1bGUgd2lsbCBuZWVkIHRvIGFkZCBwcm9wZXJ0aWVzIHRvIGEgZnVuY3Rpb24uXG4vLyBIb3dldmVyLCBzb21lIG9mIGZ1bmN0aW9ucycgb3duIHByb3BzIGFyZSBub3QgY29uZmlndXJhYmxlIGFuZCBzaG91bGQgYmUgc2tpcHBlZC5cbnZhciB0ZXN0Rm4gPSBmdW5jdGlvbigpIHt9O1xudmFyIGV4Y2x1ZGVOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3RGbikuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0ZXN0Rm4sIG5hbWUpO1xuXG4gIC8vIE5vdGU6IFBoYW50b21KUyAxLnggaW5jbHVkZXMgYGNhbGxlZWAgYXMgb25lIG9mIGB0ZXN0Rm5gJ3Mgb3duIHByb3BlcnRpZXMsXG4gIC8vIGJ1dCB0aGVuIHJldHVybnMgYHVuZGVmaW5lZGAgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBjYWxsZWVgLiBBcyBhXG4gIC8vIHdvcmthcm91bmQsIHdlIHBlcmZvcm0gYW4gb3RoZXJ3aXNlIHVubmVjZXNzYXJ5IHR5cGUtY2hlY2sgZm9yIGBwcm9wRGVzY2AsXG4gIC8vIGFuZCB0aGVuIGZpbHRlciBpdCBvdXQgaWYgaXQncyBub3QgYW4gb2JqZWN0IGFzIGl0IHNob3VsZCBiZS5cbiAgaWYgKHR5cGVvZiBwcm9wRGVzYyAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgcmV0dXJuICFwcm9wRGVzYy5jb25maWd1cmFibGU7XG59KTtcblxuLy8gQ2FjaGUgYEZ1bmN0aW9uYCBwcm9wZXJ0aWVzXG52YXIgY2FsbCAgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCxcbiAgICBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLyoqXG4gKiAjIyMgLmFkZENoYWluYWJsZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcilcbiAqXG4gKiBBZGRzIGEgbWV0aG9kIHRvIGFuIG9iamVjdCwgc3VjaCB0aGF0IHRoZSBtZXRob2QgY2FuIGFsc28gYmUgY2hhaW5lZC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkQ2hhaW5hYmxlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2ZvbycsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAqXG4gKiBUaGUgcmVzdWx0IGNhbiB0aGVuIGJlIHVzZWQgYXMgYm90aCBhIG1ldGhvZCBhc3NlcnRpb24sIGV4ZWN1dGluZyBib3RoIGBtZXRob2RgIGFuZFxuICogYGNoYWluaW5nQmVoYXZpb3JgLCBvciBhcyBhIGxhbmd1YWdlIGNoYWluLCB3aGljaCBvbmx5IGV4ZWN1dGVzIGBjaGFpbmluZ0JlaGF2aW9yYC5cbiAqXG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vKCdiYXInKTtcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28uZXF1YWwoJ2ZvbycpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBtZXRob2QgaXMgYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBgbmFtZWAsIHdoZW4gY2FsbGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFpbmluZ0JlaGF2aW9yIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgYWRkQ2hhaW5hYmxlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkQ2hhaW5hYmxlTWV0aG9kKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gIGlmICh0eXBlb2YgY2hhaW5pbmdCZWhhdmlvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoYWluaW5nQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7IH07XG4gIH1cblxuICB2YXIgY2hhaW5hYmxlQmVoYXZpb3IgPSB7XG4gICAgICBtZXRob2Q6IG1ldGhvZFxuICAgICwgY2hhaW5pbmdCZWhhdmlvcjogY2hhaW5pbmdCZWhhdmlvclxuICB9O1xuXG4gIC8vIHNhdmUgdGhlIG1ldGhvZHMgc28gd2UgY2FuIG92ZXJ3cml0ZSB0aGVtIGxhdGVyLCBpZiB3ZSBuZWVkIHRvLlxuICBpZiAoIWN0eC5fX21ldGhvZHMpIHtcbiAgICBjdHguX19tZXRob2RzID0ge307XG4gIH1cbiAgY3R4Ll9fbWV0aG9kc1tuYW1lXSA9IGNoYWluYWJsZUJlaGF2aW9yO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uIGNoYWluYWJsZU1ldGhvZEdldHRlcigpIHtcbiAgICAgICAgY2hhaW5hYmxlQmVoYXZpb3IuY2hhaW5pbmdCZWhhdmlvci5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHZhciBjaGFpbmFibGVNZXRob2RXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFNldHRpbmcgdGhlIGBzc2ZpYCBmbGFnIHRvIGBjaGFpbmFibGVNZXRob2RXcmFwcGVyYCBjYXVzZXMgdGhpc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uIHRvIGJlIHRoZSBzdGFydGluZyBwb2ludCBmb3IgcmVtb3ZpbmcgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAvLyBmcmFtZXMgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGFzIHRoZSBzdGFydGluZyBwb2ludCBpZlxuICAgICAgICAgIC8vIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXNuJ3Qgc2V0LlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWYgdGhlIGBsb2NrU3NmaWAgZmxhZyBpcyBzZXQsIHRoZW4gdGhpcyBhc3NlcnRpb24gaXMgYmVpbmdcbiAgICAgICAgICAvLyBpbnZva2VkIGZyb20gaW5zaWRlIG9mIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGlzIGNhc2UsIHRoZSBgc3NmaWBcbiAgICAgICAgICAvLyBmbGFnIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdXRlciBhc3NlcnRpb24uXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgb3ZlcndyaXRpbmcgYSBjaGFpbmFibGUgbWV0aG9kIG1lcmVseSByZXBsYWNlcyB0aGUgc2F2ZWRcbiAgICAgICAgICAvLyBtZXRob2RzIGluIGBjdHguX19tZXRob2RzYCBpbnN0ZWFkIG9mIGNvbXBsZXRlbHkgcmVwbGFjaW5nIHRoZVxuICAgICAgICAgIC8vIG92ZXJ3cml0dGVuIGFzc2VydGlvbi4gVGhlcmVmb3JlLCBhbiBvdmVyd3JpdGluZyBhc3NlcnRpb24gd29uJ3RcbiAgICAgICAgICAvLyBzZXQgdGhlIGBzc2ZpYCBvciBgbG9ja1NzZmlgIGZsYWdzLlxuICAgICAgICAgIGlmICghZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIGNoYWluYWJsZU1ldGhvZFdyYXBwZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXN1bHQgPSBjaGFpbmFibGVCZWhhdmlvci5tZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICAgICAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFkZExlbmd0aEd1YXJkKGNoYWluYWJsZU1ldGhvZFdyYXBwZXIsIG5hbWUsIHRydWUpO1xuXG4gICAgICAgIC8vIFVzZSBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKGNhblNldFByb3RvdHlwZSkge1xuICAgICAgICAgIC8vIEluaGVyaXQgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgb2JqZWN0IGJ5IHJlcGxhY2luZyB0aGUgYEZ1bmN0aW9uYCBwcm90b3R5cGVcbiAgICAgICAgICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBgY2FsbGAgYW5kIGBhcHBseWAgbWV0aG9kcyBmcm9tIGBGdW5jdGlvbmBcbiAgICAgICAgICBwcm90b3R5cGUuY2FsbCA9IGNhbGw7XG4gICAgICAgICAgcHJvdG90eXBlLmFwcGx5ID0gYXBwbHk7XG4gICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNoYWluYWJsZU1ldGhvZFdyYXBwZXIsIHByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCByZWRlZmluZSBhbGwgcHJvcGVydGllcyAoc2xvdyEpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhc3NlcnRlck5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3R4KTtcbiAgICAgICAgICBhc3NlcnRlck5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGFzc2VydGVyTmFtZSkge1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVOYW1lcy5pbmRleE9mKGFzc2VydGVyTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIGFzc2VydGVyTmFtZSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hhaW5hYmxlTWV0aG9kV3JhcHBlciwgYXNzZXJ0ZXJOYW1lLCBwZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIGNoYWluYWJsZU1ldGhvZFdyYXBwZXIpO1xuICAgICAgICByZXR1cm4gcHJveGlmeShjaGFpbmFibGVNZXRob2RXcmFwcGVyKTtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyoqXG4gKiAjIyMgLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcilcbiAqXG4gKiBPdmVyd3JpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgY2hhaW5hYmxlIG1ldGhvZFxuICogYW5kIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgcHJldmlvdXMgZnVuY3Rpb24gb3JcbiAqIHByb3BlcnR5LiAgTXVzdCByZXR1cm4gZnVuY3Rpb25zIHRvIGJlIHVzZWQgZm9yXG4gKiBuYW1lLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnbGVuZ3RoT2YnLFxuICogICAgICAgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICwgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoJ2ZvbycsIGZuLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5oYXZlLmxlbmd0aE9mLmFib3ZlKDMpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIG1ldGhvZCAvIHByb3BlcnR5IGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgLyBwcm9wZXJ0eSB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFpbmluZ0JlaGF2aW9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIHByb3BlcnR5XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0gY3R4Ll9fbWV0aG9kc1tuYW1lXTtcblxuICB2YXIgX2NoYWluaW5nQmVoYXZpb3IgPSBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yO1xuICBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gb3ZlcndyaXRpbmdDaGFpbmFibGVNZXRob2RHZXR0ZXIoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNoYWluaW5nQmVoYXZpb3IoX2NoYWluaW5nQmVoYXZpb3IpLmNhbGwodGhpcyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgfTtcblxuICB2YXIgX21ldGhvZCA9IGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZDtcbiAgY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kID0gZnVuY3Rpb24gb3ZlcndyaXRpbmdDaGFpbmFibGVNZXRob2RXcmFwcGVyKCkge1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX21ldGhvZCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICB9O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGNvbXBhcmVCeUluc3BlY3QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0Jyk7XG5cbi8qKlxuICogIyMjIC5jb21wYXJlQnlJbnNwZWN0KG1peGVkLCBtaXhlZClcbiAqXG4gKiBUbyBiZSB1c2VkIGFzIGEgY29tcGFyZUZ1bmN0aW9uIHdpdGggQXJyYXkucHJvdG90eXBlLnNvcnQuIENvbXBhcmVzIGVsZW1lbnRzXG4gKiB1c2luZyBpbnNwZWN0IGluc3RlYWQgb2YgZGVmYXVsdCBiZWhhdmlvciBvZiB1c2luZyB0b1N0cmluZyBzbyB0aGF0IFN5bWJvbHNcbiAqIGFuZCBvYmplY3RzIHdpdGggaXJyZWd1bGFyL21pc3NpbmcgdG9TdHJpbmcgY2FuIHN0aWxsIGJlIHNvcnRlZCB3aXRob3V0IGFcbiAqIFR5cGVFcnJvci5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBmaXJzdCBlbGVtZW50IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7TWl4ZWR9IHNlY29uZCBlbGVtZW50IHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IC0xIGlmICdhJyBzaG91bGQgY29tZSBiZWZvcmUgJ2InOyBvdGhlcndpc2UgMVxuICogQG5hbWUgY29tcGFyZUJ5SW5zcGVjdFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbXBhcmVCeUluc3BlY3QoYSwgYikge1xuICByZXR1cm4gaW5zcGVjdChhKSA8IGluc3BlY3QoYikgPyAtMSA6IDE7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE2IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgZGlyZWN0bHktb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBzeW1ib2xzIG9mIGFuXG4gKiBvYmplY3QuIFRoaXMgZnVuY3Rpb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xuICogcmV0dXJucyBib3RoIGVudW1lcmFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IHN5bWJvbHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9sc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMob2JqKSB7XG4gIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIFtdO1xuXG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSkuZW51bWVyYWJsZTtcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzID0gcmVxdWlyZSgnLi9nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzJyk7XG5cbi8qKlxuICogIyMjIC5nZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyhvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBkaXJlY3RseS1vd25lZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBhbiBvYmplY3QuIFRoaXMgZnVuY3Rpb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgT2JqZWN0LmtleXMgb25seVxuICogcmV0dXJucyBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzLCBub3QgZW51bWVyYWJsZSBwcm9wZXJ0eSBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmNvbmNhdChnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzKG9iaikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogIVxuICogQ2hhaSAtIGNoZWNrRXJyb3IgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5jaGVja0Vycm9yXG4gKlxuICogQ2hlY2tzIHRoYXQgYW4gZXJyb3IgY29uZm9ybXMgdG8gYSBnaXZlbiBzZXQgb2YgY3JpdGVyaWEgYW5kL29yIHJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCBpdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogIyMjIC5jb21wYXRpYmxlSW5zdGFuY2UodGhyb3duLCBlcnJvckxpa2UpXG4gKlxuICogQ2hlY2tzIGlmIHR3byBpbnN0YW5jZXMgYXJlIGNvbXBhdGlibGUgKHN0cmljdCBlcXVhbCkuXG4gKiBSZXR1cm5zIGZhbHNlIGlmIGVycm9yTGlrZSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRXJyb3IsIGJlY2F1c2UgaW5zdGFuY2VzXG4gKiBjYW4gb25seSBiZSBjb21wYXRpYmxlIGlmIHRoZXkncmUgYm90aCBlcnJvciBpbnN0YW5jZXMuXG4gKlxuICogQG5hbWUgY29tcGF0aWJsZUluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSB0aHJvd24gZXJyb3JcbiAqIEBwYXJhbSB7RXJyb3J8RXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3JMaWtlIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3RcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY29tcGF0aWJsZUluc3RhbmNlKHRocm93biwgZXJyb3JMaWtlKSB7XG4gIHJldHVybiBlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvciAmJiB0aHJvd24gPT09IGVycm9yTGlrZTtcbn1cblxuLyoqXG4gKiAjIyMgLmNvbXBhdGlibGVDb25zdHJ1Y3Rvcih0aHJvd24sIGVycm9yTGlrZSlcbiAqXG4gKiBDaGVja3MgaWYgdHdvIGNvbnN0cnVjdG9ycyBhcmUgY29tcGF0aWJsZS5cbiAqIFRoaXMgZnVuY3Rpb24gY2FuIHJlY2VpdmUgZWl0aGVyIGFuIGVycm9yIGNvbnN0cnVjdG9yIG9yXG4gKiBhbiBlcnJvciBpbnN0YW5jZSBhcyB0aGUgYGVycm9yTGlrZWAgYXJndW1lbnQuXG4gKiBDb25zdHJ1Y3RvcnMgYXJlIGNvbXBhdGlibGUgaWYgdGhleSdyZSB0aGUgc2FtZSBvciBpZiBvbmUgaXNcbiAqIGFuIGluc3RhbmNlIG9mIGFub3RoZXIuXG4gKlxuICogQG5hbWUgY29tcGF0aWJsZUNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0Vycm9yfSB0aHJvd24gZXJyb3JcbiAqIEBwYXJhbSB7RXJyb3J8RXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3JMaWtlIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3RcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY29tcGF0aWJsZUNvbnN0cnVjdG9yKHRocm93biwgZXJyb3JMaWtlKSB7XG4gIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIElmIGBlcnJvckxpa2VgIGlzIGFuIGluc3RhbmNlIG9mIGFueSBlcnJvciB3ZSBjb21wYXJlIHRoZWlyIGNvbnN0cnVjdG9yc1xuICAgIHJldHVybiB0aHJvd24uY29uc3RydWN0b3IgPT09IGVycm9yTGlrZS5jb25zdHJ1Y3RvciB8fCB0aHJvd24gaW5zdGFuY2VvZiBlcnJvckxpa2UuY29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoZXJyb3JMaWtlLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVycm9yIHx8IGVycm9yTGlrZSA9PT0gRXJyb3IpIHtcbiAgICAvLyBJZiBgZXJyb3JMaWtlYCBpcyBhIGNvbnN0cnVjdG9yIHRoYXQgaW5oZXJpdHMgZnJvbSBFcnJvciwgd2UgY29tcGFyZSBgdGhyb3duYCB0byBgZXJyb3JMaWtlYCBkaXJlY3RseVxuICAgIHJldHVybiB0aHJvd24uY29uc3RydWN0b3IgPT09IGVycm9yTGlrZSB8fCB0aHJvd24gaW5zdGFuY2VvZiBlcnJvckxpa2U7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogIyMjIC5jb21wYXRpYmxlTWVzc2FnZSh0aHJvd24sIGVyck1hdGNoZXIpXG4gKlxuICogQ2hlY2tzIGlmIGFuIGVycm9yJ3MgbWVzc2FnZSBpcyBjb21wYXRpYmxlIHdpdGggYSBtYXRjaGVyIChTdHJpbmcgb3IgUmVnRXhwKS5cbiAqIElmIHRoZSBtZXNzYWdlIGNvbnRhaW5zIHRoZSBTdHJpbmcgb3IgcGFzc2VzIHRoZSBSZWdFeHAgdGVzdCxcbiAqIGl0IGlzIGNvbnNpZGVyZWQgY29tcGF0aWJsZS5cbiAqXG4gKiBAbmFtZSBjb21wYXRpYmxlTWVzc2FnZVxuICogQHBhcmFtIHtFcnJvcn0gdGhyb3duIGVycm9yXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGVyck1hdGNoZXIgdG8gbG9vayBmb3IgaW50byB0aGUgbWVzc2FnZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjb21wYXRpYmxlTWVzc2FnZSh0aHJvd24sIGVyck1hdGNoZXIpIHtcbiAgdmFyIGNvbXBhcmlzb25TdHJpbmcgPSB0eXBlb2YgdGhyb3duID09PSAnc3RyaW5nJyA/IHRocm93biA6IHRocm93bi5tZXNzYWdlO1xuICBpZiAoZXJyTWF0Y2hlciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBlcnJNYXRjaGVyLnRlc3QoY29tcGFyaXNvblN0cmluZyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVyck1hdGNoZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbXBhcmlzb25TdHJpbmcuaW5kZXhPZihlcnJNYXRjaGVyKSAhPT0gLTE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqICMjIyAuZ2V0RnVuY3Rpb25OYW1lKGNvbnN0cnVjdG9yRm4pXG4gKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uLlxuICogVGhpcyBhbHNvIGluY2x1ZGVzIGEgcG9seWZpbGwgZnVuY3Rpb24gaWYgYGNvbnN0cnVjdG9yRm4ubmFtZWAgaXMgbm90IGRlZmluZWQuXG4gKlxuICogQG5hbWUgZ2V0RnVuY3Rpb25OYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvckZuXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZnVuY3Rpb25OYW1lTWF0Y2ggPSAvXFxzKmZ1bmN0aW9uKD86XFxzfFxccypcXC9cXCpbXig/OipcXC8pXStcXCpcXC9cXHMqKSooW15cXChcXC9dKykvO1xuZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGNvbnN0cnVjdG9yRm4pIHtcbiAgdmFyIG5hbWUgPSAnJztcbiAgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvckZuLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gSGVyZSB3ZSBydW4gYSBwb2x5ZmlsbCBpZiBjb25zdHJ1Y3RvckZuLm5hbWUgaXMgbm90IGRlZmluZWRcbiAgICB2YXIgbWF0Y2ggPSBTdHJpbmcoY29uc3RydWN0b3JGbikubWF0Y2goZnVuY3Rpb25OYW1lTWF0Y2gpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gY29uc3RydWN0b3JGbi5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogIyMjIC5nZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKVxuICpcbiAqIEdldHMgdGhlIGNvbnN0cnVjdG9yIG5hbWUgZm9yIGFuIEVycm9yIGluc3RhbmNlIG9yIGNvbnN0cnVjdG9yIGl0c2VsZi5cbiAqXG4gKiBAbmFtZSBnZXRDb25zdHJ1Y3Rvck5hbWVcbiAqIEBwYXJhbSB7RXJyb3J8RXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3JMaWtlXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yTmFtZShlcnJvckxpa2UpIHtcbiAgdmFyIGNvbnN0cnVjdG9yTmFtZSA9IGVycm9yTGlrZTtcbiAgaWYgKGVycm9yTGlrZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgY29uc3RydWN0b3JOYW1lID0gZ2V0RnVuY3Rpb25OYW1lKGVycm9yTGlrZS5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yTGlrZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIElmIGBlcnJgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBFcnJvciBpdCBpcyBhbiBlcnJvciBjb25zdHJ1Y3RvciBpdHNlbGYgb3IgYW5vdGhlciBmdW5jdGlvbi5cbiAgICAvLyBJZiB3ZSd2ZSBnb3QgYSBjb21tb24gZnVuY3Rpb24gd2UgZ2V0IGl0cyBuYW1lLCBvdGhlcndpc2Ugd2UgbWF5IG5lZWQgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlXG4gICAgLy8gb2YgdGhlIGVycm9yIGp1c3QgaW4gY2FzZSBpdCdzIGEgcG9vcmx5LWNvbnN0cnVjdGVkIGVycm9yLiBQbGVhc2Ugc2VlIGNoYWlqcy9jaGFpL2lzc3Vlcy80NSB0byBrbm93IG1vcmUuXG4gICAgY29uc3RydWN0b3JOYW1lID0gZ2V0RnVuY3Rpb25OYW1lKGVycm9yTGlrZSkudHJpbSgpIHx8XG4gICAgICAgIGdldEZ1bmN0aW9uTmFtZShuZXcgZXJyb3JMaWtlKCkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgfVxuXG4gIHJldHVybiBjb25zdHJ1Y3Rvck5hbWU7XG59XG5cbi8qKlxuICogIyMjIC5nZXRNZXNzYWdlKGVycm9yTGlrZSlcbiAqXG4gKiBHZXRzIHRoZSBlcnJvciBtZXNzYWdlIGZyb20gYW4gZXJyb3IuXG4gKiBJZiBgZXJyYCBpcyBhIFN0cmluZyBpdHNlbGYsIHdlIHJldHVybiBpdC5cbiAqIElmIHRoZSBlcnJvciBoYXMgbm8gbWVzc2FnZSwgd2UgcmV0dXJuIGFuIGVtcHR5IHN0cmluZy5cbiAqXG4gKiBAbmFtZSBnZXRNZXNzYWdlXG4gKiBAcGFyYW0ge0Vycm9yfFN0cmluZ30gZXJyb3JMaWtlXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2UoZXJyb3JMaWtlKSB7XG4gIHZhciBtc2cgPSAnJztcbiAgaWYgKGVycm9yTGlrZSAmJiBlcnJvckxpa2UubWVzc2FnZSkge1xuICAgIG1zZyA9IGVycm9yTGlrZS5tZXNzYWdlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvckxpa2UgPT09ICdzdHJpbmcnKSB7XG4gICAgbXNnID0gZXJyb3JMaWtlO1xuICB9XG5cbiAgcmV0dXJuIG1zZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhdGlibGVJbnN0YW5jZTogY29tcGF0aWJsZUluc3RhbmNlLFxuICBjb21wYXRpYmxlQ29uc3RydWN0b3I6IGNvbXBhdGlibGVDb25zdHJ1Y3RvcixcbiAgY29tcGF0aWJsZU1lc3NhZ2U6IGNvbXBhdGlibGVNZXNzYWdlLFxuICBnZXRNZXNzYWdlOiBnZXRNZXNzYWdlLFxuICBnZXRDb25zdHJ1Y3Rvck5hbWU6IGdldENvbnN0cnVjdG9yTmFtZSxcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBpc05hTiB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE1IFNha3RoaXByaXlhbiBWYWlyYW1hbmkgPHRoZWNoYXJnaW5ndm9sY2Fub0BnbWFpbC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuaXNOYU4odmFsdWUpXG4gKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBOYU4gb3Igbm90LlxuICpcbiAqICAgICB1dGlscy5pc05hTihOYU4pOyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtWYWx1ZX0gVGhlIHZhbHVlIHdoaWNoIGhhcyB0byBiZSBjaGVja2VkIGlmIGl0IGlzIE5hTlxuICogQG5hbWUgaXNOYU5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gIC8vIFJlZmVyIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pc25hbi1udW1iZXJcbiAgLy8gc2VjdGlvbidzIE5PVEUuXG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbi8vIElmIEVDTUFTY3JpcHQgNidzIE51bWJlci5pc05hTiBpcyBwcmVzZW50LCBwcmVmZXIgdGhhdC5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzTmFOIHx8IGlzTmFOO1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMSBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogRGVwZW5kZW5jaWVzIHRoYXQgYXJlIHVzZWQgZm9yIG11bHRpcGxlIGV4cG9ydHMgYXJlIHJlcXVpcmVkIGhlcmUgb25seSBvbmNlXG4gKi9cblxudmFyIHBhdGh2YWwgPSByZXF1aXJlKCdwYXRodmFsJyk7XG5cbi8qIVxuICogdGVzdCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50ZXN0ID0gcmVxdWlyZSgnLi90ZXN0Jyk7XG5cbi8qIVxuICogdHlwZSB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcblxuLyohXG4gKiBleHBlY3RUeXBlcyB1dGlsaXR5XG4gKi9cbmV4cG9ydHMuZXhwZWN0VHlwZXMgPSByZXF1aXJlKCcuL2V4cGVjdFR5cGVzJyk7XG5cbi8qIVxuICogbWVzc2FnZSB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5nZXRNZXNzYWdlID0gcmVxdWlyZSgnLi9nZXRNZXNzYWdlJyk7XG5cbi8qIVxuICogYWN0dWFsIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmdldEFjdHVhbCA9IHJlcXVpcmUoJy4vZ2V0QWN0dWFsJyk7XG5cbi8qIVxuICogSW5zcGVjdCB1dGlsXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0Jyk7XG5cbi8qIVxuICogT2JqZWN0IERpc3BsYXkgdXRpbFxuICovXG5cbmV4cG9ydHMub2JqRGlzcGxheSA9IHJlcXVpcmUoJy4vb2JqRGlzcGxheScpO1xuXG4vKiFcbiAqIEZsYWcgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKiFcbiAqIEZsYWcgdHJhbnNmZXJyaW5nIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyohXG4gKiBEZWVwIGVxdWFsIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmVxbCA9IHJlcXVpcmUoJ2RlZXAtZXFsJyk7XG5cbi8qIVxuICogRGVlcCBwYXRoIGluZm9cbiAqL1xuXG5leHBvcnRzLmdldFBhdGhJbmZvID0gcGF0aHZhbC5nZXRQYXRoSW5mbztcblxuLyohXG4gKiBDaGVjayBpZiBhIHByb3BlcnR5IGV4aXN0c1xuICovXG5cbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBwYXRodmFsLmhhc1Byb3BlcnR5O1xuXG4vKiFcbiAqIEZ1bmN0aW9uIG5hbWVcbiAqL1xuXG5leHBvcnRzLmdldE5hbWUgPSByZXF1aXJlKCdnZXQtZnVuYy1uYW1lJyk7XG5cbi8qIVxuICogYWRkIFByb3BlcnR5XG4gKi9cblxuZXhwb3J0cy5hZGRQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vYWRkUHJvcGVydHknKTtcblxuLyohXG4gKiBhZGQgTWV0aG9kXG4gKi9cblxuZXhwb3J0cy5hZGRNZXRob2QgPSByZXF1aXJlKCcuL2FkZE1ldGhvZCcpO1xuXG4vKiFcbiAqIG92ZXJ3cml0ZSBQcm9wZXJ0eVxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL292ZXJ3cml0ZVByb3BlcnR5Jyk7XG5cbi8qIVxuICogb3ZlcndyaXRlIE1ldGhvZFxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlTWV0aG9kID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVNZXRob2QnKTtcblxuLyohXG4gKiBBZGQgYSBjaGFpbmFibGUgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5hZGRDaGFpbmFibGVNZXRob2QgPSByZXF1aXJlKCcuL2FkZENoYWluYWJsZU1ldGhvZCcpO1xuXG4vKiFcbiAqIE92ZXJ3cml0ZSBjaGFpbmFibGUgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgPSByZXF1aXJlKCcuL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCcpO1xuXG4vKiFcbiAqIENvbXBhcmUgYnkgaW5zcGVjdCBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmNvbXBhcmVCeUluc3BlY3QgPSByZXF1aXJlKCcuL2NvbXBhcmVCeUluc3BlY3QnKTtcblxuLyohXG4gKiBHZXQgb3duIGVudW1lcmFibGUgcHJvcGVydHkgc3ltYm9scyBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMgPSByZXF1aXJlKCcuL2dldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMnKTtcblxuLyohXG4gKiBHZXQgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcycpO1xuXG4vKiFcbiAqIENoZWNrcyBlcnJvciBhZ2FpbnN0IGEgZ2l2ZW4gc2V0IG9mIGNyaXRlcmlhXG4gKi9cblxuZXhwb3J0cy5jaGVja0Vycm9yID0gcmVxdWlyZSgnY2hlY2stZXJyb3InKTtcblxuLyohXG4gKiBQcm94aWZ5IHV0aWxcbiAqL1xuXG5leHBvcnRzLnByb3hpZnkgPSByZXF1aXJlKCcuL3Byb3hpZnknKTtcblxuLyohXG4gKiBhZGRMZW5ndGhHdWFyZCB1dGlsXG4gKi9cblxuZXhwb3J0cy5hZGRMZW5ndGhHdWFyZCA9IHJlcXVpcmUoJy4vYWRkTGVuZ3RoR3VhcmQnKTtcblxuLyohXG4gKiBpc1Byb3h5RW5hYmxlZCBoZWxwZXJcbiAqL1xuXG5leHBvcnRzLmlzUHJveHlFbmFibGVkID0gcmVxdWlyZSgnLi9pc1Byb3h5RW5hYmxlZCcpO1xuXG4vKiFcbiAqIGlzTmFOIG1ldGhvZFxuICovXG5cbmV4cG9ydHMuaXNOYU4gPSByZXF1aXJlKCcuL2lzTmFOJyk7XG4iLCIvKiFcbiAqIGNoYWlcbiAqIGh0dHA6Ly9jaGFpanMuY29tXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9jaGFpLCB1dGlsKSB7XG4gIC8qIVxuICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgQXNzZXJ0aW9uRXJyb3IgPSBfY2hhaS5Bc3NlcnRpb25FcnJvclxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgX2NoYWkuQXNzZXJ0aW9uID0gQXNzZXJ0aW9uO1xuXG4gIC8qIVxuICAgKiBBc3NlcnRpb24gQ29uc3RydWN0b3JcbiAgICpcbiAgICogQ3JlYXRlcyBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBgQXNzZXJ0aW9uYCBvYmplY3RzIGNvbnRhaW4gbWV0YWRhdGEgaW4gdGhlIGZvcm0gb2YgZmxhZ3MuIFRocmVlIGZsYWdzIGNhblxuICAgKiBiZSBhc3NpZ25lZCBkdXJpbmcgaW5zdGFudGlhdGlvbiBieSBwYXNzaW5nIGFyZ3VtZW50cyB0byB0aGlzIGNvbnN0cnVjdG9yOlxuICAgKlxuICAgKiAtIGBvYmplY3RgOiBUaGlzIGZsYWcgY29udGFpbnMgdGhlIHRhcmdldCBvZiB0aGUgYXNzZXJ0aW9uLiBGb3IgZXhhbXBsZSwgaW5cbiAgICogICB0aGUgYXNzZXJ0aW9uIGBleHBlY3QobnVtS2l0dGVucykudG8uZXF1YWwoNyk7YCwgdGhlIGBvYmplY3RgIGZsYWcgd2lsbFxuICAgKiAgIGNvbnRhaW4gYG51bUtpdHRlbnNgIHNvIHRoYXQgdGhlIGBlcXVhbGAgYXNzZXJ0aW9uIGNhbiByZWZlcmVuY2UgaXQgd2hlblxuICAgKiAgIG5lZWRlZC5cbiAgICpcbiAgICogLSBgbWVzc2FnZWA6IFRoaXMgZmxhZyBjb250YWlucyBhbiBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZSB0byBiZVxuICAgKiAgIHByZXBlbmRlZCB0byB0aGUgZXJyb3IgbWVzc2FnZSB0aGF0J3MgZ2VuZXJhdGVkIGJ5IHRoZSBhc3NlcnRpb24gd2hlbiBpdFxuICAgKiAgIGZhaWxzLlxuICAgKlxuICAgKiAtIGBzc2ZpYDogVGhpcyBmbGFnIHN0YW5kcyBmb3IgXCJzdGFydCBzdGFjayBmdW5jdGlvbiBpbmRpY2F0b3JcIi4gSXRcbiAgICogICBjb250YWlucyBhIGZ1bmN0aW9uIHJlZmVyZW5jZSB0aGF0IHNlcnZlcyBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yXG4gICAqICAgcmVtb3ZpbmcgZnJhbWVzIGZyb20gdGhlIHN0YWNrIHRyYWNlIG9mIHRoZSBlcnJvciB0aGF0J3MgY3JlYXRlZCBieSB0aGVcbiAgICogICBhc3NlcnRpb24gd2hlbiBpdCBmYWlscy4gVGhlIGdvYWwgaXMgdG8gcHJvdmlkZSBhIGNsZWFuZXIgc3RhY2sgdHJhY2UgdG9cbiAgICogICBlbmQgdXNlcnMgYnkgcmVtb3ZpbmcgQ2hhaSdzIGludGVybmFsIGZ1bmN0aW9ucy4gTm90ZSB0aGF0IGl0IG9ubHkgd29ya3NcbiAgICogICBpbiBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IGBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZWAsIGFuZCBvbmx5IHdoZW5cbiAgICogICBgQ2hhaS5jb25maWcuaW5jbHVkZVN0YWNrYCBoYXNuJ3QgYmVlbiBzZXQgdG8gYGZhbHNlYC5cbiAgICpcbiAgICogLSBgbG9ja1NzZmlgOiBUaGlzIGZsYWcgY29udHJvbHMgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIGBzc2ZpYCBmbGFnXG4gICAqICAgc2hvdWxkIHJldGFpbiBpdHMgY3VycmVudCB2YWx1ZSwgZXZlbiBhcyBhc3NlcnRpb25zIGFyZSBjaGFpbmVkIG9mZiBvZlxuICAgKiAgIHRoaXMgb2JqZWN0LiBUaGlzIGlzIHVzdWFsbHkgc2V0IHRvIGB0cnVlYCB3aGVuIGNyZWF0aW5nIGEgbmV3IGFzc2VydGlvblxuICAgKiAgIGZyb20gd2l0aGluIGFub3RoZXIgYXNzZXJ0aW9uLiBJdCdzIGFsc28gdGVtcG9yYXJpbHkgc2V0IHRvIGB0cnVlYCBiZWZvcmVcbiAgICogICBhbiBvdmVyd3JpdHRlbiBhc3NlcnRpb24gZ2V0cyBjYWxsZWQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqIHRhcmdldCBvZiB0aGUgYXNzZXJ0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgKG9wdGlvbmFsKSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzc2ZpIChvcHRpb25hbCkgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIHN0YWNrIGZyYW1lc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxvY2tTc2ZpIChvcHRpb25hbCkgd2hldGhlciBvciBub3QgdGhlIHNzZmkgZmxhZyBpcyBsb2NrZWRcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEFzc2VydGlvbiAob2JqLCBtc2csIHNzZmksIGxvY2tTc2ZpKSB7XG4gICAgZmxhZyh0aGlzLCAnc3NmaScsIHNzZmkgfHwgQXNzZXJ0aW9uKTtcbiAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIGxvY2tTc2ZpKTtcbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBvYmopO1xuICAgIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuXG4gICAgcmV0dXJuIHV0aWwucHJveGlmeSh0aGlzKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24sICdpbmNsdWRlU3RhY2snLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLmluY2x1ZGVTdGFjayBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gY29uZmlnLmluY2x1ZGVTdGFjaztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLmluY2x1ZGVTdGFjayBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrIGluc3RlYWQuJyk7XG4gICAgICBjb25maWcuaW5jbHVkZVN0YWNrID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLCAnc2hvd0RpZmYnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLnNob3dEaWZmIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5zaG93RGlmZiBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIGNvbmZpZy5zaG93RGlmZjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLnNob3dEaWZmIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5zaG93RGlmZiBpbnN0ZWFkLicpO1xuICAgICAgY29uZmlnLnNob3dEaWZmID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLmFkZFByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwuYWRkTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcikge1xuICAgIHV0aWwuYWRkQ2hhaW5hYmxlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLm92ZXJ3cml0ZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgICB1dGlsLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmFzc2VydChleHByZXNzaW9uLCBtZXNzYWdlLCBuZWdhdGVNZXNzYWdlLCBleHBlY3RlZCwgYWN0dWFsLCBzaG93RGlmZilcbiAgICpcbiAgICogRXhlY3V0ZXMgYW4gZXhwcmVzc2lvbiBhbmQgY2hlY2sgZXhwZWN0YXRpb25zLiBUaHJvd3MgQXNzZXJ0aW9uRXJyb3IgZm9yIHJlcG9ydGluZyBpZiB0ZXN0IGRvZXNuJ3QgcGFzcy5cbiAgICpcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBwYXJhbSB7UGhpbG9zb3BoaWNhbH0gZXhwcmVzc2lvbiB0byBiZSB0ZXN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IG1lc3NhZ2Ugb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG1lc3NhZ2UgdG8gZGlzcGxheSBpZiBleHByZXNzaW9uIGZhaWxzXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBuZWdhdGVkTWVzc2FnZSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgbmVnYXRlZE1lc3NhZ2UgdG8gZGlzcGxheSBpZiBuZWdhdGVkIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWQgdmFsdWUgKHJlbWVtYmVyIHRvIGNoZWNrIGZvciBuZWdhdGlvbilcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsIChvcHRpb25hbCkgd2lsbCBkZWZhdWx0IHRvIGB0aGlzLm9iamBcbiAgICogQHBhcmFtIHtCb29sZWFufSBzaG93RGlmZiAob3B0aW9uYWwpIHdoZW4gc2V0IHRvIGB0cnVlYCwgYXNzZXJ0IHdpbGwgZGlzcGxheSBhIGRpZmYgaW4gYWRkaXRpb24gdG8gdGhlIG1lc3NhZ2UgaWYgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgPSBmdW5jdGlvbiAoZXhwciwgbXNnLCBuZWdhdGVNc2csIGV4cGVjdGVkLCBfYWN0dWFsLCBzaG93RGlmZikge1xuICAgIHZhciBvayA9IHV0aWwudGVzdCh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChmYWxzZSAhPT0gc2hvd0RpZmYpIHNob3dEaWZmID0gdHJ1ZTtcbiAgICBpZiAodW5kZWZpbmVkID09PSBleHBlY3RlZCAmJiB1bmRlZmluZWQgPT09IF9hY3R1YWwpIHNob3dEaWZmID0gZmFsc2U7XG4gICAgaWYgKHRydWUgIT09IGNvbmZpZy5zaG93RGlmZikgc2hvd0RpZmYgPSBmYWxzZTtcblxuICAgIGlmICghb2spIHtcbiAgICAgIG1zZyA9IHV0aWwuZ2V0TWVzc2FnZSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdmFyIGFjdHVhbCA9IHV0aWwuZ2V0QWN0dWFsKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnLCB7XG4gICAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgLCBzaG93RGlmZjogc2hvd0RpZmZcbiAgICAgIH0sIChjb25maWcuaW5jbHVkZVN0YWNrKSA/IHRoaXMuYXNzZXJ0IDogZmxhZyh0aGlzLCAnc3NmaScpKTtcbiAgICB9XG4gIH07XG5cbiAgLyohXG4gICAqICMjIyAuX29ialxuICAgKlxuICAgKiBRdWljayByZWZlcmVuY2UgdG8gc3RvcmVkIGBhY3R1YWxgIHZhbHVlIGZvciBwbHVnaW4gZGV2ZWxvcGVycy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24ucHJvdG90eXBlLCAnX29iaicsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgICAgfVxuICAgICwgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbCk7XG4gICAgICB9XG4gIH0pO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogaHR0cDovL2NoYWlqcy5jb21cbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCBfKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgQXNzZXJ0aW9uRXJyb3IgPSBjaGFpLkFzc2VydGlvbkVycm9yXG4gICAgLCBmbGFnID0gXy5mbGFnO1xuXG4gIC8qKlxuICAgKiAjIyMgTGFuZ3VhZ2UgQ2hhaW5zXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgYXJlIHByb3ZpZGVkIGFzIGNoYWluYWJsZSBnZXR0ZXJzIHRvIGltcHJvdmUgdGhlIHJlYWRhYmlsaXR5XG4gICAqIG9mIHlvdXIgYXNzZXJ0aW9ucy5cbiAgICpcbiAgICogKipDaGFpbnMqKlxuICAgKlxuICAgKiAtIHRvXG4gICAqIC0gYmVcbiAgICogLSBiZWVuXG4gICAqIC0gaXNcbiAgICogLSB0aGF0XG4gICAqIC0gd2hpY2hcbiAgICogLSBhbmRcbiAgICogLSBoYXNcbiAgICogLSBoYXZlXG4gICAqIC0gd2l0aFxuICAgKiAtIGF0XG4gICAqIC0gb2ZcbiAgICogLSBzYW1lXG4gICAqIC0gYnV0XG4gICAqIC0gZG9lc1xuICAgKiAtIHN0aWxsXG4gICAqXG4gICAqIEBuYW1lIGxhbmd1YWdlIGNoYWluc1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBbICd0bycsICdiZScsICdiZWVuJywgJ2lzJ1xuICAsICdhbmQnLCAnaGFzJywgJ2hhdmUnLCAnd2l0aCdcbiAgLCAndGhhdCcsICd3aGljaCcsICdhdCcsICdvZidcbiAgLCAnc2FtZScsICdidXQnLCAnZG9lcycsICdzdGlsbCcgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIEFzc2VydGlvbi5hZGRQcm9wZXJ0eShjaGFpbik7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFxuICAgKlxuICAgKiBOZWdhdGVzIGFsbCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogICAgIGV4cGVjdChmdW5jdGlvbiAoKSB7fSkudG8ubm90LnRocm93KCk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgnYicpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uYmUuYW4oJ2FycmF5JykudGhhdC5kb2VzLm5vdC5pbmNsdWRlKDMpO1xuICAgKlxuICAgKiBKdXN0IGJlY2F1c2UgeW91IGNhbiBuZWdhdGUgYW55IGFzc2VydGlvbiB3aXRoIGAubm90YCBkb2Vzbid0IG1lYW4geW91XG4gICAqIHNob3VsZC4gV2l0aCBncmVhdCBwb3dlciBjb21lcyBncmVhdCByZXNwb25zaWJpbGl0eS4gSXQncyBvZnRlbiBiZXN0IHRvXG4gICAqIGFzc2VydCB0aGF0IHRoZSBvbmUgZXhwZWN0ZWQgb3V0cHV0IHdhcyBwcm9kdWNlZCwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nXG4gICAqIHRoYXQgb25lIG9mIGNvdW50bGVzcyB1bmV4cGVjdGVkIG91dHB1dHMgd2Fzbid0IHByb2R1Y2VkLiBTZWUgaW5kaXZpZHVhbFxuICAgKiBhc3NlcnRpb25zIGZvciBzcGVjaWZpYyBndWlkYW5jZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5ub3QuZXF1YWwoMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBAbmFtZSBub3RcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdub3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnbmVnYXRlJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBcbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLmVxdWFsYCwgYC5pbmNsdWRlYCwgYC5tZW1iZXJzYCwgYC5rZXlzYCwgYW5kIGAucHJvcGVydHlgXG4gICAqIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIHVzZSBkZWVwIGVxdWFsaXR5IGluc3RlYWQgb2Ygc3RyaWN0XG4gICAqIChgPT09YCkgZXF1YWxpdHkuIFNlZSB0aGUgYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXBcbiAgICogZXF1YWxpdHkgYWxnb3JpdGhtOiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGVxdWFscyBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZGVlcC5lcXVhbCh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmVxdWFsKHthOiAxfSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBpbmNsdWRlcyBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5kZWVwLmluY2x1ZGUoe2E6IDF9KTtcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8ubm90LmluY2x1ZGUoe2E6IDF9KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBpbmNsdWRlcyBgeDoge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5kZWVwLmluY2x1ZGUoe3g6IHthOiAxfX0pO1xuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5ub3QuaW5jbHVkZSh7eDoge2E6IDF9fSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMgbWVtYmVyIGB7YTogMX1gXG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLmhhdmUuZGVlcC5tZW1iZXJzKFt7YTogMX1dKTtcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8ubm90LmhhdmUubWVtYmVycyhbe2E6IDF9XSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgc2V0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaGFzIGtleSBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoW3thOiAxfV0pKS50by5oYXZlLmRlZXAua2V5cyhbe2E6IDF9XSk7XG4gICAqICAgICBleHBlY3QobmV3IFNldChbe2E6IDF9XSkpLnRvLm5vdC5oYXZlLmtleXMoW3thOiAxfV0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBwcm9wZXJ0eSBgeDoge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5oYXZlLmRlZXAucHJvcGVydHkoJ3gnLCB7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgneCcsIHthOiAxfSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdkZWVwJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ2RlZXAnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAubmVzdGVkXG4gICAqXG4gICAqIEVuYWJsZXMgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBpbiBhbGwgYC5wcm9wZXJ0eWAgYW5kIGAuaW5jbHVkZWBcbiAgICogYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4uXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbJ3gnLCAneSddfX0pLnRvLmhhdmUubmVzdGVkLnByb3BlcnR5KCdhLmJbMV0nKTtcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFsneCcsICd5J119fSkudG8ubmVzdGVkLmluY2x1ZGUoeydhLmJbMV0nOiAneSd9KTtcbiAgICpcbiAgICogSWYgYC5gIG9yIGBbXWAgYXJlIHBhcnQgb2YgYW4gYWN0dWFsIHByb3BlcnR5IG5hbWUsIHRoZXkgY2FuIGJlIGVzY2FwZWQgYnlcbiAgICogYWRkaW5nIHR3byBiYWNrc2xhc2hlcyBiZWZvcmUgdGhlbS5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7Jy5hJzogeydbYl0nOiAneCd9fSkudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkoJ1xcXFwuYS5cXFxcW2JcXFxcXScpO1xuICAgKiAgICAgZXhwZWN0KHsnLmEnOiB7J1tiXSc6ICd4J319KS50by5uZXN0ZWQuaW5jbHVkZSh7J1xcXFwuYS5cXFxcW2JcXFxcXSc6ICd4J30pO1xuICAgKlxuICAgKiBgLm5lc3RlZGAgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggYC5vd25gLlxuICAgKlxuICAgKiBAbmFtZSBuZXN0ZWRcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCduZXN0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnbmVzdGVkJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm93blxuICAgKlxuICAgKiBDYXVzZXMgYWxsIGAucHJvcGVydHlgIGFuZCBgLmluY2x1ZGVgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluXG4gICAqIHRvIGlnbm9yZSBpbmhlcml0ZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogICAgIE9iamVjdC5wcm90b3R5cGUuYiA9IDI7XG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93bi5wcm9wZXJ0eSgnYScpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYicpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmhhdmUub3duLnByb3BlcnR5KCdiJyk7XG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5vd24uaW5jbHVkZSh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaW5jbHVkZSh7YjogMn0pLmJ1dC5ub3Qub3duLmluY2x1ZGUoe2I6IDJ9KTtcbiAgICpcbiAgICogYC5vd25gIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIGAubmVzdGVkYC5cbiAgICpcbiAgICogQG5hbWUgb3duXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnb3duJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ293bicsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5vcmRlcmVkXG4gICAqXG4gICAqIENhdXNlcyBhbGwgYC5tZW1iZXJzYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byByZXF1aXJlIHRoYXRcbiAgICogbWVtYmVycyBiZSBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLmhhdmUub3JkZXJlZC5tZW1iZXJzKFsxLCAyXSlcbiAgICogICAgICAgLmJ1dC5ub3QuaGF2ZS5vcmRlcmVkLm1lbWJlcnMoWzIsIDFdKTtcbiAgICpcbiAgICogV2hlbiBgLmluY2x1ZGVgIGFuZCBgLm9yZGVyZWRgIGFyZSBjb21iaW5lZCwgdGhlIG9yZGVyaW5nIGJlZ2lucyBhdCB0aGVcbiAgICogc3RhcnQgb2YgYm90aCBhcnJheXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm9yZGVyZWQubWVtYmVycyhbMSwgMl0pXG4gICAqICAgICAgIC5idXQubm90LmluY2x1ZGUub3JkZXJlZC5tZW1iZXJzKFsyLCAzXSk7XG4gICAqXG4gICAqIEBuYW1lIG9yZGVyZWRcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdvcmRlcmVkJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ29yZGVyZWQnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuYW55XG4gICAqXG4gICAqIENhdXNlcyBhbGwgYC5rZXlzYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byBvbmx5IHJlcXVpcmUgdGhhdFxuICAgKiB0aGUgdGFyZ2V0IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBnaXZlbiBrZXlzLiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZlxuICAgKiBgLmFsbGAsIHdoaWNoIHJlcXVpcmVzIHRoYXQgdGhlIHRhcmdldCBoYXZlIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLm5vdC5oYXZlLmFueS5rZXlzKCdjJywgJ2QnKTtcbiAgICpcbiAgICogU2VlIHRoZSBgLmtleXNgIGRvYyBmb3IgZ3VpZGFuY2Ugb24gd2hlbiB0byB1c2UgYC5hbnlgIG9yIGAuYWxsYC5cbiAgICpcbiAgICogQG5hbWUgYW55XG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnYW55JywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ2FueScsIHRydWUpO1xuICAgIGZsYWcodGhpcywgJ2FsbCcsIGZhbHNlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuYWxsXG4gICAqXG4gICAqIENhdXNlcyBhbGwgYC5rZXlzYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byByZXF1aXJlIHRoYXQgdGhlXG4gICAqIHRhcmdldCBoYXZlIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cy4gVGhpcyBpcyB0aGUgb3Bwb3NpdGUgb2YgYC5hbnlgLCB3aGljaFxuICAgKiBvbmx5IHJlcXVpcmVzIHRoYXQgdGhlIHRhcmdldCBoYXZlIGF0IGxlYXN0IG9uZSBvZiB0aGUgZ2l2ZW4ga2V5cy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBOb3RlIHRoYXQgYC5hbGxgIGlzIHVzZWQgYnkgZGVmYXVsdCB3aGVuIG5laXRoZXIgYC5hbGxgIG5vciBgLmFueWAgYXJlXG4gICAqIGFkZGVkIGVhcmxpZXIgaW4gdGhlIGNoYWluLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYWRkIGAuYWxsYCBhbnl3YXlcbiAgICogYmVjYXVzZSBpdCBpbXByb3ZlcyByZWFkYWJpbGl0eS5cbiAgICpcbiAgICogU2VlIHRoZSBgLmtleXNgIGRvYyBmb3IgZ3VpZGFuY2Ugb24gd2hlbiB0byB1c2UgYC5hbnlgIG9yIGAuYWxsYC5cbiAgICpcbiAgICogQG5hbWUgYWxsXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnYWxsJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ2FsbCcsIHRydWUpO1xuICAgIGZsYWcodGhpcywgJ2FueScsIGZhbHNlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuYSh0eXBlWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQncyB0eXBlIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiBzdHJpbmcgYHR5cGVgLiBUeXBlc1xuICAgKiBhcmUgY2FzZSBpbnNlbnNpdGl2ZS4gU2VlIHRoZSBgdHlwZS1kZXRlY3RgIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGVcbiAgICogdHlwZSBkZXRlY3Rpb24gYWxnb3JpdGhtOiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL3R5cGUtZGV0ZWN0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmJlLmFuKCdvYmplY3QnKTtcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5hKCdudWxsJyk7XG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS5hbigndW5kZWZpbmVkJyk7XG4gICAqICAgICBleHBlY3QobmV3IEVycm9yKS50by5iZS5hbignZXJyb3InKTtcbiAgICogICAgIGV4cGVjdChQcm9taXNlLnJlc29sdmUoKSkudG8uYmUuYSgncHJvbWlzZScpO1xuICAgKiAgICAgZXhwZWN0KG5ldyBGbG9hdDMyQXJyYXkpLnRvLmJlLmEoJ2Zsb2F0MzJhcnJheScpO1xuICAgKiAgICAgZXhwZWN0KFN5bWJvbCgpKS50by5iZS5hKCdzeW1ib2wnKTtcbiAgICpcbiAgICogYC5hYCBzdXBwb3J0cyBvYmplY3RzIHRoYXQgaGF2ZSBhIGN1c3RvbSB0eXBlIHNldCB2aWEgYFN5bWJvbC50b1N0cmluZ1RhZ2AuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7XG4gICAqICAgICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnbXlDdXN0b21UeXBlJ1xuICAgKiAgICAgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChteU9iaikudG8uYmUuYSgnbXlDdXN0b21UeXBlJykuYnV0Lm5vdC5hbignb2JqZWN0Jyk7XG4gICAqXG4gICAqIEl0J3Mgb2Z0ZW4gYmVzdCB0byB1c2UgYC5hYCB0byBjaGVjayBhIHRhcmdldCdzIHR5cGUgYmVmb3JlIG1ha2luZyBtb3JlXG4gICAqIGFzc2VydGlvbnMgb24gdGhlIHNhbWUgdGFyZ2V0LiBUaGF0IHdheSwgeW91IGF2b2lkIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZnJvbVxuICAgKiBhbnkgYXNzZXJ0aW9uIHRoYXQgZG9lcyBkaWZmZXJlbnQgdGhpbmdzIGJhc2VkIG9uIHRoZSB0YXJnZXQncyB0eXBlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uYmUuYW4oJ2FycmF5JykudGhhdC5pbmNsdWRlcygyKTtcbiAgICogICAgIGV4cGVjdChbXSkudG8uYmUuYW4oJ2FycmF5JykudGhhdC5pcy5lbXB0eTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5hYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvXG4gICAqIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgdGhlIGV4cGVjdGVkIHR5cGUsIHJhdGhlciB0aGFuIGFzc2VydGluZyB0aGF0IGl0XG4gICAqIGlzbid0IG9uZSBvZiBtYW55IHVuZXhwZWN0ZWQgdHlwZXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmJlLmEoJ3N0cmluZycpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5ub3QuYmUuYW4oJ2FycmF5Jyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmFgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZSB0b1xuICAgKiBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZFxuICAgKiBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5hKCdzdHJpbmcnLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmEoJ3N0cmluZycpO1xuICAgKlxuICAgKiBgLmFgIGNhbiBhbHNvIGJlIHVzZWQgYXMgYSBsYW5ndWFnZSBjaGFpbiB0byBpbXByb3ZlIHRoZSByZWFkYWJpbGl0eSBvZlxuICAgKiB5b3VyIGFzc2VydGlvbnMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2I6IDJ9KS50by5oYXZlLmEucHJvcGVydHkoJ2InKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuYW5gIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuYWAuXG4gICAqXG4gICAqIEBuYW1lIGFcbiAgICogQGFsaWFzIGFuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhbiAodHlwZSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgYXJ0aWNsZSA9IH5bICdhJywgJ2UnLCAnaScsICdvJywgJ3UnIF0uaW5kZXhPZih0eXBlLmNoYXJBdCgwKSkgPyAnYW4gJyA6ICdhICc7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdHlwZSA9PT0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSAnICsgYXJ0aWNsZSArIHR5cGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhbicsIGFuKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnYScsIGFuKTtcblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlKHZhbFssIG1zZ10pXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIHN0cmluZywgYC5pbmNsdWRlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIHN0cmluZyBgdmFsYFxuICAgKiBpcyBhIHN1YnN0cmluZyBvZiB0aGUgdGFyZ2V0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5pbmNsdWRlKCdmb28nKTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGFuIGFycmF5LCBgLmluY2x1ZGVgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gYHZhbGAgaXMgYVxuICAgKiBtZW1iZXIgb2YgdGhlIHRhcmdldC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUoMik7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhbiBvYmplY3QsIGAuaW5jbHVkZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBvYmplY3RcbiAgICogYHZhbGAncyBwcm9wZXJ0aWVzIGFyZSBhIHN1YnNldCBvZiB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMiwgYzogM30pLnRvLmluY2x1ZGUoe2E6IDEsIGI6IDJ9KTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgU2V0IG9yIFdlYWtTZXQsIGAuaW5jbHVkZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgdmFsYCBpcyBhXG4gICAqIG1lbWJlciBvZiB0aGUgdGFyZ2V0LiBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobSBpcyB1c2VkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoWzEsIDJdKSkudG8uaW5jbHVkZSgyKTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgTWFwLCBgLmluY2x1ZGVgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gYHZhbGAgaXMgb25lIG9mXG4gICAqIHRoZSB2YWx1ZXMgb2YgdGhlIHRhcmdldC4gU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG0gaXMgdXNlZC5cbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgTWFwKFtbJ2EnLCAxXSwgWydiJywgMl1dKSkudG8uaW5jbHVkZSgyKTtcbiAgICpcbiAgICogQmVjYXVzZSBgLmluY2x1ZGVgIGRvZXMgZGlmZmVyZW50IHRoaW5ncyBiYXNlZCBvbiB0aGUgdGFyZ2V0J3MgdHlwZSwgaXQnc1xuICAgKiBpbXBvcnRhbnQgdG8gY2hlY2sgdGhlIHRhcmdldCdzIHR5cGUgYmVmb3JlIHVzaW5nIGAuaW5jbHVkZWAuIFNlZSB0aGUgYC5hYFxuICAgKiBkb2MgZm9yIGluZm8gb24gdGVzdGluZyBhIHRhcmdldCdzIHR5cGUuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5iZS5hbignYXJyYXknKS50aGF0LmluY2x1ZGVzKDIpO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBzdHJpY3QgKGA9PT1gKSBlcXVhbGl0eSBpcyB1c2VkIHRvIGNvbXBhcmUgYXJyYXkgbWVtYmVycyBhbmRcbiAgICogb2JqZWN0IHByb3BlcnRpZXMuIEFkZCBgLmRlZXBgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIHVzZSBkZWVwIGVxdWFsaXR5XG4gICAqIGluc3RlYWQgKFdlYWtTZXQgdGFyZ2V0cyBhcmUgbm90IHN1cHBvcnRlZCkuIFNlZSB0aGUgYGRlZXAtZXFsYCBwcm9qZWN0XG4gICAqIHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaW5jbHVkZXMgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8uZGVlcC5pbmNsdWRlKHthOiAxfSk7XG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLm5vdC5pbmNsdWRlKHthOiAxfSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaW5jbHVkZXMgYHg6IHthOiAxfWBcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8uZGVlcC5pbmNsdWRlKHt4OiB7YTogMX19KTtcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8ubm90LmluY2x1ZGUoe3g6IHthOiAxfX0pO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhbGwgb2YgdGhlIHRhcmdldCdzIHByb3BlcnRpZXMgYXJlIHNlYXJjaGVkIHdoZW4gd29ya2luZyB3aXRoXG4gICAqIG9iamVjdHMuIFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IGFyZSBpbmhlcml0ZWQgYW5kL29yIG5vbi1lbnVtZXJhYmxlLlxuICAgKiBBZGQgYC5vd25gIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGV4Y2x1ZGUgdGhlIHRhcmdldCdzIGluaGVyaXRlZFxuICAgKiBwcm9wZXJ0aWVzIGZyb20gdGhlIHNlYXJjaC5cbiAgICpcbiAgICogICAgIE9iamVjdC5wcm90b3R5cGUuYiA9IDI7XG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5vd24uaW5jbHVkZSh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaW5jbHVkZSh7YjogMn0pLmJ1dC5ub3Qub3duLmluY2x1ZGUoe2I6IDJ9KTtcbiAgICpcbiAgICogTm90ZSB0aGF0IGEgdGFyZ2V0IG9iamVjdCBpcyBhbHdheXMgb25seSBzZWFyY2hlZCBmb3IgYHZhbGAncyBvd25cbiAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBgLmRlZXBgIGFuZCBgLm93bmAgY2FuIGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogMn19KS50by5kZWVwLm93bi5pbmNsdWRlKHthOiB7YjogMn19KTtcbiAgICpcbiAgICogQWRkIGAubmVzdGVkYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBlbmFibGUgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiB3aGVuXG4gICAqIHJlZmVyZW5jaW5nIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5uZXN0ZWQuaW5jbHVkZSh7J2EuYlsxXSc6ICd5J30pO1xuICAgKlxuICAgKiBJZiBgLmAgb3IgYFtdYCBhcmUgcGFydCBvZiBhbiBhY3R1YWwgcHJvcGVydHkgbmFtZSwgdGhleSBjYW4gYmUgZXNjYXBlZCBieVxuICAgKiBhZGRpbmcgdHdvIGJhY2tzbGFzaGVzIGJlZm9yZSB0aGVtLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsnLmEnOiB7J1tiXSc6IDJ9fSkudG8ubmVzdGVkLmluY2x1ZGUoeydcXFxcLmEuXFxcXFtiXFxcXF0nOiAyfSk7XG4gICAqXG4gICAqIGAuZGVlcGAgYW5kIGAubmVzdGVkYCBjYW4gYmUgY29tYmluZWQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbe2M6IDN9XX19KS50by5kZWVwLm5lc3RlZC5pbmNsdWRlKHsnYS5iWzBdJzoge2M6IDN9fSk7XG4gICAqXG4gICAqIGAub3duYCBhbmQgYC5uZXN0ZWRgIGNhbm5vdCBiZSBjb21iaW5lZC5cbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5pbmNsdWRlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubm90LmluY2x1ZGUoJ3RhY28nKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLm5vdC5pbmNsdWRlKDQpO1xuICAgKlxuICAgKiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byBuZWdhdGUgYC5pbmNsdWRlYCB3aGVuIHRoZSB0YXJnZXQgaXMgYW4gb2JqZWN0LlxuICAgKiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9ucyBieSBhc3NlcnRpbmcgdGhhdCB0aGVcbiAgICogdGFyZ2V0IG9iamVjdCBkb2Vzbid0IGhhdmUgYWxsIG9mIGB2YWxgJ3Mga2V5L3ZhbHVlIHBhaXJzIGJ1dCBtYXkgb3IgbWF5XG4gICAqIG5vdCBoYXZlIHNvbWUgb2YgdGhlbS4gSXQncyBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzXG4gICAqIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhbiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBvYmplY3QgaXNuJ3QgZXZlbiBleHBlY3RlZCB0byBoYXZlIGB2YWxgJ3Mga2V5cywgaXQnc1xuICAgKiBvZnRlbiBiZXN0IHRvIGFzc2VydCBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2M6IDN9KS50by5ub3QuaGF2ZS5hbnkua2V5cygnYScsICdiJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2M6IDN9KS50by5ub3QuaW5jbHVkZSh7YTogMSwgYjogMn0pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIGB2YWxgJ3Mga2V5cywgaXQncyBvZnRlbiBiZXN0IHRvXG4gICAqIGFzc2VydCB0aGF0IGVhY2ggb2YgdGhlIHByb3BlcnRpZXMgaGFzIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyIHRoYW5cbiAgICogYXNzZXJ0aW5nIHRoYXQgZWFjaCBwcm9wZXJ0eSBkb2Vzbid0IGhhdmUgb25lIG9mIG1hbnkgdW5leHBlY3RlZCB2YWx1ZXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDMsIGI6IDR9KS50by5pbmNsdWRlKHthOiAzLCBiOiA0fSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDMsIGI6IDR9KS50by5ub3QuaW5jbHVkZSh7YTogMSwgYjogMn0pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5pbmNsdWRlYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlKDQsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10sICdub29vIHdoeSBmYWlsPz8nKS50by5pbmNsdWRlKDQpO1xuICAgKlxuICAgKiBgLmluY2x1ZGVgIGNhbiBhbHNvIGJlIHVzZWQgYXMgYSBsYW5ndWFnZSBjaGFpbiwgY2F1c2luZyBhbGwgYC5tZW1iZXJzYCBhbmRcbiAgICogYC5rZXlzYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byByZXF1aXJlIHRoZSB0YXJnZXQgdG8gYmUgYVxuICAgKiBzdXBlcnNldCBvZiB0aGUgZXhwZWN0ZWQgc2V0LCByYXRoZXIgdGhhbiBhbiBpZGVudGljYWwgc2V0LiBOb3RlIHRoYXRcbiAgICogYC5tZW1iZXJzYCBpZ25vcmVzIGR1cGxpY2F0ZXMgaW4gdGhlIHN1YnNldCB3aGVuIGAuaW5jbHVkZWAgaXMgYWRkZWQuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0J3Mga2V5cyBhcmUgYSBzdXBlcnNldCBvZiBbJ2EnLCAnYiddIGJ1dCBub3QgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDIsIGM6IDN9KS50by5pbmNsdWRlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMiwgYzogM30pLnRvLm5vdC5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBpcyBhIHN1cGVyc2V0IG9mIFsxLCAyXSBidXQgbm90IGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5tZW1iZXJzKFsxLCAyXSk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5ub3QuaGF2ZS5tZW1iZXJzKFsxLCAyXSk7XG4gICAqXG4gICAqICAgICAvLyBEdXBsaWNhdGVzIGluIHRoZSBzdWJzZXQgYXJlIGlnbm9yZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUubWVtYmVycyhbMSwgMiwgMiwgMl0pO1xuICAgKlxuICAgKiBOb3RlIHRoYXQgYWRkaW5nIGAuYW55YCBlYXJsaWVyIGluIHRoZSBjaGFpbiBjYXVzZXMgdGhlIGAua2V5c2AgYXNzZXJ0aW9uXG4gICAqIHRvIGlnbm9yZSBgLmluY2x1ZGVgLlxuICAgKlxuICAgKiAgICAgLy8gQm90aCBhc3NlcnRpb25zIGFyZSBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmluY2x1ZGUuYW55LmtleXMoJ2EnLCAnYicpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5hbnkua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIFRoZSBhbGlhc2VzIGAuaW5jbHVkZXNgLCBgLmNvbnRhaW5gLCBhbmQgYC5jb250YWluc2AgY2FuIGJlIHVzZWRcbiAgICogaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5pbmNsdWRlYC5cbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZVxuICAgKiBAYWxpYXMgY29udGFpblxuICAgKiBAYWxpYXMgaW5jbHVkZXNcbiAgICogQGFsaWFzIGNvbnRhaW5zXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gU2FtZVZhbHVlWmVybyhhLCBiKSB7XG4gICAgcmV0dXJuIChfLmlzTmFOKGEpICYmIF8uaXNOYU4oYikpIHx8IGEgPT09IGI7XG4gIH1cblxuICBmdW5jdGlvbiBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvciAoKSB7XG4gICAgZmxhZyh0aGlzLCAnY29udGFpbnMnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBuZWdhdGUgPSBmbGFnKHRoaXMsICduZWdhdGUnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIGlzRGVlcCA9IGZsYWcodGhpcywgJ2RlZXAnKVxuICAgICAgLCBkZXNjcmlwdG9yID0gaXNEZWVwID8gJ2RlZXAgJyA6ICcnO1xuXG4gICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuXG4gICAgdmFyIGluY2x1ZGVkID0gZmFsc2U7XG5cbiAgICBzd2l0Y2ggKG9ialR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGluY2x1ZGVkID0gb2JqLmluZGV4T2YodmFsKSAhPT0gLTE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd3ZWFrc2V0JzpcbiAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICAgIGZsYWdNc2cgKyAndW5hYmxlIHRvIHVzZSAuZGVlcC5pbmNsdWRlIHdpdGggV2Vha1NldCcsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBzc2ZpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluY2x1ZGVkID0gb2JqLmhhcyh2YWwpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgdmFyIGlzRXFsID0gaXNEZWVwID8gXy5lcWwgOiBTYW1lVmFsdWVaZXJvO1xuICAgICAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIGluY2x1ZGVkID0gaW5jbHVkZWQgfHwgaXNFcWwoaXRlbSwgdmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzZXQnOlxuICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGluY2x1ZGVkID0gaW5jbHVkZWQgfHwgXy5lcWwoaXRlbSwgdmFsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmNsdWRlZCA9IG9iai5oYXModmFsKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgaW5jbHVkZWQgPSBvYmouc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZXFsKGl0ZW0sIHZhbCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmNsdWRlZCA9IG9iai5pbmRleE9mKHZhbCkgIT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBUaGlzIGJsb2NrIGlzIGZvciBhc3NlcnRpbmcgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBvYmplY3QuXG4gICAgICAgIC8vIGBfLmV4cGVjdFR5cGVzYCBpc24ndCB1c2VkIGhlcmUgYmVjYXVzZSBgLmluY2x1ZGVgIHNob3VsZCB3b3JrIHdpdGhcbiAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGEgY3VzdG9tIGBAQHRvU3RyaW5nVGFnYC5cbiAgICAgICAgaWYgKHZhbCAhPT0gT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgICBmbGFnTXNnICsgJ29iamVjdCB0ZXN0ZWQgbXVzdCBiZSBhbiBhcnJheSwgYSBtYXAsIGFuIG9iamVjdCwnXG4gICAgICAgICAgICAgICsgJyBhIHNldCwgYSBzdHJpbmcsIG9yIGEgd2Vha3NldCwgYnV0ICcgKyBvYmpUeXBlICsgJyBnaXZlbicsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBzc2ZpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbClcbiAgICAgICAgICAsIGZpcnN0RXJyID0gbnVsbFxuICAgICAgICAgICwgbnVtRXJycyA9IDA7XG5cbiAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIHZhciBwcm9wQXNzZXJ0aW9uID0gbmV3IEFzc2VydGlvbihvYmopO1xuICAgICAgICAgIF8udHJhbnNmZXJGbGFncyh0aGlzLCBwcm9wQXNzZXJ0aW9uLCB0cnVlKTtcbiAgICAgICAgICBmbGFnKHByb3BBc3NlcnRpb24sICdsb2NrU3NmaScsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKCFuZWdhdGUgfHwgcHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBwcm9wQXNzZXJ0aW9uLnByb3BlcnR5KHByb3AsIHZhbFtwcm9wXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb3BBc3NlcnRpb24ucHJvcGVydHkocHJvcCwgdmFsW3Byb3BdKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICghXy5jaGVja0Vycm9yLmNvbXBhdGlibGVDb25zdHJ1Y3RvcihlcnIsIEFzc2VydGlvbkVycm9yKSkge1xuICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RFcnIgPT09IG51bGwpIGZpcnN0RXJyID0gZXJyO1xuICAgICAgICAgICAgbnVtRXJycysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gV2hlbiB2YWxpZGF0aW5nIC5ub3QuaW5jbHVkZSB3aXRoIG11bHRpcGxlIHByb3BlcnRpZXMsIHdlIG9ubHkgd2FudFxuICAgICAgICAvLyB0byB0aHJvdyBhbiBhc3NlcnRpb24gZXJyb3IgaWYgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGFyZSBpbmNsdWRlZCxcbiAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSB0aHJvdyB0aGUgZmlyc3QgcHJvcGVydHkgYXNzZXJ0aW9uIGVycm9yIHRoYXQgd2VcbiAgICAgICAgLy8gZW5jb3VudGVyZWQuXG4gICAgICAgIGlmIChuZWdhdGUgJiYgcHJvcHMubGVuZ3RoID4gMSAmJiBudW1FcnJzID09PSBwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBmaXJzdEVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXNzZXJ0IGluY2x1c2lvbiBpbiBjb2xsZWN0aW9uIG9yIHN1YnN0cmluZyBpbiBhIHN0cmluZy5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGluY2x1ZGVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvICcgKyBkZXNjcmlwdG9yICsgJ2luY2x1ZGUgJyArIF8uaW5zcGVjdCh2YWwpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCAnICsgZGVzY3JpcHRvciArICdpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKSk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdpbmNsdWRlJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjb250YWluJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjb250YWlucycsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jbHVkZXMnLCBpbmNsdWRlLCBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvcik7XG5cbiAgLyoqXG4gICAqICMjIyAub2tcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSB0cnV0aHkgdmFsdWUgKGNvbnNpZGVyZWQgYHRydWVgIGluIGJvb2xlYW4gY29udGV4dCkuXG4gICAqIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IChgPT09YCkgb3JcbiAgICogZGVlcGx5IGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5vazsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8uYmUudHJ1ZTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh0cnVlKS50by5iZS5vazsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAub2tgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDApLnRvLmVxdWFsKDApOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDApLnRvLm5vdC5iZS5vazsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLmJlLmZhbHNlOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5ub3QuYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLm51bGw7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QobnVsbCkudG8ubm90LmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLnVuZGVmaW5lZDsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLm5vdC5iZS5vazsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5vaztcbiAgICpcbiAgICogQG5hbWUgb2tcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdvaycsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdHJ1dGh5J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzeScpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC50cnVlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gYHRydWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLnRydWU7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAudHJ1ZWAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyIHRoYW4gbm90XG4gICAqIGVxdWFsIHRvIGB0cnVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8uYmUuZmFsc2U7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLm5vdC5iZS50cnVlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUudHJ1ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS50cnVlO1xuICAgKlxuICAgKiBAbmFtZSB0cnVlXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgndHJ1ZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdHJ1ZSA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdHJ1ZSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc2UnXG4gICAgICAsIGZsYWcodGhpcywgJ25lZ2F0ZScpID8gZmFsc2UgOiB0cnVlXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZmFsc2VcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBgZmFsc2VgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5iZS5mYWxzZTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5mYWxzZWAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyIHRoYW5cbiAgICogbm90IGVxdWFsIHRvIGBmYWxzZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8uYmUudHJ1ZTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh0cnVlKS50by5ub3QuYmUuZmFsc2U7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5mYWxzZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QodHJ1ZSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmZhbHNlO1xuICAgKlxuICAgKiBAbmFtZSBmYWxzZVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2ZhbHNlJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBmYWxzZSA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc2UnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydWUnXG4gICAgICAsIGZsYWcodGhpcywgJ25lZ2F0ZScpID8gdHJ1ZSA6IGZhbHNlXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAubnVsbFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGBudWxsYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5udWxsO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm51bGxgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuIG5vdFxuICAgKiBlcXVhbCB0byBgbnVsbGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLm51bGw7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDQyLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUubnVsbDtcbiAgICpcbiAgICogQG5hbWUgbnVsbFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ251bGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG51bGwgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIG51bGwnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBudWxsJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnVuZGVmaW5lZFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8uYmUudW5kZWZpbmVkO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnVuZGVmaW5lZGAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyIHRoYW5cbiAgICogbm90IGVxdWFsIHRvIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS51bmRlZmluZWQ7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDQyLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUudW5kZWZpbmVkO1xuICAgKlxuICAgKiBAbmFtZSB1bmRlZmluZWRcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCd1bmRlZmluZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHVuZGVmaW5lZCA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdW5kZWZpbmVkJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgdW5kZWZpbmVkJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLk5hTlxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBleGFjdGx5IGBOYU5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KE5hTikudG8uYmUuTmFOO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLk5hTmAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyIHRoYW4gbm90XG4gICAqIGVxdWFsIHRvIGBOYU5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5lcXVhbCgnZm9vJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLm5vdC5iZS5OYU47IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDQyLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuTmFOO1xuICAgKlxuICAgKiBAbmFtZSBOYU5cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdOYU4nLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIF8uaXNOYU4oZmxhZyh0aGlzLCAnb2JqZWN0JykpXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgTmFOJ1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBOYU4nXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXhpc3RcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbm90IHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gZWl0aGVyIGBudWxsYCBvclxuICAgKiBgdW5kZWZpbmVkYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG9cbiAgICogaXRzIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmV4aXN0OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdCgwKS50by5lcXVhbCgwKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgwKS50by5leGlzdDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZXhpc3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLm51bGw7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QobnVsbCkudG8ubm90LmV4aXN0OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLnVuZGVmaW5lZDsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLm5vdC5leGlzdDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QobnVsbCwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmV4aXN0O1xuICAgKlxuICAgKiBAbmFtZSBleGlzdFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2V4aXN0JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGV4aXN0J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXhpc3QnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZW1wdHlcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIGFycmF5LCBgLmVtcHR5YCBhc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzXG4gICAqIGBsZW5ndGhgIHByb3BlcnR5IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gYDBgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdCgnJykudG8uYmUuZW1wdHk7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIG1hcCBvciBzZXQsIGAuZW1wdHlgIGFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3MgYHNpemVgXG4gICAqIHByb3BlcnR5IGlzIHN0cmljdGx5IGVxdWFsIHRvIGAwYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KCkpLnRvLmJlLmVtcHR5O1xuICAgKiAgICAgZXhwZWN0KG5ldyBNYXAoKSkudG8uYmUuZW1wdHk7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIG5vbi1mdW5jdGlvbiBvYmplY3QsIGAuZW1wdHlgIGFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0XG4gICAqIGRvZXNuJ3QgaGF2ZSBhbnkgb3duIGVudW1lcmFibGUgcHJvcGVydGllcy4gUHJvcGVydGllcyB3aXRoIFN5bWJvbC1iYXNlZFxuICAgKiBrZXlzIGFyZSBleGNsdWRlZCBmcm9tIHRoZSBjb3VudC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7fSkudG8uYmUuZW1wdHk7XG4gICAqXG4gICAqIEJlY2F1c2UgYC5lbXB0eWAgZG9lcyBkaWZmZXJlbnQgdGhpbmdzIGJhc2VkIG9uIHRoZSB0YXJnZXQncyB0eXBlLCBpdCdzXG4gICAqIGltcG9ydGFudCB0byBjaGVjayB0aGUgdGFyZ2V0J3MgdHlwZSBiZWZvcmUgdXNpbmcgYC5lbXB0eWAuIFNlZSB0aGUgYC5hYFxuICAgKiBkb2MgZm9yIGluZm8gb24gdGVzdGluZyBhIHRhcmdldCdzIHR5cGUuXG4gICAqXG4gICAqICAgICBleHBlY3QoW10pLnRvLmJlLmFuKCdhcnJheScpLnRoYXQuaXMuZW1wdHk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZW1wdHlgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBjb250YWlucyBpdHMgZXhwZWN0ZWQgbnVtYmVyIG9mIHZhbHVlcyxcbiAgICogcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXQncyBub3QgZW1wdHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmJlLmVtcHR5OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFsxLCAyLCAzXSkpLnRvLmhhdmUucHJvcGVydHkoJ3NpemUnLCAzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFsxLCAyLCAzXSkpLnRvLm5vdC5iZS5lbXB0eTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoT2JqZWN0LmtleXMoe2E6IDF9KSkudG8uaGF2ZS5sZW5ndGhPZigxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5iZS5lbXB0eTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuZW1wdHk7XG4gICAqXG4gICAqIEBuYW1lIGVtcHR5XG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZW1wdHknLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbCA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBpdGVtc0NvdW50O1xuXG4gICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuXG4gICAgc3dpdGNoIChfLnR5cGUodmFsKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpdGVtc0NvdW50ID0gdmFsLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtYXAnOlxuICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgaXRlbXNDb3VudCA9IHZhbC5zaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dlYWttYXAnOlxuICAgICAgY2FzZSAnd2Vha3NldCc6XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICBmbGFnTXNnICsgJy5lbXB0eSB3YXMgcGFzc2VkIGEgd2VhayBjb2xsZWN0aW9uJyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc3NmaVxuICAgICAgICApO1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICB2YXIgbXNnID0gZmxhZ01zZyArICcuZW1wdHkgd2FzIHBhc3NlZCBhIGZ1bmN0aW9uICcgKyBfLmdldE5hbWUodmFsKTtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1zZy50cmltKCksIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodmFsICE9PSBPYmplY3QodmFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICAgIGZsYWdNc2cgKyAnLmVtcHR5IHdhcyBwYXNzZWQgbm9uLXN0cmluZyBwcmltaXRpdmUgJyArIF8uaW5zcGVjdCh2YWwpLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3NmaVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbXNDb3VudCA9IE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAwID09PSBpdGVtc0NvdW50XG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGVtcHR5J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgZW1wdHknXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuYXJndW1lbnRzXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIHRlc3QgKCkge1xuICAgKiAgICAgICBleHBlY3QoYXJndW1lbnRzKS50by5iZS5hcmd1bWVudHM7XG4gICAqICAgICB9XG4gICAqXG4gICAqICAgICB0ZXN0KCk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuYXJndW1lbnRzYC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB3aGljaCB0eXBlIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gYmUsIHJhdGhlciB0aGFuXG4gICAqIGFzc2VydGluZyB0aGF0IGl0cyBub3QgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5iZS5hKCdzdHJpbmcnKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8ubm90LmJlLmFyZ3VtZW50czsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe30sICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5hcmd1bWVudHM7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLkFyZ3VtZW50c2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5hcmd1bWVudHNgLlxuICAgKlxuICAgKiBAbmFtZSBhcmd1bWVudHNcbiAgICogQGFsaWFzIEFyZ3VtZW50c1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBjaGVja0FyZ3VtZW50cyAoKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHR5cGUgPSBfLnR5cGUob2JqKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgJ0FyZ3VtZW50cycgPT09IHR5cGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXJndW1lbnRzIGJ1dCBnb3QgJyArIHR5cGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFyZ3VtZW50cydcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhcmd1bWVudHMnLCBjaGVja0FyZ3VtZW50cyk7XG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnQXJndW1lbnRzJywgY2hlY2tBcmd1bWVudHMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxdWFsKHZhbFssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gdGhlIGdpdmVuIGB2YWxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpO1xuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5lcXVhbCgnZm9vJyk7XG4gICAqXG4gICAqIEFkZCBgLmRlZXBgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIHVzZSBkZWVwIGVxdWFsaXR5IGluc3RlYWQuIFNlZSB0aGVcbiAgICogYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGVxdWFscyBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZGVlcC5lcXVhbCh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmVxdWFsKHthOiAxfSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBlcXVhbHMgYFsxLCAyXWBcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLmRlZXAuZXF1YWwoWzEsIDJdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLm5vdC5lcXVhbChbMSwgMl0pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmVxdWFsYC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhblxuICAgKiBub3QgZXF1YWwgdG8gb25lIG9mIGNvdW50bGVzcyB1bmV4cGVjdGVkIHZhbHVlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuZXF1YWwoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmVxdWFsYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMiwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5lcXVhbCgyKTtcbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC5lcXVhbHNgIGFuZCBgZXFgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuZXF1YWxgLlxuICAgKlxuICAgKiBAbmFtZSBlcXVhbFxuICAgKiBAYWxpYXMgZXF1YWxzXG4gICAqIEBhbGlhcyBlcVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEVxdWFsICh2YWwsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZGVlcCcpKSB7XG4gICAgICB2YXIgcHJldkxvY2tTc2ZpID0gZmxhZyh0aGlzLCAnbG9ja1NzZmknKTtcbiAgICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgdHJ1ZSk7XG4gICAgICB0aGlzLmVxbCh2YWwpO1xuICAgICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCBwcmV2TG9ja1NzZmkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICB2YWwgPT09IG9ialxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3tleHB9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIHRoaXMuX29ialxuICAgICAgICAsIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXF1YWwnLCBhc3NlcnRFcXVhbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxdWFscycsIGFzc2VydEVxdWFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXEnLCBhc3NlcnRFcXVhbCk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXFsKG9ialssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byB0aGUgZ2l2ZW4gYG9iamAuIFNlZSB0aGVcbiAgICogYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBpcyBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGVxdWFsIHRvIHthOiAxfVxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZXFsKHthOiAxfSkuYnV0Lm5vdC5lcXVhbCh7YTogMX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGlzIGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgZXF1YWwgdG8gWzEsIDJdXG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5lcWwoWzEsIDJdKS5idXQubm90LmVxdWFsKFsxLCAyXSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZXFsYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZGVlcGx5IGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyXG4gICAqIHRoYW4gbm90IGRlZXBseSBlcXVhbCB0byBvbmUgb2YgY291bnRsZXNzIHVuZXhwZWN0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZXFsKHthOiAxfSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuZXFsKHtiOiAyfSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmVxbGAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZXFsKHtiOiAyfSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmVxbCh7YjogMn0pO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5lcWxzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmVxbGAuXG4gICAqXG4gICAqIFRoZSBgLmRlZXAuZXF1YWxgIGFzc2VydGlvbiBpcyBhbG1vc3QgaWRlbnRpY2FsIHRvIGAuZXFsYCBidXQgd2l0aCBvbmVcbiAgICogZGlmZmVyZW5jZTogYC5kZWVwLmVxdWFsYCBjYXVzZXMgZGVlcCBlcXVhbGl0eSBjb21wYXJpc29ucyB0byBhbHNvIGJlIHVzZWRcbiAgICogZm9yIGFueSBvdGhlciBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogQG5hbWUgZXFsXG4gICAqIEBhbGlhcyBlcWxzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RXFsKG9iaiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIF8uZXFsKG9iaiwgZmxhZyh0aGlzLCAnb2JqZWN0JykpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGRlZXBseSBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBkZWVwbHkgZXF1YWwgI3tleHB9J1xuICAgICAgLCBvYmpcbiAgICAgICwgdGhpcy5fb2JqXG4gICAgICAsIHRydWVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXFsJywgYXNzZXJ0RXFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXFscycsIGFzc2VydEVxbCk7XG5cbiAgLyoqXG4gICAqICMjIyAuYWJvdmUoblssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBncmVhdGVyIHRoYW4gdGhlIGdpdmVuIG51bWJlciBvciBkYXRlIGBuYCByZXNwZWN0aXZlbHkuXG4gICAqIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZFxuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS5hYm92ZSgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGBcbiAgICogb3IgYHNpemVgIGlzIGdyZWF0ZXIgdGhhbiB0aGUgZ2l2ZW4gbnVtYmVyIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi5hYm92ZSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5hYm92ZSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuYWJvdmVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5hYm92ZSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuYWJvdmVgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5hYm92ZSgyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmFib3ZlKDIpO1xuICAgKlxuICAgKiBUaGUgYWxpYXNlcyBgLmd0YCBhbmQgYC5ncmVhdGVyVGhhbmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGhcbiAgICogYC5hYm92ZWAuXG4gICAqXG4gICAqIEBuYW1lIGFib3ZlXG4gICAqIEBhbGlhcyBndFxuICAgKiBAYWxpYXMgZ3JlYXRlclRoYW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEFib3ZlIChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgblR5cGUgPSBfLnR5cGUobikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBlcnJvck1lc3NhZ2VcbiAgICAgICwgc2hvdWxkVGhyb3cgPSB0cnVlO1xuXG4gICAgaWYgKGRvTGVuZ3RoICYmIG9ialR5cGUgIT09ICdtYXAnICYmIG9ialR5cGUgIT09ICdzZXQnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIG5UeXBlICE9PSAnZGF0ZScpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGFib3ZlIG11c3QgYmUgYSBkYXRlJztcbiAgICB9IGVsc2UgaWYgKG5UeXBlICE9PSAnbnVtYmVyJyAmJiAoZG9MZW5ndGggfHwgb2JqVHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGFib3ZlIG11c3QgYmUgYSBudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlICE9PSAnZGF0ZScgJiYgb2JqVHlwZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgcHJpbnRPYmogPSAob2JqVHlwZSA9PT0gJ3N0cmluZycpID8gXCInXCIgKyBvYmogKyBcIidcIiA6IG9iajtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICdleHBlY3RlZCAnICsgcHJpbnRPYmogKyAnIHRvIGJlIGEgbnVtYmVyIG9yIGEgZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFRocm93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSAnbGVuZ3RoJ1xuICAgICAgICAsIGl0ZW1zQ291bnQ7XG4gICAgICBpZiAob2JqVHlwZSA9PT0gJ21hcCcgfHwgb2JqVHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgZGVzY3JpcHRvciA9ICdzaXplJztcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5zaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBpdGVtc0NvdW50ID4gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgYWJvdmUgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgaXRlbXNDb3VudFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqID4gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2Fib3ZlJywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndCcsIGFzc2VydEFib3ZlKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3JlYXRlclRoYW4nLCBhc3NlcnRBYm92ZSk7XG5cbiAgLyoqXG4gICAqICMjIyAubGVhc3QoblssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuXG4gICAqIG51bWJlciBvciBkYXRlIGBuYCByZXNwZWN0aXZlbHkuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvXG4gICAqIGl0cyBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS5hdC5sZWFzdCgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYXQubGVhc3QoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5sZW5ndGhPZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgXG4gICAqIG9yIGBzaXplYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlciBgbmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YuYXQubGVhc3QoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYXQubGVhc3QoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmxlYXN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUuYXQubGVhc3QoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmxlYXN0YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYXQubGVhc3QoMiwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5hdC5sZWFzdCgyKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuZ3RlYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmxlYXN0YC5cbiAgICpcbiAgICogQG5hbWUgbGVhc3RcbiAgICogQGFsaWFzIGd0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVhc3QgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBkb0xlbmd0aCA9IGZsYWcodGhpcywgJ2RvTGVuZ3RoJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBtc2dQcmVmaXggPSAoKGZsYWdNc2cpID8gZmxhZ01zZyArICc6ICcgOiAnJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBuVHlwZSA9IF8udHlwZShuKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGVycm9yTWVzc2FnZVxuICAgICAgLCBzaG91bGRUaHJvdyA9IHRydWU7XG5cbiAgICBpZiAoZG9MZW5ndGggJiYgb2JqVHlwZSAhPT0gJ21hcCcgJiYgb2JqVHlwZSAhPT0gJ3NldCcpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlID09PSAnZGF0ZScgJiYgblR5cGUgIT09ICdkYXRlJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gbGVhc3QgbXVzdCBiZSBhIGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoblR5cGUgIT09ICdudW1iZXInICYmIChkb0xlbmd0aCB8fCBvYmpUeXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gbGVhc3QgbXVzdCBiZSBhIG51bWJlcic7XG4gICAgfSBlbHNlIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgIT09ICdkYXRlJyAmJiBvYmpUeXBlICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBwcmludE9iaiA9IChvYmpUeXBlID09PSAnc3RyaW5nJykgPyBcIidcIiArIG9iaiArIFwiJ1wiIDogb2JqO1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ2V4cGVjdGVkICcgKyBwcmludE9iaiArICcgdG8gYmUgYSBudW1iZXIgb3IgYSBkYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVGhyb3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvck1lc3NhZ2UsIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgfVxuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9ICdsZW5ndGgnXG4gICAgICAgICwgaXRlbXNDb3VudDtcbiAgICAgIGlmIChvYmpUeXBlID09PSAnbWFwJyB8fCBvYmpUeXBlID09PSAnc2V0Jykge1xuICAgICAgICBkZXNjcmlwdG9yID0gJ3NpemUnO1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLnNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGl0ZW1zQ291bnQgPj0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgYXQgbGVhc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBpdGVtc0NvdW50XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPj0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IGxlYXN0ICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZWFzdCcsIGFzc2VydExlYXN0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3RlJywgYXNzZXJ0TGVhc3QpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmJlbG93KG5bLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciBvciBhIGRhdGUgbGVzcyB0aGFuIHRoZSBnaXZlbiBudW1iZXIgb3IgZGF0ZSBgbmAgcmVzcGVjdGl2ZWx5LlxuICAgKiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWRcbiAgICogdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYmVsb3coMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5sZW5ndGhPZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgXG4gICAqIG9yIGBzaXplYCBpcyBsZXNzIHRoYW4gdGhlIGdpdmVuIG51bWJlciBgbmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YuYmVsb3coNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGgoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmJlbG93KDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5iZWxvd2AuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8ubm90LmJlLmJlbG93KDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5iZWxvd2AgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLmJlbG93KDEsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgyLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYmVsb3coMSk7XG4gICAqXG4gICAqIFRoZSBhbGlhc2VzIGAubHRgIGFuZCBgLmxlc3NUaGFuYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aFxuICAgKiBgLmJlbG93YC5cbiAgICpcbiAgICogQG5hbWUgYmVsb3dcbiAgICogQGFsaWFzIGx0XG4gICAqIEBhbGlhcyBsZXNzVGhhblxuICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0QmVsb3cgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBkb0xlbmd0aCA9IGZsYWcodGhpcywgJ2RvTGVuZ3RoJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBtc2dQcmVmaXggPSAoKGZsYWdNc2cpID8gZmxhZ01zZyArICc6ICcgOiAnJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBuVHlwZSA9IF8udHlwZShuKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGVycm9yTWVzc2FnZVxuICAgICAgLCBzaG91bGRUaHJvdyA9IHRydWU7XG5cbiAgICBpZiAoZG9MZW5ndGggJiYgb2JqVHlwZSAhPT0gJ21hcCcgJiYgb2JqVHlwZSAhPT0gJ3NldCcpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlID09PSAnZGF0ZScgJiYgblR5cGUgIT09ICdkYXRlJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gYmVsb3cgbXVzdCBiZSBhIGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoblR5cGUgIT09ICdudW1iZXInICYmIChkb0xlbmd0aCB8fCBvYmpUeXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gYmVsb3cgbXVzdCBiZSBhIG51bWJlcic7XG4gICAgfSBlbHNlIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgIT09ICdkYXRlJyAmJiBvYmpUeXBlICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBwcmludE9iaiA9IChvYmpUeXBlID09PSAnc3RyaW5nJykgPyBcIidcIiArIG9iaiArIFwiJ1wiIDogb2JqO1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ2V4cGVjdGVkICcgKyBwcmludE9iaiArICcgdG8gYmUgYSBudW1iZXIgb3IgYSBkYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVGhyb3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvck1lc3NhZ2UsIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgfVxuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9ICdsZW5ndGgnXG4gICAgICAgICwgaXRlbXNDb3VudDtcbiAgICAgIGlmIChvYmpUeXBlID09PSAnbWFwJyB8fCBvYmpUeXBlID09PSAnc2V0Jykge1xuICAgICAgICBkZXNjcmlwdG9yID0gJ3NpemUnO1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLnNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGl0ZW1zQ291bnQgPCBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBiZWxvdyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBpdGVtc0NvdW50XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPCBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYmVsb3cgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IGxlYXN0ICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2JlbG93JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsdCcsIGFzc2VydEJlbG93KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVzc1RoYW4nLCBhc3NlcnRCZWxvdyk7XG5cbiAgLyoqXG4gICAqICMjIyAubW9zdChuWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIgb3IgYSBkYXRlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAqIG9yIGRhdGUgYG5gIHJlc3BlY3RpdmVseS4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzXG4gICAqIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmF0Lm1vc3QoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmF0Lm1vc3QoMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5sZW5ndGhPZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgXG4gICAqIG9yIGBzaXplYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlciBgbmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YuYXQubW9zdCg0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5hdC5tb3N0KDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5tb3N0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5ub3QuYmUuYXQubW9zdCgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAubW9zdGAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLmF0Lm1vc3QoMSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDIsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5hdC5tb3N0KDEpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5sdGVgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAubW9zdGAuXG4gICAqXG4gICAqIEBuYW1lIG1vc3RcbiAgICogQGFsaWFzIGx0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TW9zdCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGRvTGVuZ3RoID0gZmxhZyh0aGlzLCAnZG9MZW5ndGgnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG1zZ1ByZWZpeCA9ICgoZmxhZ01zZykgPyBmbGFnTXNnICsgJzogJyA6ICcnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIG5UeXBlID0gXy50eXBlKG4pLnRvTG93ZXJDYXNlKClcbiAgICAgICwgZXJyb3JNZXNzYWdlXG4gICAgICAsIHNob3VsZFRocm93ID0gdHJ1ZTtcblxuICAgIGlmIChkb0xlbmd0aCAmJiBvYmpUeXBlICE9PSAnbWFwJyAmJiBvYmpUeXBlICE9PSAnc2V0Jykge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIH1cblxuICAgIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgPT09ICdkYXRlJyAmJiBuVHlwZSAhPT0gJ2RhdGUnKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBtb3N0IG11c3QgYmUgYSBkYXRlJztcbiAgICB9IGVsc2UgaWYgKG5UeXBlICE9PSAnbnVtYmVyJyAmJiAoZG9MZW5ndGggfHwgb2JqVHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIG1vc3QgbXVzdCBiZSBhIG51bWJlcic7XG4gICAgfSBlbHNlIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgIT09ICdkYXRlJyAmJiBvYmpUeXBlICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBwcmludE9iaiA9IChvYmpUeXBlID09PSAnc3RyaW5nJykgPyBcIidcIiArIG9iaiArIFwiJ1wiIDogb2JqO1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ2V4cGVjdGVkICcgKyBwcmludE9iaiArICcgdG8gYmUgYSBudW1iZXIgb3IgYSBkYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVGhyb3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvck1lc3NhZ2UsIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgfVxuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9ICdsZW5ndGgnXG4gICAgICAgICwgaXRlbXNDb3VudDtcbiAgICAgIGlmIChvYmpUeXBlID09PSAnbWFwJyB8fCBvYmpUeXBlID09PSAnc2V0Jykge1xuICAgICAgICBkZXNjcmlwdG9yID0gJ3NpemUnO1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLnNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGl0ZW1zQ291bnQgPD0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgYXQgbW9zdCAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGl0ZW1zQ291bnRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbW9zdCAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbW9zdCcsIGFzc2VydE1vc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsdGUnLCBhc3NlcnRNb3N0KTtcblxuICAvKipcbiAgICogIyMjIC53aXRoaW4oc3RhcnQsIGZpbmlzaFssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuXG4gICAqIG51bWJlciBvciBkYXRlIGBzdGFydGAsIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlciBvciBkYXRlIGBmaW5pc2hgIHJlc3BlY3RpdmVseS5cbiAgICogSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLndpdGhpbigxLCAzKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUud2l0aGluKDIsIDMpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS53aXRoaW4oMSwgMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5sZW5ndGhPZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgXG4gICAqIG9yIGBzaXplYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlciBgc3RhcnRgLCBhbmQgbGVzc1xuICAgKiB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXIgYGZpbmlzaGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2Yud2l0aGluKDIsIDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLndpdGhpbigyLCA0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAud2l0aGluYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUud2l0aGluKDIsIDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC53aXRoaW5gIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0KS50by5iZS53aXRoaW4oMSwgMywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDQsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS53aXRoaW4oMSwgMyk7XG4gICAqXG4gICAqIEBuYW1lIHdpdGhpblxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgbG93ZXIgYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmaW5pc2ggdXBwZXIgYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd3aXRoaW4nLCBmdW5jdGlvbiAoc3RhcnQsIGZpbmlzaCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGRvTGVuZ3RoID0gZmxhZyh0aGlzLCAnZG9MZW5ndGgnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG1zZ1ByZWZpeCA9ICgoZmxhZ01zZykgPyBmbGFnTXNnICsgJzogJyA6ICcnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIHN0YXJ0VHlwZSA9IF8udHlwZShzdGFydCkudG9Mb3dlckNhc2UoKVxuICAgICAgLCBmaW5pc2hUeXBlID0gXy50eXBlKGZpbmlzaCkudG9Mb3dlckNhc2UoKVxuICAgICAgLCBlcnJvck1lc3NhZ2VcbiAgICAgICwgc2hvdWxkVGhyb3cgPSB0cnVlXG4gICAgICAsIHJhbmdlID0gKHN0YXJ0VHlwZSA9PT0gJ2RhdGUnICYmIGZpbmlzaFR5cGUgPT09ICdkYXRlJylcbiAgICAgICAgICA/IHN0YXJ0LnRvVVRDU3RyaW5nKCkgKyAnLi4nICsgZmluaXNoLnRvVVRDU3RyaW5nKClcbiAgICAgICAgICA6IHN0YXJ0ICsgJy4uJyArIGZpbmlzaDtcblxuICAgIGlmIChkb0xlbmd0aCAmJiBvYmpUeXBlICE9PSAnbWFwJyAmJiBvYmpUeXBlICE9PSAnc2V0Jykge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIH1cblxuICAgIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgPT09ICdkYXRlJyAmJiAoc3RhcnRUeXBlICE9PSAnZGF0ZScgfHwgZmluaXNoVHlwZSAhPT0gJ2RhdGUnKSkpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnRzIHRvIHdpdGhpbiBtdXN0IGJlIGRhdGVzJztcbiAgICB9IGVsc2UgaWYgKChzdGFydFR5cGUgIT09ICdudW1iZXInIHx8IGZpbmlzaFR5cGUgIT09ICdudW1iZXInKSAmJiAoZG9MZW5ndGggfHwgb2JqVHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50cyB0byB3aXRoaW4gbXVzdCBiZSBudW1iZXJzJztcbiAgICB9IGVsc2UgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSAhPT0gJ2RhdGUnICYmIG9ialR5cGUgIT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHByaW50T2JqID0gKG9ialR5cGUgPT09ICdzdHJpbmcnKSA/IFwiJ1wiICsgb2JqICsgXCInXCIgOiBvYmo7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAnZXhwZWN0ZWQgJyArIHByaW50T2JqICsgJyB0byBiZSBhIG51bWJlciBvciBhIGRhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRUaHJvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGVycm9yTWVzc2FnZSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gJ2xlbmd0aCdcbiAgICAgICAgLCBpdGVtc0NvdW50O1xuICAgICAgaWYgKG9ialR5cGUgPT09ICdtYXAnIHx8IG9ialR5cGUgPT09ICdzZXQnKSB7XG4gICAgICAgIGRlc2NyaXB0b3IgPSAnc2l6ZSc7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmouc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmoubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaXRlbXNDb3VudCA+PSBzdGFydCAmJiBpdGVtc0NvdW50IDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBzdGFydCAmJiBvYmogPD0gZmluaXNoXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuaW5zdGFuY2VvZihjb25zdHJ1Y3RvclssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHsgfVxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBDYXQoKSkudG8uYmUuYW4uaW5zdGFuY2VvZihDYXQpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uYmUuYW4uaW5zdGFuY2VvZihBcnJheSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuaW5zdGFuY2VvZmAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuYmUuYW4uaW5zdGFuY2VvZihBcnJheSk7XG4gICAqXG4gICAqIGAuaW5zdGFuY2VvZmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmFuLmluc3RhbmNlb2YoQXJyYXksICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYW4uaW5zdGFuY2VvZihBcnJheSk7XG4gICAqXG4gICAqIER1ZSB0byBsaW1pdGF0aW9ucyBpbiBFUzUsIGAuaW5zdGFuY2VvZmAgbWF5IG5vdCBhbHdheXMgd29yayBhcyBleHBlY3RlZFxuICAgKiB3aGVuIHVzaW5nIGEgdHJhbnNwaWxlciBzdWNoIGFzIEJhYmVsIG9yIFR5cGVTY3JpcHQuIEluIHBhcnRpY3VsYXIsIGl0IG1heVxuICAgKiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cyB3aGVuIHN1YmNsYXNzaW5nIGJ1aWx0LWluIG9iamVjdCBzdWNoIGFzXG4gICAqIGBBcnJheWAsIGBFcnJvcmAsIGFuZCBgTWFwYC4gU2VlIHlvdXIgdHJhbnNwaWxlcidzIGRvY3MgZm9yIGRldGFpbHM6XG4gICAqXG4gICAqIC0gKFtCYWJlbF0oaHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvdXNhZ2UvY2F2ZWF0cy8jY2xhc3NlcykpXG4gICAqIC0gKFtUeXBlU2NyaXB0XShodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvd2lraS9CcmVha2luZy1DaGFuZ2VzI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29yaykpXG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmluc3RhbmNlT2ZgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuaW5zdGFuY2VvZmAuXG4gICAqXG4gICAqIEBuYW1lIGluc3RhbmNlb2ZcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBhbGlhcyBpbnN0YW5jZU9mXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEluc3RhbmNlT2YgKGNvbnN0cnVjdG9yLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciB0YXJnZXQgPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgIHZhciBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIHZhciBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0luc3RhbmNlT2YgPSB0YXJnZXQgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgZmxhZ01zZyArICdUaGUgaW5zdGFuY2VvZiBhc3NlcnRpb24gbmVlZHMgYSBjb25zdHJ1Y3RvciBidXQgJ1xuICAgICAgICAgICAgKyBfLnR5cGUoY29uc3RydWN0b3IpICsgJyB3YXMgZ2l2ZW4uJyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc3NmaVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gXy5nZXROYW1lKGNvbnN0cnVjdG9yKTtcbiAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgbmFtZSA9ICdhbiB1bm5hbWVkIGNvbnN0cnVjdG9yJztcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXNJbnN0YW5jZU9mXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFuIGluc3RhbmNlIG9mICcgKyBuYW1lXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhbiBpbnN0YW5jZSBvZiAnICsgbmFtZVxuICAgICk7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5zdGFuY2VvZicsIGFzc2VydEluc3RhbmNlT2YpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbnN0YW5jZU9mJywgYXNzZXJ0SW5zdGFuY2VPZik7XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHkobmFtZVssIHZhbFssIG1zZ11dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXkgYG5hbWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYScpO1xuICAgKlxuICAgKiBXaGVuIGB2YWxgIGlzIHByb3ZpZGVkLCBgLnByb3BlcnR5YCBhbHNvIGFzc2VydHMgdGhhdCB0aGUgcHJvcGVydHkncyB2YWx1ZVxuICAgKiBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gYHZhbGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdhJywgMSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHN0cmljdCAoYD09PWApIGVxdWFsaXR5IGlzIHVzZWQuIEFkZCBgLmRlZXBgIGVhcmxpZXIgaW4gdGhlXG4gICAqIGNoYWluIHRvIHVzZSBkZWVwIGVxdWFsaXR5IGluc3RlYWQuIFNlZSB0aGUgYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yXG4gICAqIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBwcm9wZXJ0eSBgeDoge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5oYXZlLmRlZXAucHJvcGVydHkoJ3gnLCB7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgneCcsIHthOiAxfSk7XG4gICAqXG4gICAqIFRoZSB0YXJnZXQncyBlbnVtZXJhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgaW5jbHVkZWRcbiAgICogaW4gdGhlIHNlYXJjaC4gQnkgZGVmYXVsdCwgYm90aCBvd24gYW5kIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZSBpbmNsdWRlZC5cbiAgICogQWRkIGAub3duYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBleGNsdWRlIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGZyb20gdGhlXG4gICAqIHNlYXJjaC5cbiAgICpcbiAgICogICAgIE9iamVjdC5wcm90b3R5cGUuYiA9IDI7XG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93bi5wcm9wZXJ0eSgnYScpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd24ucHJvcGVydHkoJ2EnLCAxKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2InKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5oYXZlLm93bi5wcm9wZXJ0eSgnYicpO1xuICAgKlxuICAgKiBgLmRlZXBgIGFuZCBgLm93bmAgY2FuIGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5oYXZlLmRlZXAub3duLnByb3BlcnR5KCd4Jywge2E6IDF9KTtcbiAgICpcbiAgICogQWRkIGAubmVzdGVkYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBlbmFibGUgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiB3aGVuXG4gICAqIHJlZmVyZW5jaW5nIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnYS5iWzFdJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbJ3gnLCAneSddfX0pLnRvLmhhdmUubmVzdGVkLnByb3BlcnR5KCdhLmJbMV0nLCAneScpO1xuICAgKlxuICAgKiBJZiBgLmAgb3IgYFtdYCBhcmUgcGFydCBvZiBhbiBhY3R1YWwgcHJvcGVydHkgbmFtZSwgdGhleSBjYW4gYmUgZXNjYXBlZCBieVxuICAgKiBhZGRpbmcgdHdvIGJhY2tzbGFzaGVzIGJlZm9yZSB0aGVtLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsnLmEnOiB7J1tiXSc6ICd4J319KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnXFxcXC5hLlxcXFxbYlxcXFxdJyk7XG4gICAqXG4gICAqIGAuZGVlcGAgYW5kIGAubmVzdGVkYCBjYW4gYmUgY29tYmluZWQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbe2M6IDN9XX19KVxuICAgKiAgICAgICAudG8uaGF2ZS5kZWVwLm5lc3RlZC5wcm9wZXJ0eSgnYS5iWzBdJywge2M6IDN9KTtcbiAgICpcbiAgICogYC5vd25gIGFuZCBgLm5lc3RlZGAgY2Fubm90IGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnByb3BlcnR5YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdiJyk7XG4gICAqXG4gICAqIEhvd2V2ZXIsIGl0J3MgZGFuZ2Vyb3VzIHRvIG5lZ2F0ZSBgLnByb3BlcnR5YCB3aGVuIHByb3ZpZGluZyBgdmFsYC4gVGhlXG4gICAqIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMgYnkgYXNzZXJ0aW5nIHRoYXQgdGhlXG4gICAqIHRhcmdldCBlaXRoZXIgZG9lc24ndCBoYXZlIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4ga2V5IGBuYW1lYCwgb3IgdGhhdCBpdFxuICAgKiBkb2VzIGhhdmUgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXkgYG5hbWVgIGJ1dCBpdHMgdmFsdWUgaXNuJ3QgZXF1YWwgdG9cbiAgICogdGhlIGdpdmVuIGB2YWxgLiBJdCdzIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3NcbiAgICogZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzbid0IGV4cGVjdGVkIHRvIGhhdmUgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXlcbiAgICogYG5hbWVgLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdhJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2I6IDJ9KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgnYScsIDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXkgYG5hbWVgLFxuICAgKiBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHByb3BlcnR5IGhhcyBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlclxuICAgKiB0aGFuIGFzc2VydGluZyB0aGF0IGl0IGRvZXNuJ3QgaGF2ZSBvbmUgb2YgbWFueSB1bmV4cGVjdGVkIHZhbHVlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogM30pLnRvLmhhdmUucHJvcGVydHkoJ2EnLCAzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogM30pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdhJywgMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLnByb3BlcnR5YCBjaGFuZ2VzIHRoZSB0YXJnZXQgb2YgYW55IGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluXG4gICAqIHRvIGJlIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgZnJvbSB0aGUgb3JpZ2luYWwgdGFyZ2V0IG9iamVjdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2EnKS50aGF0LmlzLmEoJ251bWJlcicpO1xuICAgKlxuICAgKiBgLnByb3BlcnR5YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZyBgdmFsYCwgb25seSB1c2UgdGhlXG4gICAqIHNlY29uZCBmb3JtLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2EnLCAyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5wcm9wZXJ0eSgnYScsIDIpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUucHJvcGVydHkoJ2InKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYicsIHVuZGVmaW5lZCwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiBUaGUgYWJvdmUgYXNzZXJ0aW9uIGlzbid0IHRoZSBzYW1lIHRoaW5nIGFzIG5vdCBwcm92aWRpbmcgYHZhbGAuIEluc3RlYWQsXG4gICAqIGl0J3MgYXNzZXJ0aW5nIHRoYXQgdGhlIHRhcmdldCBvYmplY3QgaGFzIGEgYGJgIHByb3BlcnR5IHRoYXQncyBlcXVhbCB0b1xuICAgKiBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogVGhlIGFzc2VydGlvbnMgYC5vd25Qcm9wZXJ0eWAgYW5kIGAuaGF2ZU93blByb3BlcnR5YCBjYW4gYmUgdXNlZFxuICAgKiBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLm93bi5wcm9wZXJ0eWAuXG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbCAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAcmV0dXJucyB2YWx1ZSBvZiBwcm9wZXJ0eSBmb3IgY2hhaW5pbmdcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0UHJvcGVydHkgKG5hbWUsIHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICB2YXIgaXNOZXN0ZWQgPSBmbGFnKHRoaXMsICduZXN0ZWQnKVxuICAgICAgLCBpc093biA9IGZsYWcodGhpcywgJ293bicpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBuYW1lVHlwZSA9IHR5cGVvZiBuYW1lO1xuXG4gICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuXG4gICAgaWYgKGlzTmVzdGVkKSB7XG4gICAgICBpZiAobmFtZVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICBmbGFnTXNnICsgJ3RoZSBhcmd1bWVudCB0byBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIHdoZW4gdXNpbmcgbmVzdGVkIHN5bnRheCcsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHNzZmlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5hbWVUeXBlICE9PSAnc3RyaW5nJyAmJiBuYW1lVHlwZSAhPT0gJ251bWJlcicgJiYgbmFtZVR5cGUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICBmbGFnTXNnICsgJ3RoZSBhcmd1bWVudCB0byBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIHN5bWJvbCcsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHNzZmlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNOZXN0ZWQgJiYgaXNPd24pIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgZmxhZ01zZyArICdUaGUgXCJuZXN0ZWRcIiBhbmQgXCJvd25cIiBmbGFncyBjYW5ub3QgYmUgY29tYmluZWQuJyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBzc2ZpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgZmxhZ01zZyArICdUYXJnZXQgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgc3NmaVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgaXNEZWVwID0gZmxhZyh0aGlzLCAnZGVlcCcpXG4gICAgICAsIG5lZ2F0ZSA9IGZsYWcodGhpcywgJ25lZ2F0ZScpXG4gICAgICAsIHBhdGhJbmZvID0gaXNOZXN0ZWQgPyBfLmdldFBhdGhJbmZvKG9iaiwgbmFtZSkgOiBudWxsXG4gICAgICAsIHZhbHVlID0gaXNOZXN0ZWQgPyBwYXRoSW5mby52YWx1ZSA6IG9ialtuYW1lXTtcblxuICAgIHZhciBkZXNjcmlwdG9yID0gJyc7XG4gICAgaWYgKGlzRGVlcCkgZGVzY3JpcHRvciArPSAnZGVlcCAnO1xuICAgIGlmIChpc093bikgZGVzY3JpcHRvciArPSAnb3duICc7XG4gICAgaWYgKGlzTmVzdGVkKSBkZXNjcmlwdG9yICs9ICduZXN0ZWQgJztcbiAgICBkZXNjcmlwdG9yICs9ICdwcm9wZXJ0eSAnO1xuXG4gICAgdmFyIGhhc1Byb3BlcnR5O1xuICAgIGlmIChpc093bikgaGFzUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBuYW1lKTtcbiAgICBlbHNlIGlmIChpc05lc3RlZCkgaGFzUHJvcGVydHkgPSBwYXRoSW5mby5leGlzdHM7XG4gICAgZWxzZSBoYXNQcm9wZXJ0eSA9IF8uaGFzUHJvcGVydHkob2JqLCBuYW1lKTtcblxuICAgIC8vIFdoZW4gcGVyZm9ybWluZyBhIG5lZ2F0ZWQgYXNzZXJ0aW9uIGZvciBib3RoIG5hbWUgYW5kIHZhbCwgbWVyZWx5IGhhdmluZ1xuICAgIC8vIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpc24ndCBlbm91Z2ggdG8gY2F1c2UgdGhlIGFzc2VydGlvbiB0b1xuICAgIC8vIGZhaWwuIEl0IG11c3QgYm90aCBoYXZlIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgYW5kIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoYXQgcHJvcGVydHkgbXVzdCBlcXVhbCB0aGUgZ2l2ZW4gdmFsLiBUaGVyZWZvcmUsIHNraXAgdGhpcyBhc3NlcnRpb24gaW5cbiAgICAvLyBmYXZvciBvZiB0aGUgbmV4dC5cbiAgICBpZiAoIW5lZ2F0ZSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBoYXNQcm9wZXJ0eVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBoYXNQcm9wZXJ0eSAmJiAoaXNEZWVwID8gXy5lcWwodmFsLCB2YWx1ZSkgOiB2YWwgPT09IHZhbHVlKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7ZXhwfSwgYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7YWN0fSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB2YWx1ZSk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdwcm9wZXJ0eScsIGFzc2VydFByb3BlcnR5KTtcblxuICBmdW5jdGlvbiBhc3NlcnRPd25Qcm9wZXJ0eSAobmFtZSwgdmFsdWUsIG1zZykge1xuICAgIGZsYWcodGhpcywgJ293bicsIHRydWUpO1xuICAgIGFzc2VydFByb3BlcnR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdvd25Qcm9wZXJ0eScsIGFzc2VydE93blByb3BlcnR5KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaGF2ZU93blByb3BlcnR5JywgYXNzZXJ0T3duUHJvcGVydHkpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm93blByb3BlcnR5RGVzY3JpcHRvcihuYW1lWywgZGVzY3JpcHRvclssIG1zZ11dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgaXRzIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGggdGhlIGdpdmVuIGtleVxuICAgKiBgbmFtZWAuIEVudW1lcmFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGluY2x1ZGVkIGluIHRoZVxuICAgKiBzZWFyY2guXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScpO1xuICAgKlxuICAgKiBXaGVuIGBkZXNjcmlwdG9yYCBpcyBwcm92aWRlZCwgYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgIGFsc28gYXNzZXJ0cyB0aGF0XG4gICAqIHRoZSBwcm9wZXJ0eSdzIGRlc2NyaXB0b3IgaXMgZGVlcGx5IGVxdWFsIHRvIHRoZSBnaXZlbiBgZGVzY3JpcHRvcmAuIFNlZVxuICAgKiB0aGUgYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAxLFxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAub3duUHJvcGVydHlEZXNjcmlwdG9yYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYicpO1xuICAgKlxuICAgKiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byBuZWdhdGUgYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgIHdoZW4gcHJvdmlkaW5nXG4gICAqIGEgYGRlc2NyaXB0b3JgLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9ucyBieVxuICAgKiBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0IGVpdGhlciBkb2Vzbid0IGhhdmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGhcbiAgICogdGhlIGdpdmVuIGtleSBgbmFtZWAsIG9yIHRoYXQgaXQgZG9lcyBoYXZlIGEgcHJvcGVydHkgZGVzY3JpcHRvciB3aXRoIHRoZVxuICAgKiBnaXZlbiBrZXkgYG5hbWVgIGJ1dCBpdHMgbm90IGRlZXBseSBlcXVhbCB0byB0aGUgZ2l2ZW4gYGRlc2NyaXB0b3JgLiBJdCdzXG4gICAqIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuXG4gICAqIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzbid0IGV4cGVjdGVkIHRvIGhhdmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGggdGhlIGdpdmVuXG4gICAqIGtleSBgbmFtZWAsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLm5vdC5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2I6IDJ9KS50by5ub3QuaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAxLFxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBoYXZlIGEgcHJvcGVydHkgZGVzY3JpcHRvciB3aXRoIHRoZSBnaXZlblxuICAgKiBrZXkgYG5hbWVgLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHByb3BlcnR5IGhhcyBpdHMgZXhwZWN0ZWRcbiAgICogZGVzY3JpcHRvciwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXQgZG9lc24ndCBoYXZlIG9uZSBvZiBtYW55XG4gICAqIHVuZXhwZWN0ZWQgZGVzY3JpcHRvcnMuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAzfSkudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAzLFxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogM30pLnRvLm5vdC5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDEsXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgIGNoYW5nZXMgdGhlIHRhcmdldCBvZiBhbnkgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvd1xuICAgKiBpbiB0aGUgY2hhaW4gdG8gYmUgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZyb20gdGhlIG9yaWdpbmFsXG4gICAqIHRhcmdldCBvYmplY3QuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScpXG4gICAqICAgICAgIC50aGF0Lmhhcy5wcm9wZXJ0eSgnZW51bWVyYWJsZScsIHRydWUpO1xuICAgKlxuICAgKiBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhXG4gICAqIGN1c3RvbSBlcnJvciBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzb1xuICAgKiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmdcbiAgICogYGRlc2NyaXB0b3JgLCBvbmx5IHVzZSB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAyLFxuICAgKiAgICAgfSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDIsXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2InKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSlcbiAgICogICAgICAgLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdiJywgdW5kZWZpbmVkLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqIFRoZSBhYm92ZSBhc3NlcnRpb24gaXNuJ3QgdGhlIHNhbWUgdGhpbmcgYXMgbm90IHByb3ZpZGluZyBgZGVzY3JpcHRvcmAuXG4gICAqIEluc3RlYWQsIGl0J3MgYXNzZXJ0aW5nIHRoYXQgdGhlIHRhcmdldCBvYmplY3QgaGFzIGEgYGJgIHByb3BlcnR5XG4gICAqIGRlc2NyaXB0b3IgdGhhdCdzIGRlZXBseSBlcXVhbCB0byBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogVGhlIGFsaWFzIGAuaGF2ZU93blByb3BlcnR5RGVzY3JpcHRvcmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGhcbiAgICogYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgLlxuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICogQGFsaWFzIGhhdmVPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3IgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHlEZXNjcmlwdG9yIChuYW1lLCBkZXNjcmlwdG9yLCBtc2cpIHtcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtc2cgPSBkZXNjcmlwdG9yO1xuICAgICAgZGVzY3JpcHRvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB2YXIgYWN0dWFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0KG9iaiksIG5hbWUpO1xuICAgIGlmIChhY3R1YWxEZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIF8uZXFsKGRlc2NyaXB0b3IsIGFjdHVhbERlc2NyaXB0b3IpXG4gICAgICAgICwgJ2V4cGVjdGVkIHRoZSBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKSArICcgb24gI3t0aGlzfSB0byBtYXRjaCAnICsgXy5pbnNwZWN0KGRlc2NyaXB0b3IpICsgJywgZ290ICcgKyBfLmluc3BlY3QoYWN0dWFsRGVzY3JpcHRvcilcbiAgICAgICAgLCAnZXhwZWN0ZWQgdGhlIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvbiAje3RoaXN9IHRvIG5vdCBtYXRjaCAnICsgXy5pbnNwZWN0KGRlc2NyaXB0b3IpXG4gICAgICAgICwgZGVzY3JpcHRvclxuICAgICAgICAsIGFjdHVhbERlc2NyaXB0b3JcbiAgICAgICAgLCB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBhY3R1YWxEZXNjcmlwdG9yXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhbiBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGFuIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICApO1xuICAgIH1cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBhY3R1YWxEZXNjcmlwdG9yKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ293blByb3BlcnR5RGVzY3JpcHRvcicsIGFzc2VydE93blByb3BlcnR5RGVzY3JpcHRvcik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aE9mKG5bLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgIG9yIGBzaXplYCBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAqIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gICAqICAgICBleHBlY3QobmV3IFNldChbMSwgMiwgM10pKS50by5oYXZlLmxlbmd0aE9mKDMpO1xuICAgKiAgICAgZXhwZWN0KG5ldyBNYXAoW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dKSkudG8uaGF2ZS5sZW5ndGhPZigzKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5sZW5ndGhPZmAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkXG4gICAqIHZhbHVlLCByYXRoZXIgdGhhbiBub3QgZXF1YWwgdG8gb25lIG9mIG1hbnkgdW5leHBlY3RlZCB2YWx1ZXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLm5vdC5oYXZlLmxlbmd0aE9mKDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5sZW5ndGhPZmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5sZW5ndGhPZigyKTtcbiAgICpcbiAgICogYC5sZW5ndGhPZmAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGxhbmd1YWdlIGNoYWluLCBjYXVzaW5nIGFsbCBgLmFib3ZlYCxcbiAgICogYC5iZWxvd2AsIGAubGVhc3RgLCBgLm1vc3RgLCBhbmQgYC53aXRoaW5gIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlXG4gICAqIGNoYWluIHRvIHVzZSB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgYXMgdGhlIHRhcmdldC4gSG93ZXZlciwgaXQnc1xuICAgKiBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQncyBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBlcXVhbCB0byBpdHNcbiAgICogZXhwZWN0ZWQgbGVuZ3RoLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdHMgYGxlbmd0aGAgcHJvcGVydHkgZmFsbHNcbiAgICogd2l0aGluIHNvbWUgcmFuZ2Ugb2YgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmJlbG93KDQpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5hdC5sZWFzdCgzKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYXQubW9zdCgzKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2Yud2l0aGluKDIsNCk7XG4gICAqXG4gICAqIER1ZSB0byBhIGNvbXBhdGliaWxpdHkgaXNzdWUsIHRoZSBhbGlhcyBgLmxlbmd0aGAgY2FuJ3QgYmUgY2hhaW5lZCBkaXJlY3RseVxuICAgKiBvZmYgb2YgYW4gdW5pbnZva2VkIG1ldGhvZCBzdWNoIGFzIGAuYWAuIFRoZXJlZm9yZSwgYC5sZW5ndGhgIGNhbid0IGJlIHVzZWRcbiAgICogaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5sZW5ndGhPZmAgaW4gZXZlcnkgc2l0dWF0aW9uLiBJdCdzIHJlY29tbWVuZGVkIHRvXG4gICAqIGFsd2F5cyB1c2UgYC5sZW5ndGhPZmAgaW5zdGVhZCBvZiBgLmxlbmd0aGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmEubGVuZ3RoKDMpOyAvLyBpbmNvbXBhdGlibGU7IHRocm93cyBlcnJvclxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5hLmxlbmd0aE9mKDMpOyAgLy8gcGFzc2VzIGFzIGV4cGVjdGVkXG4gICAqXG4gICAqIEBuYW1lIGxlbmd0aE9mXG4gICAqIEBhbGlhcyBsZW5ndGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydExlbmd0aENoYWluICgpIHtcbiAgICBmbGFnKHRoaXMsICdkb0xlbmd0aCcsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVuZ3RoIChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIGRlc2NyaXB0b3IgPSAnbGVuZ3RoJ1xuICAgICAgLCBpdGVtc0NvdW50O1xuXG4gICAgc3dpdGNoIChvYmpUeXBlKSB7XG4gICAgICBjYXNlICdtYXAnOlxuICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgZGVzY3JpcHRvciA9ICdzaXplJztcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5zaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5sZW5ndGg7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGl0ZW1zQ291bnQgPT0gblxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIG9mICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgb2YgI3thY3R9J1xuICAgICAgLCBuXG4gICAgICAsIGl0ZW1zQ291bnRcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnbGVuZ3RoJywgYXNzZXJ0TGVuZ3RoLCBhc3NlcnRMZW5ndGhDaGFpbik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2xlbmd0aE9mJywgYXNzZXJ0TGVuZ3RoLCBhc3NlcnRMZW5ndGhDaGFpbik7XG5cbiAgLyoqXG4gICAqICMjIyAubWF0Y2gocmVbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBtYXRjaGVzIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYHJlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubWF0Y2goL15mb28vKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5tYXRjaGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm5vdC5tYXRjaCgvdGFjby8pO1xuICAgKlxuICAgKiBgLm1hdGNoYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm1hdGNoKC90YWNvLywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KCdmb29iYXInLCAnbm9vbyB3aHkgZmFpbD8/JykudG8ubWF0Y2goL3RhY28vKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAubWF0Y2hlc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5tYXRjaGAuXG4gICAqXG4gICAqIEBuYW1lIG1hdGNoXG4gICAqIEBhbGlhcyBtYXRjaGVzXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIGFzc2VydE1hdGNoKHJlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlLmV4ZWMob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBtYXRjaCAnICsgcmVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIG1hdGNoICcgKyByZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtYXRjaCcsIGFzc2VydE1hdGNoKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWF0Y2hlcycsIGFzc2VydE1hdGNoKTtcblxuICAvKipcbiAgICogIyMjIC5zdHJpbmcoc3RyWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgc3RyaW5nIGNvbnRhaW5zIHRoZSBnaXZlbiBzdWJzdHJpbmcgYHN0cmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmhhdmUuc3RyaW5nKCdiYXInKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5zdHJpbmdgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5ub3QuaGF2ZS5zdHJpbmcoJ3RhY28nKTtcbiAgICpcbiAgICogYC5zdHJpbmdgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5zdHJpbmcoJ3RhY28nLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicsICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLnN0cmluZygndGFjbycpO1xuICAgKlxuICAgKiBAbmFtZSBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc3RyaW5nJywgZnVuY3Rpb24gKHN0ciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnc3RyaW5nJyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgfm9iai5pbmRleE9mKHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gY29udGFpbiAnICsgXy5pbnNwZWN0KHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGNvbnRhaW4gJyArIF8uaW5zcGVjdChzdHIpXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAua2V5cyhrZXkxWywga2V5MlssIC4uLl1dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBvYmplY3QsIGFycmF5LCBtYXAsIG9yIHNldCBoYXMgdGhlIGdpdmVuIGtleXMuIE9ubHlcbiAgICogdGhlIHRhcmdldCdzIG93biBpbmhlcml0ZWQgcHJvcGVydGllcyBhcmUgaW5jbHVkZWQgaW4gdGhlIHNlYXJjaC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGFuIG9iamVjdCBvciBhcnJheSwga2V5cyBjYW4gYmUgcHJvdmlkZWQgYXMgb25lIG9yIG1vcmVcbiAgICogc3RyaW5nIGFyZ3VtZW50cywgYSBzaW5nbGUgYXJyYXkgYXJndW1lbnQsIG9yIGEgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4gSW5cbiAgICogdGhlIGxhdHRlciBjYXNlLCBvbmx5IHRoZSBrZXlzIGluIHRoZSBnaXZlbiBvYmplY3QgbWF0dGVyOyB0aGUgdmFsdWVzIGFyZVxuICAgKiBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3QoWyd4JywgJ3knXSkudG8uaGF2ZS5hbGwua2V5cygwLCAxKTtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYWxsLmtleXMoWydhJywgJ2InXSk7XG4gICAqICAgICBleHBlY3QoWyd4JywgJ3knXSkudG8uaGF2ZS5hbGwua2V5cyhbMCwgMV0pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cyh7YTogNCwgYjogNX0pOyAvLyBpZ25vcmUgNCBhbmQgNVxuICAgKiAgICAgZXhwZWN0KFsneCcsICd5J10pLnRvLmhhdmUuYWxsLmtleXMoezA6IDQsIDE6IDV9KTsgLy8gaWdub3JlIDQgYW5kIDVcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgbWFwIG9yIHNldCwgZWFjaCBrZXkgbXVzdCBiZSBwcm92aWRlZCBhcyBhIHNlcGFyYXRlXG4gICAqIGFyZ3VtZW50LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBNYXAoW1snYScsIDFdLCBbJ2InLCAyXV0pKS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFsnYScsICdiJ10pKS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogQmVjYXVzZSBgLmtleXNgIGRvZXMgZGlmZmVyZW50IHRoaW5ncyBiYXNlZCBvbiB0aGUgdGFyZ2V0J3MgdHlwZSwgaXQnc1xuICAgKiBpbXBvcnRhbnQgdG8gY2hlY2sgdGhlIHRhcmdldCdzIHR5cGUgYmVmb3JlIHVzaW5nIGAua2V5c2AuIFNlZSB0aGUgYC5hYCBkb2NcbiAgICogZm9yIGluZm8gb24gdGVzdGluZyBhIHRhcmdldCdzIHR5cGUuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5iZS5hbignb2JqZWN0JykudGhhdC5oYXMuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBzdHJpY3QgKGA9PT1gKSBlcXVhbGl0eSBpcyB1c2VkIHRvIGNvbXBhcmUga2V5cyBvZiBtYXBzIGFuZFxuICAgKiBzZXRzLiBBZGQgYC5kZWVwYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byB1c2UgZGVlcCBlcXVhbGl0eSBpbnN0ZWFkLiBTZWVcbiAgICogdGhlIGBkZWVwLWVxbGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBzZXQgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMga2V5IGB7YTogMX1gXG4gICAqICAgICBleHBlY3QobmV3IFNldChbe2E6IDF9XSkpLnRvLmhhdmUuYWxsLmRlZXAua2V5cyhbe2E6IDF9XSk7XG4gICAqICAgICBleHBlY3QobmV3IFNldChbe2E6IDF9XSkpLnRvLm5vdC5oYXZlLmFsbC5rZXlzKFt7YTogMX1dKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHRhcmdldCBtdXN0IGhhdmUgYWxsIG9mIHRoZSBnaXZlbiBrZXlzIGFuZCBubyBtb3JlLiBBZGRcbiAgICogYC5hbnlgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG9ubHkgcmVxdWlyZSB0aGF0IHRoZSB0YXJnZXQgaGF2ZSBhdCBsZWFzdFxuICAgKiBvbmUgb2YgdGhlIGdpdmVuIGtleXMuIEFsc28sIGFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlXG4gICAqIGAua2V5c2AuIEl0J3Mgb2Z0ZW4gYmVzdCB0byBhZGQgYC5hbnlgIHdoZW4gbmVnYXRpbmcgYC5rZXlzYCwgYW5kIHRvIHVzZVxuICAgKiBgLmFsbGAgd2hlbiBhc3NlcnRpbmcgYC5rZXlzYCB3aXRob3V0IG5lZ2F0aW9uLlxuICAgKlxuICAgKiBXaGVuIG5lZ2F0aW5nIGAua2V5c2AsIGAuYW55YCBpcyBwcmVmZXJyZWQgYmVjYXVzZSBgLm5vdC5hbnkua2V5c2AgYXNzZXJ0c1xuICAgKiBleGFjdGx5IHdoYXQncyBleHBlY3RlZCBvZiB0aGUgb3V0cHV0LCB3aGVyZWFzIGAubm90LmFsbC5rZXlzYCBjcmVhdGVzXG4gICAqIHVuY2VydGFpbiBleHBlY3RhdGlvbnMuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZDsgYXNzZXJ0cyB0aGF0IHRhcmdldCBkb2Vzbid0IGhhdmUgYW55IG9mIHRoZSBnaXZlbiBrZXlzXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5ub3QuaGF2ZS5hbnkua2V5cygnYycsICdkJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWQ7IGFzc2VydHMgdGhhdCB0YXJnZXQgZG9lc24ndCBoYXZlIGFsbCBvZiB0aGUgZ2l2ZW5cbiAgICogICAgIC8vIGtleXMgYnV0IG1heSBvciBtYXkgbm90IGhhdmUgc29tZSBvZiB0aGVtXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5ub3QuaGF2ZS5hbGwua2V5cygnYycsICdkJyk7XG4gICAqXG4gICAqIFdoZW4gYXNzZXJ0aW5nIGAua2V5c2Agd2l0aG91dCBuZWdhdGlvbiwgYC5hbGxgIGlzIHByZWZlcnJlZCBiZWNhdXNlXG4gICAqIGAuYWxsLmtleXNgIGFzc2VydHMgZXhhY3RseSB3aGF0J3MgZXhwZWN0ZWQgb2YgdGhlIG91dHB1dCwgd2hlcmVhc1xuICAgKiBgLmFueS5rZXlzYCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZDsgYXNzZXJ0cyB0aGF0IHRhcmdldCBoYXMgYWxsIHRoZSBnaXZlbiBrZXlzXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZDsgYXNzZXJ0cyB0aGF0IHRhcmdldCBoYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBnaXZlblxuICAgKiAgICAgLy8ga2V5cyBidXQgbWF5IG9yIG1heSBub3QgaGF2ZSBtb3JlIG9mIHRoZW1cbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYW55LmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBOb3RlIHRoYXQgYC5hbGxgIGlzIHVzZWQgYnkgZGVmYXVsdCB3aGVuIG5laXRoZXIgYC5hbGxgIG5vciBgLmFueWAgYXBwZWFyXG4gICAqIGVhcmxpZXIgaW4gdGhlIGNoYWluLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYWRkIGAuYWxsYCBhbnl3YXkgYmVjYXVzZVxuICAgKiBpdCBpbXByb3ZlcyByZWFkYWJpbGl0eS5cbiAgICpcbiAgICogICAgIC8vIEJvdGggYXNzZXJ0aW9ucyBhcmUgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUua2V5cygnYScsICdiJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5pbmNsdWRlYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byByZXF1aXJlIHRoYXQgdGhlIHRhcmdldCdzIGtleXMgYmUgYVxuICAgKiBzdXBlcnNldCBvZiB0aGUgZXhwZWN0ZWQga2V5cywgcmF0aGVyIHRoYW4gaWRlbnRpY2FsIHNldHMuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0J3Mga2V5cyBhcmUgYSBzdXBlcnNldCBvZiBbJ2EnLCAnYiddIGJ1dCBub3QgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDIsIGM6IDN9KS50by5pbmNsdWRlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMiwgYzogM30pLnRvLm5vdC5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogSG93ZXZlciwgaWYgYC5hbnlgIGFuZCBgLmluY2x1ZGVgIGFyZSBjb21iaW5lZCwgb25seSB0aGUgYC5hbnlgIHRha2VzXG4gICAqIGVmZmVjdC4gVGhlIGAuaW5jbHVkZWAgaXMgaWdub3JlZCBpbiB0aGlzIGNhc2UuXG4gICAqXG4gICAqICAgICAvLyBCb3RoIGFzc2VydGlvbnMgYXJlIGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5hbnkua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5pbmNsdWRlLmFueS5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLmtleSgnYicpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5rZXlgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAua2V5c2AuXG4gICAqXG4gICAqIEBuYW1lIGtleXNcbiAgICogQGFsaWFzIGtleVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ3xBcnJheXxPYmplY3R9IGtleXNcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0S2V5cyAoa2V5cykge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iailcbiAgICAgICwga2V5c1R5cGUgPSBfLnR5cGUoa2V5cylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBpc0RlZXAgPSBmbGFnKHRoaXMsICdkZWVwJylcbiAgICAgICwgc3RyXG4gICAgICAsIGRlZXBTdHIgPSAnJ1xuICAgICAgLCBhY3R1YWxcbiAgICAgICwgb2sgPSB0cnVlXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJyk7XG5cbiAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG4gICAgdmFyIG1peGVkQXJnc01zZyA9IGZsYWdNc2cgKyAnd2hlbiB0ZXN0aW5nIGtleXMgYWdhaW5zdCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgeW91IG11c3QgZ2l2ZSBhIHNpbmdsZSBBcnJheXxPYmplY3R8U3RyaW5nIGFyZ3VtZW50IG9yIG11bHRpcGxlIFN0cmluZyBhcmd1bWVudHMnO1xuXG4gICAgaWYgKG9ialR5cGUgPT09ICdNYXAnIHx8IG9ialR5cGUgPT09ICdTZXQnKSB7XG4gICAgICBkZWVwU3RyID0gaXNEZWVwID8gJ2RlZXBseSAnIDogJyc7XG4gICAgICBhY3R1YWwgPSBbXTtcblxuICAgICAgLy8gTWFwIGFuZCBTZXQgJy5rZXlzJyBhcmVuJ3Qgc3VwcG9ydGVkIGluIElFIDExLiBUaGVyZWZvcmUsIHVzZSAuZm9yRWFjaC5cbiAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGtleSkgeyBhY3R1YWwucHVzaChrZXkpIH0pO1xuXG4gICAgICBpZiAoa2V5c1R5cGUgIT09ICdBcnJheScpIHtcbiAgICAgICAga2V5cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdHVhbCA9IF8uZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMob2JqKTtcblxuICAgICAgc3dpdGNoIChrZXlzVHlwZSkge1xuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobWl4ZWRBcmdzTXNnLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtaXhlZEFyZ3NNc2csIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhrZXlzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBrZXlzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgLy8gT25seSBzdHJpbmdpZnkgbm9uLVN5bWJvbHMgYmVjYXVzZSBTeW1ib2xzIHdvdWxkIGJlY29tZSBcIlN5bWJvbCgpXCJcbiAgICAgIGtleXMgPSBrZXlzLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3ltYm9sJyA/IHZhbCA6IFN0cmluZyh2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGZsYWdNc2cgKyAna2V5cyByZXF1aXJlZCcsIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoXG4gICAgICAsIGFueSA9IGZsYWcodGhpcywgJ2FueScpXG4gICAgICAsIGFsbCA9IGZsYWcodGhpcywgJ2FsbCcpXG4gICAgICAsIGV4cGVjdGVkID0ga2V5cztcblxuICAgIGlmICghYW55ICYmICFhbGwpIHtcbiAgICAgIGFsbCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gSGFzIGFueVxuICAgIGlmIChhbnkpIHtcbiAgICAgIG9rID0gZXhwZWN0ZWQuc29tZShmdW5jdGlvbihleHBlY3RlZEtleSkge1xuICAgICAgICByZXR1cm4gYWN0dWFsLnNvbWUoZnVuY3Rpb24oYWN0dWFsS2V5KSB7XG4gICAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZXFsKGV4cGVjdGVkS2V5LCBhY3R1YWxLZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWRLZXkgPT09IGFjdHVhbEtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSGFzIGFsbFxuICAgIGlmIChhbGwpIHtcbiAgICAgIG9rID0gZXhwZWN0ZWQuZXZlcnkoZnVuY3Rpb24oZXhwZWN0ZWRLZXkpIHtcbiAgICAgICAgcmV0dXJuIGFjdHVhbC5zb21lKGZ1bmN0aW9uKGFjdHVhbEtleSkge1xuICAgICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBfLmVxbChleHBlY3RlZEtleSwgYWN0dWFsS2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkS2V5ID09PSBhY3R1YWxLZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWZsYWcodGhpcywgJ2NvbnRhaW5zJykpIHtcbiAgICAgICAgb2sgPSBvayAmJiBrZXlzLmxlbmd0aCA9PSBhY3R1YWwubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEtleSBzdHJpbmdcbiAgICBpZiAobGVuID4gMSkge1xuICAgICAga2V5cyA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gXy5pbnNwZWN0KGtleSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0ga2V5cy5wb3AoKTtcbiAgICAgIGlmIChhbGwpIHtcbiAgICAgICAgc3RyID0ga2V5cy5qb2luKCcsICcpICsgJywgYW5kICcgKyBsYXN0O1xuICAgICAgfVxuICAgICAgaWYgKGFueSkge1xuICAgICAgICBzdHIgPSBrZXlzLmpvaW4oJywgJykgKyAnLCBvciAnICsgbGFzdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gXy5pbnNwZWN0KGtleXNbMF0pO1xuICAgIH1cblxuICAgIC8vIEZvcm1cbiAgICBzdHIgPSAobGVuID4gMSA/ICdrZXlzICcgOiAna2V5ICcpICsgc3RyO1xuXG4gICAgLy8gSGF2ZSAvIGluY2x1ZGVcbiAgICBzdHIgPSAoZmxhZyh0aGlzLCAnY29udGFpbnMnKSA/ICdjb250YWluICcgOiAnaGF2ZSAnKSArIHN0cjtcblxuICAgIC8vIEFzc2VydGlvblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBva1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byAnICsgZGVlcFN0ciArIHN0clxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgJyArIGRlZXBTdHIgKyBzdHJcbiAgICAgICwgZXhwZWN0ZWQuc2xpY2UoMCkuc29ydChfLmNvbXBhcmVCeUluc3BlY3QpXG4gICAgICAsIGFjdHVhbC5zb3J0KF8uY29tcGFyZUJ5SW5zcGVjdClcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdrZXlzJywgYXNzZXJ0S2V5cyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2tleScsIGFzc2VydEtleXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnRocm93KFtlcnJvckxpa2VdLCBbZXJyTXNnTWF0Y2hlcl0sIFttc2ddKVxuICAgKlxuICAgKiBXaGVuIG5vIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGAudGhyb3dgIGludm9rZXMgdGhlIHRhcmdldCBmdW5jdGlvbiBhbmRcbiAgICogYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93bi5cbiAgICpcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KCk7XG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBhbmQgaXQncyBhbiBlcnJvciBjb25zdHJ1Y3RvciwgYC50aHJvd2BcbiAgICogaW52b2tlcyB0aGUgdGFyZ2V0IGZ1bmN0aW9uIGFuZCBhc3NlcnRzIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duIHRoYXQncyBhblxuICAgKiBpbnN0YW5jZSBvZiB0aGF0IGVycm9yIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coVHlwZUVycm9yKTtcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGFuZCBpdCdzIGFuIGVycm9yIGluc3RhbmNlLCBgLnRocm93YCBpbnZva2VzXG4gICAqIHRoZSB0YXJnZXQgZnVuY3Rpb24gYW5kIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24gdGhhdCdzIHN0cmljdGx5XG4gICAqIChgPT09YCkgZXF1YWwgdG8gdGhhdCBlcnJvciBpbnN0YW5jZS5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTtcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhlcnIpO1xuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYW5kIGl0J3MgYSBzdHJpbmcsIGAudGhyb3dgIGludm9rZXMgdGhlXG4gICAqIHRhcmdldCBmdW5jdGlvbiBhbmQgYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93biB3aXRoIGEgbWVzc2FnZSB0aGF0XG4gICAqIGNvbnRhaW5zIHRoYXQgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coJ3NhbG1vbicpO1xuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYW5kIGl0J3MgYSByZWd1bGFyIGV4cHJlc3Npb24sIGAudGhyb3dgXG4gICAqIGludm9rZXMgdGhlIHRhcmdldCBmdW5jdGlvbiBhbmQgYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93biB3aXRoIGFcbiAgICogbWVzc2FnZSB0aGF0IG1hdGNoZXMgdGhhdCByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqXG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdygvc2FsbW9uLyk7XG4gICAqXG4gICAqIFdoZW4gdHdvIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGFuZCB0aGUgZmlyc3QgaXMgYW4gZXJyb3IgaW5zdGFuY2Ugb3JcbiAgICogY29uc3RydWN0b3IsIGFuZCB0aGUgc2Vjb25kIGlzIGEgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiwgYC50aHJvd2BcbiAgICogaW52b2tlcyB0aGUgZnVuY3Rpb24gYW5kIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24gdGhhdCBmdWxmaWxscyBib3RoXG4gICAqIGNvbmRpdGlvbnMgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKlxuICAgKiAgICAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpO1xuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KFR5cGVFcnJvciwgJ3NhbG1vbicpO1xuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhUeXBlRXJyb3IsIC9zYWxtb24vKTtcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coZXJyLCAnc2FsbW9uJyk7XG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KGVyciwgL3NhbG1vbi8pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnRocm93YC5cbiAgICpcbiAgICogICAgIHZhciBnb29kRm4gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLm5vdC50aHJvdygpO1xuICAgKlxuICAgKiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byBuZWdhdGUgYC50aHJvd2Agd2hlbiBwcm92aWRpbmcgYW55IGFyZ3VtZW50cy5cbiAgICogVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMgYnkgYXNzZXJ0aW5nIHRoYXQgdGhlXG4gICAqIHRhcmdldCBlaXRoZXIgZG9lc24ndCB0aHJvdyBhbiBlcnJvciwgb3IgdGhhdCBpdCB0aHJvd3MgYW4gZXJyb3IgYnV0IG9mIGFcbiAgICogZGlmZmVyZW50IHR5cGUgdGhhbiB0aGUgZ2l2ZW4gdHlwZSwgb3IgdGhhdCBpdCB0aHJvd3MgYW4gZXJyb3Igb2YgdGhlIGdpdmVuXG4gICAqIHR5cGUgYnV0IHdpdGggYSBtZXNzYWdlIHRoYXQgZG9lc24ndCBpbmNsdWRlIHRoZSBnaXZlbiBzdHJpbmcuIEl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW5cbiAgICogYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXNuJ3QgZXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3IsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgdmFyIGdvb2RGbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGdvb2RGbikudG8ubm90LnRocm93KCk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoZ29vZEZuKS50by5ub3QudGhyb3coUmVmZXJlbmNlRXJyb3IsICd4Jyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3IsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogdGhhdCB0aGUgZXJyb3IgaXMgb2YgaXRzIGV4cGVjdGVkIHR5cGUsIGFuZCBoYXMgYSBtZXNzYWdlIHRoYXQgaW5jbHVkZXMgYW5cbiAgICogZXhwZWN0ZWQgc3RyaW5nLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdCBkb2Vzbid0IGhhdmUgb25lIG9mIG1hbnlcbiAgICogdW5leHBlY3RlZCB0eXBlcywgYW5kIGRvZXNuJ3QgaGF2ZSBhIG1lc3NhZ2UgdGhhdCBpbmNsdWRlcyBzb21lIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KFR5cGVFcnJvciwgJ3NhbG1vbicpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by5ub3QudGhyb3coUmVmZXJlbmNlRXJyb3IsICd4Jyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLnRocm93YCBjaGFuZ2VzIHRoZSB0YXJnZXQgb2YgYW55IGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvXG4gICAqIGJlIHRoZSBlcnJvciBvYmplY3QgdGhhdCdzIHRocm93bi5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTtcbiAgICogICAgIGVyci5jb2RlID0gNDI7XG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coVHlwZUVycm9yKS53aXRoLnByb3BlcnR5KCdjb2RlJywgNDIpO1xuICAgKlxuICAgKiBgLnRocm93YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZyB0d28gYXJndW1lbnRzLCBhbHdheXMgdXNlXG4gICAqIHRoZSBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIHZhciBnb29kRm4gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLnRocm93KFR5cGVFcnJvciwgJ3gnLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoZ29vZEZuLCAnbm9vbyB3aHkgZmFpbD8/JykudG8udGhyb3coKTtcbiAgICpcbiAgICogRHVlIHRvIGxpbWl0YXRpb25zIGluIEVTNSwgYC50aHJvd2AgbWF5IG5vdCBhbHdheXMgd29yayBhcyBleHBlY3RlZCB3aGVuXG4gICAqIHVzaW5nIGEgdHJhbnNwaWxlciBzdWNoIGFzIEJhYmVsIG9yIFR5cGVTY3JpcHQuIEluIHBhcnRpY3VsYXIsIGl0IG1heVxuICAgKiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cyB3aGVuIHN1YmNsYXNzaW5nIHRoZSBidWlsdC1pbiBgRXJyb3JgIG9iamVjdCBhbmRcbiAgICogdGhlbiBwYXNzaW5nIHRoZSBzdWJjbGFzc2VkIGNvbnN0cnVjdG9yIHRvIGAudGhyb3dgLiBTZWUgeW91ciB0cmFuc3BpbGVyJ3NcbiAgICogZG9jcyBmb3IgZGV0YWlsczpcbiAgICpcbiAgICogLSAoW0JhYmVsXShodHRwczovL2JhYmVsanMuaW8vZG9jcy91c2FnZS9jYXZlYXRzLyNjbGFzc2VzKSlcbiAgICogLSAoW1R5cGVTY3JpcHRdKGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC93aWtpL0JyZWFraW5nLUNoYW5nZXMjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrKSlcbiAgICpcbiAgICogQmV3YXJlIG9mIHNvbWUgY29tbW9uIG1pc3Rha2VzIHdoZW4gdXNpbmcgdGhlIGB0aHJvd2AgYXNzZXJ0aW9uLiBPbmUgY29tbW9uXG4gICAqIG1pc3Rha2UgaXMgdG8gYWNjaWRlbnRhbGx5IGludm9rZSB0aGUgZnVuY3Rpb24geW91cnNlbGYgaW5zdGVhZCBvZiBsZXR0aW5nXG4gICAqIHRoZSBgdGhyb3dgIGFzc2VydGlvbiBpbnZva2UgdGhlIGZ1bmN0aW9uIGZvciB5b3UuIEZvciBleGFtcGxlLCB3aGVuXG4gICAqIHRlc3RpbmcgaWYgYSBmdW5jdGlvbiBuYW1lZCBgZm5gIHRocm93cywgcHJvdmlkZSBgZm5gIGluc3RlYWQgb2YgYGZuKClgIGFzXG4gICAqIHRoZSB0YXJnZXQgZm9yIHRoZSBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KCk7ICAgICAvLyBHb29kISBUZXN0cyBgZm5gIGFzIGRlc2lyZWRcbiAgICogICAgIGV4cGVjdChmbigpKS50by50aHJvdygpOyAgIC8vIEJhZCEgVGVzdHMgcmVzdWx0IG9mIGBmbigpYCwgbm90IGBmbmBcbiAgICpcbiAgICogSWYgeW91IG5lZWQgdG8gYXNzZXJ0IHRoYXQgeW91ciBmdW5jdGlvbiBgZm5gIHRocm93cyB3aGVuIHBhc3NlZCBjZXJ0YWluXG4gICAqIGFyZ3VtZW50cywgdGhlbiB3cmFwIGEgY2FsbCB0byBgZm5gIGluc2lkZSBvZiBhbm90aGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZ1bmN0aW9uICgpIHsgZm4oNDIpOyB9KS50by50aHJvdygpOyAgLy8gRnVuY3Rpb24gZXhwcmVzc2lvblxuICAgKiAgICAgZXhwZWN0KCgpID0+IGZuKDQyKSkudG8udGhyb3coKTsgICAgICAgICAgICAgLy8gRVM2IGFycm93IGZ1bmN0aW9uXG4gICAqXG4gICAqIEFub3RoZXIgY29tbW9uIG1pc3Rha2UgaXMgdG8gcHJvdmlkZSBhbiBvYmplY3QgbWV0aG9kIChvciBhbnkgc3RhbmQtYWxvbmVcbiAgICogZnVuY3Rpb24gdGhhdCByZWxpZXMgb24gYHRoaXNgKSBhcyB0aGUgdGFyZ2V0IG9mIHRoZSBhc3NlcnRpb24uIERvaW5nIHNvIGlzXG4gICAqIHByb2JsZW1hdGljIGJlY2F1c2UgdGhlIGB0aGlzYCBjb250ZXh0IHdpbGwgYmUgbG9zdCB3aGVuIHRoZSBmdW5jdGlvbiBpc1xuICAgKiBpbnZva2VkIGJ5IGAudGhyb3dgOyB0aGVyZSdzIG5vIHdheSBmb3IgaXQgdG8ga25vdyB3aGF0IGB0aGlzYCBpcyBzdXBwb3NlZFxuICAgKiB0byBiZS4gVGhlcmUgYXJlIHR3byB3YXlzIGFyb3VuZCB0aGlzIHByb2JsZW0uIE9uZSBzb2x1dGlvbiBpcyB0byB3cmFwIHRoZVxuICAgKiBtZXRob2Qgb3IgZnVuY3Rpb24gY2FsbCBpbnNpZGUgb2YgYW5vdGhlciBmdW5jdGlvbi4gQW5vdGhlciBzb2x1dGlvbiBpcyB0b1xuICAgKiB1c2UgYGJpbmRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZ1bmN0aW9uICgpIHsgY2F0Lm1lb3coKTsgfSkudG8udGhyb3coKTsgIC8vIEZ1bmN0aW9uIGV4cHJlc3Npb25cbiAgICogICAgIGV4cGVjdCgoKSA9PiBjYXQubWVvdygpKS50by50aHJvdygpOyAgICAgICAgICAgICAvLyBFUzYgYXJyb3cgZnVuY3Rpb25cbiAgICogICAgIGV4cGVjdChjYXQubWVvdy5iaW5kKGNhdCkpLnRvLnRocm93KCk7ICAgICAgICAgICAvLyBCaW5kXG4gICAqXG4gICAqIEZpbmFsbHksIGl0J3Mgd29ydGggbWVudGlvbmluZyB0aGF0IGl0J3MgYSBiZXN0IHByYWN0aWNlIGluIEphdmFTY3JpcHQgdG9cbiAgICogb25seSB0aHJvdyBgRXJyb3JgIGFuZCBkZXJpdmF0aXZlcyBvZiBgRXJyb3JgIHN1Y2ggYXMgYFJlZmVyZW5jZUVycm9yYCxcbiAgICogYFR5cGVFcnJvcmAsIGFuZCB1c2VyLWRlZmluZWQgb2JqZWN0cyB0aGF0IGV4dGVuZCBgRXJyb3JgLiBObyBvdGhlciB0eXBlIG9mXG4gICAqIHZhbHVlIHdpbGwgZ2VuZXJhdGUgYSBzdGFjayB0cmFjZSB3aGVuIGluaXRpYWxpemVkLiBXaXRoIHRoYXQgc2FpZCwgdGhlXG4gICAqIGB0aHJvd2AgYXNzZXJ0aW9uIGRvZXMgdGVjaG5pY2FsbHkgc3VwcG9ydCBhbnkgdHlwZSBvZiB2YWx1ZSBiZWluZyB0aHJvd24sXG4gICAqIG5vdCBqdXN0IGBFcnJvcmAgYW5kIGl0cyBkZXJpdmF0aXZlcy5cbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC50aHJvd3NgIGFuZCBgLlRocm93YCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aFxuICAgKiBgLnRocm93YC5cbiAgICpcbiAgICogQG5hbWUgdGhyb3dcbiAgICogQGFsaWFzIHRocm93c1xuICAgKiBAYWxpYXMgVGhyb3dcbiAgICogQHBhcmFtIHtFcnJvcnxFcnJvckNvbnN0cnVjdG9yfSBlcnJvckxpa2VcbiAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBlcnJNc2dNYXRjaGVyIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQHJldHVybnMgZXJyb3IgZm9yIGNoYWluaW5nIChudWxsIGlmIG5vIGVycm9yKVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRUaHJvd3MgKGVycm9yTGlrZSwgZXJyTXNnTWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBuZWdhdGUgPSBmbGFnKHRoaXMsICduZWdhdGUnKSB8fCBmYWxzZTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIGVycm9yTGlrZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVyck1zZ01hdGNoZXIgPSBlcnJvckxpa2U7XG4gICAgICBlcnJvckxpa2UgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBjYXVnaHRFcnI7XG4gICAgdHJ5IHtcbiAgICAgIG9iaigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2F1Z2h0RXJyID0gZXJyO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgdGhlIG5lZ2F0ZSBmbGFnIGVuYWJsZWQgYW5kIGF0IGxlYXN0IG9uZSB2YWxpZCBhcmd1bWVudCBpdCBtZWFucyB3ZSBkbyBleHBlY3QgYW4gZXJyb3JcbiAgICAvLyBidXQgd2Ugd2FudCBpdCB0byBtYXRjaCBhIGdpdmVuIHNldCBvZiBjcml0ZXJpYVxuICAgIHZhciBldmVyeUFyZ0lzVW5kZWZpbmVkID0gZXJyb3JMaWtlID09PSB1bmRlZmluZWQgJiYgZXJyTXNnTWF0Y2hlciA9PT0gdW5kZWZpbmVkO1xuXG4gICAgLy8gSWYgd2UndmUgZ290IHRoZSBuZWdhdGUgZmxhZyBlbmFibGVkIGFuZCBib3RoIGFyZ3MsIHdlIHNob3VsZCBvbmx5IGZhaWwgaWYgYm90aCBhcmVuJ3QgY29tcGF0aWJsZVxuICAgIC8vIFNlZSBJc3N1ZSAjNTUxIGFuZCBQUiAjNjgzQEdpdEh1YlxuICAgIHZhciBldmVyeUFyZ0lzRGVmaW5lZCA9IEJvb2xlYW4oZXJyb3JMaWtlICYmIGVyck1zZ01hdGNoZXIpO1xuICAgIHZhciBlcnJvckxpa2VGYWlsID0gZmFsc2U7XG4gICAgdmFyIGVyck1zZ01hdGNoZXJGYWlsID0gZmFsc2U7XG5cbiAgICAvLyBDaGVja2luZyBpZiBlcnJvciB3YXMgdGhyb3duXG4gICAgaWYgKGV2ZXJ5QXJnSXNVbmRlZmluZWQgfHwgIWV2ZXJ5QXJnSXNVbmRlZmluZWQgJiYgIW5lZ2F0ZSkge1xuICAgICAgLy8gV2UgbmVlZCB0aGlzIHRvIGRpc3BsYXkgcmVzdWx0cyBjb3JyZWN0bHkgYWNjb3JkaW5nIHRvIHRoZWlyIHR5cGVzXG4gICAgICB2YXIgZXJyb3JMaWtlU3RyaW5nID0gJ2FuIGVycm9yJztcbiAgICAgIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBlcnJvckxpa2VTdHJpbmcgPSAnI3tleHB9JztcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3JMaWtlKSB7XG4gICAgICAgIGVycm9yTGlrZVN0cmluZyA9IF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgY2F1Z2h0RXJyXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgJyArIGVycm9yTGlrZVN0cmluZ1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyBhbiBlcnJvciBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICwgZXJyb3JMaWtlICYmIGVycm9yTGlrZS50b1N0cmluZygpXG4gICAgICAgICwgKGNhdWdodEVyciBpbnN0YW5jZW9mIEVycm9yID9cbiAgICAgICAgICAgIGNhdWdodEVyci50b1N0cmluZygpIDogKHR5cGVvZiBjYXVnaHRFcnIgPT09ICdzdHJpbmcnID8gY2F1Z2h0RXJyIDogY2F1Z2h0RXJyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGNhdWdodEVycikpKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JMaWtlICYmIGNhdWdodEVycikge1xuICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgaW5zdGFuY2VzIG9ubHkgaWYgYGVycm9yTGlrZWAgaXMgYW4gaW5zdGFuY2Ugb2YgYEVycm9yYFxuICAgICAgaWYgKGVycm9yTGlrZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHZhciBpc0NvbXBhdGlibGVJbnN0YW5jZSA9IF8uY2hlY2tFcnJvci5jb21wYXRpYmxlSW5zdGFuY2UoY2F1Z2h0RXJyLCBlcnJvckxpa2UpO1xuXG4gICAgICAgIGlmIChpc0NvbXBhdGlibGVJbnN0YW5jZSA9PT0gbmVnYXRlKSB7XG4gICAgICAgICAgLy8gVGhlc2UgY2hlY2tzIHdlcmUgY3JlYXRlZCB0byBlbnN1cmUgd2Ugd29uJ3QgZmFpbCB0b28gc29vbiB3aGVuIHdlJ3ZlIGdvdCBib3RoIGFyZ3MgYW5kIGEgbmVnYXRlXG4gICAgICAgICAgLy8gU2VlIElzc3VlICM1NTEgYW5kIFBSICM2ODNAR2l0SHViXG4gICAgICAgICAgaWYgKGV2ZXJ5QXJnSXNEZWZpbmVkICYmIG5lZ2F0ZSkge1xuICAgICAgICAgICAgZXJyb3JMaWtlRmFpbCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgICAgIG5lZ2F0ZVxuICAgICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfScgKyAoY2F1Z2h0RXJyICYmICFuZWdhdGUgPyAnIGJ1dCAje2FjdH0gd2FzIHRocm93bicgOiAnJylcbiAgICAgICAgICAgICAgLCBlcnJvckxpa2UudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAsIGNhdWdodEVyci50b1N0cmluZygpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb21wYXRpYmxlQ29uc3RydWN0b3IgPSBfLmNoZWNrRXJyb3IuY29tcGF0aWJsZUNvbnN0cnVjdG9yKGNhdWdodEVyciwgZXJyb3JMaWtlKTtcbiAgICAgIGlmIChpc0NvbXBhdGlibGVDb25zdHJ1Y3RvciA9PT0gbmVnYXRlKSB7XG4gICAgICAgIGlmIChldmVyeUFyZ0lzRGVmaW5lZCAmJiBuZWdhdGUpIHtcbiAgICAgICAgICAgIGVycm9yTGlrZUZhaWwgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgICBuZWdhdGVcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfScgKyAoY2F1Z2h0RXJyID8gJyBidXQgI3thY3R9IHdhcyB0aHJvd24nIDogJycpXG4gICAgICAgICAgICAsIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yTGlrZS50b1N0cmluZygpIDogZXJyb3JMaWtlICYmIF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKSlcbiAgICAgICAgICAgICwgKGNhdWdodEVyciBpbnN0YW5jZW9mIEVycm9yID8gY2F1Z2h0RXJyLnRvU3RyaW5nKCkgOiBjYXVnaHRFcnIgJiYgXy5jaGVja0Vycm9yLmdldENvbnN0cnVjdG9yTmFtZShjYXVnaHRFcnIpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2F1Z2h0RXJyICYmIGVyck1zZ01hdGNoZXIgIT09IHVuZGVmaW5lZCAmJiBlcnJNc2dNYXRjaGVyICE9PSBudWxsKSB7XG4gICAgICAvLyBIZXJlIHdlIGNoZWNrIGNvbXBhdGlibGUgbWVzc2FnZXNcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9ICdpbmNsdWRpbmcnO1xuICAgICAgaWYgKGVyck1zZ01hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcGxhY2Vob2xkZXIgPSAnbWF0Y2hpbmcnXG4gICAgICB9XG5cbiAgICAgIHZhciBpc0NvbXBhdGlibGVNZXNzYWdlID0gXy5jaGVja0Vycm9yLmNvbXBhdGlibGVNZXNzYWdlKGNhdWdodEVyciwgZXJyTXNnTWF0Y2hlcik7XG4gICAgICBpZiAoaXNDb21wYXRpYmxlTWVzc2FnZSA9PT0gbmVnYXRlKSB7XG4gICAgICAgIGlmIChldmVyeUFyZ0lzRGVmaW5lZCAmJiBuZWdhdGUpIHtcbiAgICAgICAgICAgIGVyck1zZ01hdGNoZXJGYWlsID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIG5lZ2F0ZVxuICAgICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciAnICsgcGxhY2Vob2xkZXIgKyAnICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3Igbm90ICcgKyBwbGFjZWhvbGRlciArICcgI3tleHB9J1xuICAgICAgICAgICAgLCAgZXJyTXNnTWF0Y2hlclxuICAgICAgICAgICAgLCAgXy5jaGVja0Vycm9yLmdldE1lc3NhZ2UoY2F1Z2h0RXJyKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGFzc2VydGlvbnMgZmFpbGVkIGFuZCBib3RoIHNob3VsZCd2ZSBtYXRjaGVkIHdlIHRocm93IGFuIGVycm9yXG4gICAgaWYgKGVycm9yTGlrZUZhaWwgJiYgZXJyTXNnTWF0Y2hlckZhaWwpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBuZWdhdGVcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0nICsgKGNhdWdodEVyciA/ICcgYnV0ICN7YWN0fSB3YXMgdGhyb3duJyA6ICcnKVxuICAgICAgICAsIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yTGlrZS50b1N0cmluZygpIDogZXJyb3JMaWtlICYmIF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKSlcbiAgICAgICAgLCAoY2F1Z2h0RXJyIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVnaHRFcnIudG9TdHJpbmcoKSA6IGNhdWdodEVyciAmJiBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGNhdWdodEVycikpXG4gICAgICApO1xuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGNhdWdodEVycik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd0aHJvd3MnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdUaHJvdycsIGFzc2VydFRocm93cyk7XG5cbiAgLyoqXG4gICAqICMjIyAucmVzcG9uZFRvKG1ldGhvZFssIG1zZ10pXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIG5vbi1mdW5jdGlvbiBvYmplY3QsIGAucmVzcG9uZFRvYCBhc3NlcnRzIHRoYXQgdGhlXG4gICAqIHRhcmdldCBoYXMgYSBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBgbWV0aG9kYC4gVGhlIG1ldGhvZCBjYW4gYmUgb3duIG9yXG4gICAqIGluaGVyaXRlZCwgYW5kIGl0IGNhbiBiZSBlbnVtZXJhYmxlIG9yIG5vbi1lbnVtZXJhYmxlLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHt9XG4gICAqICAgICBDYXQucHJvdG90eXBlLm1lb3cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgQ2F0KCkpLnRvLnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBmdW5jdGlvbiwgYC5yZXNwb25kVG9gIGFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3NcbiAgICogYHByb3RvdHlwZWAgcHJvcGVydHkgaGFzIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYG1ldGhvZGAuIEFnYWluLCB0aGVcbiAgICogbWV0aG9kIGNhbiBiZSBvd24gb3IgaW5oZXJpdGVkLCBhbmQgaXQgY2FuIGJlIGVudW1lcmFibGUgb3Igbm9uLWVudW1lcmFibGUuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBDYXQgKCkge31cbiAgICogICAgIENhdC5wcm90b3R5cGUubWVvdyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KENhdCkudG8ucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIEFkZCBgLml0c2VsZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gZm9yY2UgYC5yZXNwb25kVG9gIHRvIHRyZWF0IHRoZVxuICAgKiB0YXJnZXQgYXMgYSBub24tZnVuY3Rpb24gb2JqZWN0LCBldmVuIGlmIGl0J3MgYSBmdW5jdGlvbi4gVGh1cywgaXQgYXNzZXJ0c1xuICAgKiB0aGF0IHRoZSB0YXJnZXQgaGFzIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYG1ldGhvZGAsIHJhdGhlciB0aGFuXG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQncyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBoYXMgYSBtZXRob2Qgd2l0aCB0aGVcbiAgICogZ2l2ZW4gbmFtZSBgbWV0aG9kYC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7fVxuICAgKiAgICAgQ2F0LnByb3RvdHlwZS5tZW93ID0gZnVuY3Rpb24gKCkge307XG4gICAqICAgICBDYXQuaGlzcyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KENhdCkuaXRzZWxmLnRvLnJlc3BvbmRUbygnaGlzcycpLmJ1dC5ub3QucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIFdoZW4gbm90IGFkZGluZyBgLml0c2VsZmAsIGl0J3MgaW1wb3J0YW50IHRvIGNoZWNrIHRoZSB0YXJnZXQncyB0eXBlIGJlZm9yZVxuICAgKiB1c2luZyBgLnJlc3BvbmRUb2AuIFNlZSB0aGUgYC5hYCBkb2MgZm9yIGluZm8gb24gY2hlY2tpbmcgYSB0YXJnZXQncyB0eXBlLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHt9XG4gICAqICAgICBDYXQucHJvdG90eXBlLm1lb3cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgQ2F0KCkpLnRvLmJlLmFuKCdvYmplY3QnKS50aGF0LnJlc3BvbmRzVG8oJ21lb3cnKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5yZXNwb25kVG9gLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gRG9nICgpIHt9XG4gICAqICAgICBEb2cucHJvdG90eXBlLmJhcmsgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgRG9nKCkpLnRvLm5vdC5yZXNwb25kVG8oJ21lb3cnKTtcbiAgICpcbiAgICogYC5yZXNwb25kVG9gIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7fSkudG8ucmVzcG9uZFRvKCdtZW93JywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KHt9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8ucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLnJlc3BvbmRzVG9gIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAucmVzcG9uZFRvYC5cbiAgICpcbiAgICogQG5hbWUgcmVzcG9uZFRvXG4gICAqIEBhbGlhcyByZXNwb25kc1RvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlc3BvbmRUbyAobWV0aG9kLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgaXRzZWxmID0gZmxhZyh0aGlzLCAnaXRzZWxmJylcbiAgICAgICwgY29udGV4dCA9ICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygb2JqICYmICFpdHNlbGYpXG4gICAgICAgID8gb2JqLnByb3RvdHlwZVttZXRob2RdXG4gICAgICAgIDogb2JqW21ldGhvZF07XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGNvbnRleHRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gcmVzcG9uZCB0byAnICsgXy5pbnNwZWN0KG1ldGhvZClcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHJlc3BvbmQgdG8gJyArIF8uaW5zcGVjdChtZXRob2QpXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Jlc3BvbmRUbycsIHJlc3BvbmRUbyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Jlc3BvbmRzVG8nLCByZXNwb25kVG8pO1xuXG4gIC8qKlxuICAgKiAjIyMgLml0c2VsZlxuICAgKlxuICAgKiBGb3JjZXMgYWxsIGAucmVzcG9uZFRvYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byBiZWhhdmUgYXMgaWZcbiAgICogdGhlIHRhcmdldCBpcyBhIG5vbi1mdW5jdGlvbiBvYmplY3QsIGV2ZW4gaWYgaXQncyBhIGZ1bmN0aW9uLiBUaHVzLCBpdFxuICAgKiBjYXVzZXMgYC5yZXNwb25kVG9gIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaGFzIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuXG4gICAqIG5hbWUsIHJhdGhlciB0aGFuIGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQncyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBoYXMgYVxuICAgKiBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7fVxuICAgKiAgICAgQ2F0LnByb3RvdHlwZS5tZW93ID0gZnVuY3Rpb24gKCkge307XG4gICAqICAgICBDYXQuaGlzcyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KENhdCkuaXRzZWxmLnRvLnJlc3BvbmRUbygnaGlzcycpLmJ1dC5ub3QucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIEBuYW1lIGl0c2VsZlxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2l0c2VsZicsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdpdHNlbGYnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuc2F0aXNmeShtYXRjaGVyWywgbXNnXSlcbiAgICpcbiAgICogSW52b2tlcyB0aGUgZ2l2ZW4gYG1hdGNoZXJgIGZ1bmN0aW9uIHdpdGggdGhlIHRhcmdldCBiZWluZyBwYXNzZWQgYXMgdGhlXG4gICAqIGZpcnN0IGFyZ3VtZW50LCBhbmQgYXNzZXJ0cyB0aGF0IHRoZSB2YWx1ZSByZXR1cm5lZCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uc2F0aXNmeShmdW5jdGlvbihudW0pIHtcbiAgICogICAgICAgcmV0dXJuIG51bSA+IDA7XG4gICAqICAgICB9KTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5zYXRpc2Z5YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3Quc2F0aXNmeShmdW5jdGlvbihudW0pIHtcbiAgICogICAgICAgcmV0dXJuIG51bSA+IDI7XG4gICAqICAgICB9KTtcbiAgICpcbiAgICogYC5zYXRpc2Z5YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uc2F0aXNmeShmdW5jdGlvbihudW0pIHtcbiAgICogICAgICAgcmV0dXJuIG51bSA+IDI7XG4gICAqICAgICB9LCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLnNhdGlzZnkoZnVuY3Rpb24obnVtKSB7XG4gICAqICAgICAgIHJldHVybiBudW0gPiAyO1xuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLnNhdGlzZmllc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5zYXRpc2Z5YC5cbiAgICpcbiAgICogQG5hbWUgc2F0aXNmeVxuICAgKiBAYWxpYXMgc2F0aXNmaWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1hdGNoZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNhdGlzZnkgKG1hdGNoZXIsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB2YXIgcmVzdWx0ID0gbWF0Y2hlcihvYmopO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICByZXN1bHRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gc2F0aXNmeSAnICsgXy5vYmpEaXNwbGF5KG1hdGNoZXIpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBzYXRpc2Z5JyArIF8ub2JqRGlzcGxheShtYXRjaGVyKVxuICAgICAgLCBmbGFnKHRoaXMsICduZWdhdGUnKSA/IGZhbHNlIDogdHJ1ZVxuICAgICAgLCByZXN1bHRcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc2F0aXNmeScsIHNhdGlzZnkpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzYXRpc2ZpZXMnLCBzYXRpc2Z5KTtcblxuICAvKipcbiAgICogIyMjIC5jbG9zZVRvKGV4cGVjdGVkLCBkZWx0YVssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIHRoYXQncyB3aXRoaW4gYSBnaXZlbiArLy0gYGRlbHRhYCByYW5nZVxuICAgKiBvZiB0aGUgZ2l2ZW4gbnVtYmVyIGBleHBlY3RlZGAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGVcbiAgICogdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMS41KS50by5lcXVhbCgxLjUpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMS41KS50by5iZS5jbG9zZVRvKDEsIDAuNSk7XG4gICAqICAgICBleHBlY3QoMS41KS50by5iZS5jbG9zZVRvKDIsIDAuNSk7XG4gICAqICAgICBleHBlY3QoMS41KS50by5iZS5jbG9zZVRvKDEsIDEpO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmNsb3NlVG9gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uZXF1YWwoMS41KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLm5vdC5iZS5jbG9zZVRvKDMsIDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5jbG9zZVRvYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMS41KS50by5iZS5jbG9zZVRvKDMsIDEsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLjUsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5jbG9zZVRvKDMsIDEpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5hcHByb3hpbWF0ZWx5YCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmNsb3NlVG9gLlxuICAgKlxuICAgKiBAbmFtZSBjbG9zZVRvXG4gICAqIEBhbGlhcyBhcHByb3hpbWF0ZWx5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsb3NlVG8oZXhwZWN0ZWQsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuXG4gICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ251bWJlcicpO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgIT09ICdudW1iZXInIHx8IHR5cGVvZiBkZWx0YSAhPT0gJ251bWJlcicpIHtcbiAgICAgIGZsYWdNc2cgPSBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgOiAnJztcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICBmbGFnTXNnICsgJ3RoZSBhcmd1bWVudHMgdG8gY2xvc2VUbyBvciBhcHByb3hpbWF0ZWx5IG11c3QgYmUgbnVtYmVycycsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHNzZmlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIE1hdGguYWJzKG9iaiAtIGV4cGVjdGVkKSA8PSBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBjbG9zZSB0byAnICsgZXhwZWN0ZWQgKyAnICsvLSAnICsgZGVsdGFcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIGNsb3NlIHRvICcgKyBleHBlY3RlZCArICcgKy8tICcgKyBkZWx0YVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdjbG9zZVRvJywgY2xvc2VUbyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2FwcHJveGltYXRlbHknLCBjbG9zZVRvKTtcblxuICAvLyBOb3RlOiBEdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGlmIHRlc3RpbmcgZm9yIGluY2x1c2lvbiBpbnN0ZWFkIG9mIHNhbWVuZXNzLlxuICBmdW5jdGlvbiBpc1N1YnNldE9mKHN1YnNldCwgc3VwZXJzZXQsIGNtcCwgY29udGFpbnMsIG9yZGVyZWQpIHtcbiAgICBpZiAoIWNvbnRhaW5zKSB7XG4gICAgICBpZiAoc3Vic2V0Lmxlbmd0aCAhPT0gc3VwZXJzZXQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBzdXBlcnNldCA9IHN1cGVyc2V0LnNsaWNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnNldC5ldmVyeShmdW5jdGlvbihlbGVtLCBpZHgpIHtcbiAgICAgIGlmIChvcmRlcmVkKSByZXR1cm4gY21wID8gY21wKGVsZW0sIHN1cGVyc2V0W2lkeF0pIDogZWxlbSA9PT0gc3VwZXJzZXRbaWR4XTtcblxuICAgICAgaWYgKCFjbXApIHtcbiAgICAgICAgdmFyIG1hdGNoSWR4ID0gc3VwZXJzZXQuaW5kZXhPZihlbGVtKTtcbiAgICAgICAgaWYgKG1hdGNoSWR4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIFJlbW92ZSBtYXRjaCBmcm9tIHN1cGVyc2V0IHNvIG5vdCBjb3VudGVkIHR3aWNlIGlmIGR1cGxpY2F0ZSBpbiBzdWJzZXQuXG4gICAgICAgIGlmICghY29udGFpbnMpIHN1cGVyc2V0LnNwbGljZShtYXRjaElkeCwgMSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3VwZXJzZXQuc29tZShmdW5jdGlvbihlbGVtMiwgbWF0Y2hJZHgpIHtcbiAgICAgICAgaWYgKCFjbXAoZWxlbSwgZWxlbTIpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8gUmVtb3ZlIG1hdGNoIGZyb20gc3VwZXJzZXQgc28gbm90IGNvdW50ZWQgdHdpY2UgaWYgZHVwbGljYXRlIGluIHN1YnNldC5cbiAgICAgICAgaWYgKCFjb250YWlucykgc3VwZXJzZXQuc3BsaWNlKG1hdGNoSWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm1lbWJlcnMoc2V0WywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgYXJyYXkgaGFzIHRoZSBzYW1lIG1lbWJlcnMgYXMgdGhlIGdpdmVuIGFycmF5XG4gICAqIGBzZXRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5tZW1iZXJzKFsyLCAxLCAzXSk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDJdKS50by5oYXZlLm1lbWJlcnMoWzIsIDEsIDJdKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgbWVtYmVycyBhcmUgY29tcGFyZWQgdXNpbmcgc3RyaWN0IChgPT09YCkgZXF1YWxpdHkuIEFkZCBgLmRlZXBgXG4gICAqIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIHVzZSBkZWVwIGVxdWFsaXR5IGluc3RlYWQuIFNlZSB0aGUgYGRlZXAtZXFsYFxuICAgKiBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaGFzIG1lbWJlciBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5oYXZlLmRlZXAubWVtYmVycyhbe2E6IDF9XSk7XG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLm5vdC5oYXZlLm1lbWJlcnMoW3thOiAxfV0pO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBvcmRlciBkb2Vzbid0IG1hdHRlci4gQWRkIGAub3JkZXJlZGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG9cbiAgICogcmVxdWlyZSB0aGF0IG1lbWJlcnMgYXBwZWFyIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5vcmRlcmVkLm1lbWJlcnMoWzEsIDIsIDNdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubWVtYmVycyhbMiwgMSwgM10pXG4gICAqICAgICAgIC5idXQubm90Lm9yZGVyZWQubWVtYmVycyhbMiwgMSwgM10pO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBib3RoIGFycmF5cyBtdXN0IGJlIHRoZSBzYW1lIHNpemUuIEFkZCBgLmluY2x1ZGVgIGVhcmxpZXIgaW5cbiAgICogdGhlIGNoYWluIHRvIHJlcXVpcmUgdGhhdCB0aGUgdGFyZ2V0J3MgbWVtYmVycyBiZSBhIHN1cGVyc2V0IG9mIHRoZVxuICAgKiBleHBlY3RlZCBtZW1iZXJzLiBOb3RlIHRoYXQgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBpbiB0aGUgc3Vic2V0IHdoZW5cbiAgICogYC5pbmNsdWRlYCBpcyBhZGRlZC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBpcyBhIHN1cGVyc2V0IG9mIFsxLCAyXSBidXQgbm90IGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5tZW1iZXJzKFsxLCAyXSk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5ub3QuaGF2ZS5tZW1iZXJzKFsxLCAyXSk7XG4gICAqXG4gICAqICAgICAvLyBEdXBsaWNhdGVzIGluIHRoZSBzdWJzZXQgYXJlIGlnbm9yZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUubWVtYmVycyhbMSwgMiwgMiwgMl0pO1xuICAgKlxuICAgKiBgLmRlZXBgLCBgLm9yZGVyZWRgLCBhbmQgYC5pbmNsdWRlYCBjYW4gYWxsIGJlIGNvbWJpbmVkLiBIb3dldmVyLCBpZlxuICAgKiBgLmluY2x1ZGVgIGFuZCBgLm9yZGVyZWRgIGFyZSBjb21iaW5lZCwgdGhlIG9yZGVyaW5nIGJlZ2lucyBhdCB0aGUgc3RhcnQgb2ZcbiAgICogYm90aCBhcnJheXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoW3thOiAxfSwge2I6IDJ9LCB7YzogM31dKVxuICAgKiAgICAgICAudG8uaW5jbHVkZS5kZWVwLm9yZGVyZWQubWVtYmVycyhbe2E6IDF9LCB7YjogMn1dKVxuICAgKiAgICAgICAuYnV0Lm5vdC5pbmNsdWRlLmRlZXAub3JkZXJlZC5tZW1iZXJzKFt7YjogMn0sIHtjOiAzfV0pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm1lbWJlcnNgLiBIb3dldmVyLCBpdCdzXG4gICAqIGRhbmdlcm91cyB0byBkbyBzby4gVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnNcbiAgICogYnkgYXNzZXJ0aW5nIHRoYXQgdGhlIHRhcmdldCBhcnJheSBkb2Vzbid0IGhhdmUgYWxsIG9mIHRoZSBzYW1lIG1lbWJlcnMgYXNcbiAgICogdGhlIGdpdmVuIGFycmF5IGBzZXRgIGJ1dCBtYXkgb3IgbWF5IG5vdCBoYXZlIHNvbWUgb2YgdGhlbS4gSXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhbiBhc3NlcnRpb25cbiAgICogdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5ub3QuaW5jbHVkZSgzKS5hbmQubm90LmluY2x1ZGUoNCk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5ub3QuaGF2ZS5tZW1iZXJzKFszLCA0XSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLm1lbWJlcnNgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLmhhdmUubWVtYmVycyhbMSwgMiwgM10sICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdChbMSwgMl0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLm1lbWJlcnMoWzEsIDIsIDNdKTtcbiAgICpcbiAgICogQG5hbWUgbWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21lbWJlcnMnLCBmdW5jdGlvbiAoc3Vic2V0LCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuXG4gICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmJlLmFuKCdhcnJheScpO1xuICAgIG5ldyBBc3NlcnRpb24oc3Vic2V0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5iZS5hbignYXJyYXknKTtcblxuICAgIHZhciBjb250YWlucyA9IGZsYWcodGhpcywgJ2NvbnRhaW5zJyk7XG4gICAgdmFyIG9yZGVyZWQgPSBmbGFnKHRoaXMsICdvcmRlcmVkJyk7XG5cbiAgICB2YXIgc3ViamVjdCwgZmFpbE1zZywgZmFpbE5lZ2F0ZU1zZztcblxuICAgIGlmIChjb250YWlucykge1xuICAgICAgc3ViamVjdCA9IG9yZGVyZWQgPyAnYW4gb3JkZXJlZCBzdXBlcnNldCcgOiAnYSBzdXBlcnNldCc7XG4gICAgICBmYWlsTXNnID0gJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgJyArIHN1YmplY3QgKyAnIG9mICN7ZXhwfSc7XG4gICAgICBmYWlsTmVnYXRlTXNnID0gJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlICcgKyBzdWJqZWN0ICsgJyBvZiAje2V4cH0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJqZWN0ID0gb3JkZXJlZCA/ICdvcmRlcmVkIG1lbWJlcnMnIDogJ21lbWJlcnMnO1xuICAgICAgZmFpbE1zZyA9ICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgdGhlIHNhbWUgJyArIHN1YmplY3QgKyAnIGFzICN7ZXhwfSc7XG4gICAgICBmYWlsTmVnYXRlTXNnID0gJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgdGhlIHNhbWUgJyArIHN1YmplY3QgKyAnIGFzICN7ZXhwfSc7XG4gICAgfVxuXG4gICAgdmFyIGNtcCA9IGZsYWcodGhpcywgJ2RlZXAnKSA/IF8uZXFsIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGlzU3Vic2V0T2Yoc3Vic2V0LCBvYmosIGNtcCwgY29udGFpbnMsIG9yZGVyZWQpXG4gICAgICAsIGZhaWxNc2dcbiAgICAgICwgZmFpbE5lZ2F0ZU1zZ1xuICAgICAgLCBzdWJzZXRcbiAgICAgICwgb2JqXG4gICAgICAsIHRydWVcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5vbmVPZihsaXN0WywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBtZW1iZXIgb2YgdGhlIGdpdmVuIGFycmF5IGBsaXN0YC4gSG93ZXZlcixcbiAgICogaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLm9uZU9mKFsxLCAyLCAzXSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBDb21wYXJpc29ucyBhcmUgcGVyZm9ybWVkIHVzaW5nIHN0cmljdCAoYD09PWApIGVxdWFsaXR5LlxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm9uZU9mYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUub25lT2YoWzIsIDMsIDRdKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAub25lT2ZgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5vbmVPZihbMiwgMywgNF0sICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUub25lT2YoWzIsIDMsIDRdKTtcbiAgICpcbiAgICogQG5hbWUgb25lT2ZcbiAgICogQHBhcmFtIHtBcnJheTwqPn0gbGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gb25lT2YgKGxpc3QsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBleHBlY3RlZCA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKGxpc3QsIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmJlLmFuKCdhcnJheScpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGxpc3QuaW5kZXhPZihleHBlY3RlZCkgPiAtMVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBvbmUgb2YgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgb25lIG9mICN7ZXhwfSdcbiAgICAgICwgbGlzdFxuICAgICAgLCBleHBlY3RlZFxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdvbmVPZicsIG9uZU9mKTtcblxuICAvKipcbiAgICogIyMjIC5jaGFuZ2Uoc3ViamVjdFssIHByb3BbLCBtc2ddXSlcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGAuY2hhbmdlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGBzdWJqZWN0YCByZXR1cm5zIGEgZGlmZmVyZW50IHZhbHVlIHdoZW4gaXQncyBpbnZva2VkIGJlZm9yZSB0aGUgdGFyZ2V0XG4gICAqIGZ1bmN0aW9uIGNvbXBhcmVkIHRvIHdoZW4gaXQncyBpbnZva2VkIGFmdGVyd2FyZC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IGBzdWJqZWN0YCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICB2YXIgZG90cyA9ICcnXG4gICAqICAgICAgICwgYWRkRG90ID0gZnVuY3Rpb24gKCkgeyBkb3RzICs9ICcuJzsgfVxuICAgKiAgICAgICAsIGdldERvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb3RzOyB9O1xuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChnZXREb3RzKCkpLnRvLmVxdWFsKCcnKTtcbiAgICogICAgIGFkZERvdCgpO1xuICAgKiAgICAgZXhwZWN0KGdldERvdHMoKSkudG8uZXF1YWwoJy4nKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZERvdCkudG8uY2hhbmdlKGdldERvdHMpO1xuICAgKlxuICAgKiBXaGVuIHR3byBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBgLmNoYW5nZWAgYXNzZXJ0cyB0aGF0IHRoZSB2YWx1ZSBvZiB0aGVcbiAgICogZ2l2ZW4gb2JqZWN0IGBzdWJqZWN0YCdzIGBwcm9wYCBwcm9wZXJ0eSBpcyBkaWZmZXJlbnQgYmVmb3JlIGludm9raW5nIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gY29tcGFyZWQgdG8gYWZ0ZXJ3YXJkLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge2RvdHM6ICcnfVxuICAgKiAgICAgICAsIGFkZERvdCA9IGZ1bmN0aW9uICgpIHsgbXlPYmouZG90cyArPSAnLic7IH07XG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG15T2JqKS50by5oYXZlLnByb3BlcnR5KCdkb3RzJywgJycpO1xuICAgKiAgICAgYWRkRG90KCk7XG4gICAqICAgICBleHBlY3QobXlPYmopLnRvLmhhdmUucHJvcGVydHkoJ2RvdHMnLCAnLicpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkRG90KS50by5jaGFuZ2UobXlPYmosICdkb3RzJyk7XG4gICAqXG4gICAqIFN0cmljdCAoYD09PWApIGVxdWFsaXR5IGlzIHVzZWQgdG8gY29tcGFyZSBiZWZvcmUgYW5kIGFmdGVyIHZhbHVlcy5cbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5jaGFuZ2VgLlxuICAgKlxuICAgKiAgICAgdmFyIGRvdHMgPSAnJ1xuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuICAgKiAgICAgICAsIGdldERvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb3RzOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5jaGFuZ2UoZ2V0RG90cyk7XG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7ZG90czogJyd9XG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5jaGFuZ2UobXlPYmosICdkb3RzJyk7XG4gICAqXG4gICAqIGAuY2hhbmdlYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZyB0d28gYXJndW1lbnRzLCBhbHdheXNcbiAgICogdXNlIHRoZSBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHtkb3RzOiAnJ31cbiAgICogICAgICAgLCBhZGREb3QgPSBmdW5jdGlvbiAoKSB7IG15T2JqLmRvdHMgKz0gJy4nOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZERvdCkudG8ubm90LmNoYW5nZShteU9iaiwgJ2RvdHMnLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqICAgICB2YXIgZG90cyA9ICcnXG4gICAqICAgICAgICwgYWRkRG90ID0gZnVuY3Rpb24gKCkgeyBkb3RzICs9ICcuJzsgfVxuICAgKiAgICAgICAsIGdldERvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb3RzOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZERvdCwgJ25vb28gd2h5IGZhaWw/PycpLnRvLm5vdC5jaGFuZ2UoZ2V0RG90cyk7XG4gICAqXG4gICAqIGAuY2hhbmdlYCBhbHNvIGNhdXNlcyBhbGwgYC5ieWAgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG9cbiAgICogYXNzZXJ0IGhvdyBtdWNoIGEgbnVtZXJpYyBzdWJqZWN0IHdhcyBpbmNyZWFzZWQgb3IgZGVjcmVhc2VkIGJ5LiBIb3dldmVyLFxuICAgKiBpdCdzIGRhbmdlcm91cyB0byB1c2UgYC5jaGFuZ2UuYnlgLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXNcbiAgICogdW5jZXJ0YWluIGV4cGVjdGF0aW9ucyBieSBhc3NlcnRpbmcgdGhhdCB0aGUgc3ViamVjdCBlaXRoZXIgaW5jcmVhc2VzIGJ5XG4gICAqIHRoZSBnaXZlbiBkZWx0YSwgb3IgdGhhdCBpdCBkZWNyZWFzZXMgYnkgdGhlIGdpdmVuIGRlbHRhLiBJdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuIGFzc2VydGlvblxuICAgKiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgLT0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5jaGFuZ2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmNoYW5nZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuY2hhbmdlc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5jaGFuZ2VgLlxuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VcbiAgICogQGFsaWFzIGNoYW5nZXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN1YmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRDaGFuZ2VzIChzdWJqZWN0LCBwcm9wLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZm4gPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgbmV3IEFzc2VydGlvbihmbiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciBpbml0aWFsO1xuICAgIGlmICghcHJvcCkge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3RbcHJvcF07XG4gICAgfVxuXG4gICAgZm4oKTtcblxuICAgIHZhciBmaW5hbCA9IHByb3AgPT09IHVuZGVmaW5lZCB8fCBwcm9wID09PSBudWxsID8gc3ViamVjdCgpIDogc3ViamVjdFtwcm9wXTtcbiAgICB2YXIgbXNnT2JqID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBpbml0aWFsIDogJy4nICsgcHJvcDtcblxuICAgIC8vIFRoaXMgZ2V0cyBmbGFnZ2VkIGJlY2F1c2Ugb2YgdGhlIC5ieShkZWx0YSkgYXNzZXJ0aW9uXG4gICAgZmxhZyh0aGlzLCAnZGVsdGFNc2dPYmonLCBtc2dPYmopO1xuICAgIGZsYWcodGhpcywgJ2luaXRpYWxEZWx0YVZhbHVlJywgaW5pdGlhbCk7XG4gICAgZmxhZyh0aGlzLCAnZmluYWxEZWx0YVZhbHVlJywgZmluYWwpO1xuICAgIGZsYWcodGhpcywgJ2RlbHRhQmVoYXZpb3InLCAnY2hhbmdlJyk7XG4gICAgZmxhZyh0aGlzLCAncmVhbERlbHRhJywgZmluYWwgIT09IGluaXRpYWwpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpbml0aWFsICE9PSBmaW5hbFxuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gY2hhbmdlJ1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gbm90IGNoYW5nZSdcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2hhbmdlJywgYXNzZXJ0Q2hhbmdlcyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2NoYW5nZXMnLCBhc3NlcnRDaGFuZ2VzKTtcblxuICAvKipcbiAgICogIyMjIC5pbmNyZWFzZShzdWJqZWN0WywgcHJvcFssIG1zZ11dKVxuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYC5pbmNyZWFzZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBmdW5jdGlvblxuICAgKiBgc3ViamVjdGAgcmV0dXJucyBhIGdyZWF0ZXIgbnVtYmVyIHdoZW4gaXQncyBpbnZva2VkIGFmdGVyIGludm9raW5nIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gY29tcGFyZWQgdG8gd2hlbiBpdCdzIGludm9rZWQgYmVmb3JlaGFuZC4gYC5pbmNyZWFzZWAgYWxzb1xuICAgKiBjYXVzZXMgYWxsIGAuYnlgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIGFzc2VydCBob3cgbXVjaFxuICAgKiBncmVhdGVyIG9mIGEgbnVtYmVyIGlzIHJldHVybmVkLiBJdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHJldHVyblxuICAgKiB2YWx1ZSBpbmNyZWFzZWQgYnkgdGhlIGV4cGVjdGVkIGFtb3VudCwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIGl0IGluY3JlYXNlZFxuICAgKiBieSBhbnkgYW1vdW50LlxuICAgKlxuICAgKiAgICAgdmFyIHZhbCA9IDFcbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IHZhbCArPSAyOyB9XG4gICAqICAgICAgICwgZ2V0VmFsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UoZ2V0VmFsKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKGdldFZhbCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHR3byBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBgLmluY3JlYXNlYCBhc3NlcnRzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZVxuICAgKiBnaXZlbiBvYmplY3QgYHN1YmplY3RgJ3MgYHByb3BgIHByb3BlcnR5IGlzIGdyZWF0ZXIgYWZ0ZXIgaW52b2tpbmcgdGhlXG4gICAqIHRhcmdldCBmdW5jdGlvbiBjb21wYXJlZCB0byBiZWZvcmVoYW5kLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmluY3JlYXNlYC4gSG93ZXZlciwgaXQnc1xuICAgKiBkYW5nZXJvdXMgdG8gZG8gc28uIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zXG4gICAqIGJ5IGFzc2VydGluZyB0aGF0IHRoZSBzdWJqZWN0IGVpdGhlciBkZWNyZWFzZXMsIG9yIHRoYXQgaXQgc3RheXMgdGhlIHNhbWUuXG4gICAqIEl0J3Mgb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW5cbiAgICogd3JpdGUgYW4gYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSBzdWJqZWN0IGlzIGV4cGVjdGVkIHRvIGRlY3JlYXNlLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgaXRcbiAgICogZGVjcmVhc2VkIGJ5IHRoZSBleHBlY3RlZCBhbW91bnQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgLT0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8ubm90LmluY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSBzdWJqZWN0IGlzIGV4cGVjdGVkIHRvIHN0YXkgdGhlIHNhbWUsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmNoYW5nZShteU9iaiwgJ3ZhbCcpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5pbmNyZWFzZWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmcgdHdvIGFyZ3VtZW50cywgYWx3YXlzXG4gICAqIHVzZSB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogICAgIHZhciB2YWwgPSAxXG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG4gICAqICAgICAgICwgZ2V0VmFsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3AsICdub29vIHdoeSBmYWlsPz8nKS50by5pbmNyZWFzZShnZXRWYWwpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5pbmNyZWFzZXNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuaW5jcmVhc2VgLlxuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZVxuICAgKiBAYWxpYXMgaW5jcmVhc2VzXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzdWJqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW5jcmVhc2VzIChzdWJqZWN0LCBwcm9wLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZm4gPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgbmV3IEFzc2VydGlvbihmbiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciBpbml0aWFsO1xuICAgIGlmICghcHJvcCkge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3RbcHJvcF07XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlclxuICAgIG5ldyBBc3NlcnRpb24oaW5pdGlhbCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnbnVtYmVyJyk7XG5cbiAgICBmbigpO1xuXG4gICAgdmFyIGZpbmFsID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBzdWJqZWN0KCkgOiBzdWJqZWN0W3Byb3BdO1xuICAgIHZhciBtc2dPYmogPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IGluaXRpYWwgOiAnLicgKyBwcm9wO1xuXG4gICAgZmxhZyh0aGlzLCAnZGVsdGFNc2dPYmonLCBtc2dPYmopO1xuICAgIGZsYWcodGhpcywgJ2luaXRpYWxEZWx0YVZhbHVlJywgaW5pdGlhbCk7XG4gICAgZmxhZyh0aGlzLCAnZmluYWxEZWx0YVZhbHVlJywgZmluYWwpO1xuICAgIGZsYWcodGhpcywgJ2RlbHRhQmVoYXZpb3InLCAnaW5jcmVhc2UnKTtcbiAgICBmbGFnKHRoaXMsICdyZWFsRGVsdGEnLCBmaW5hbCAtIGluaXRpYWwpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBmaW5hbCAtIGluaXRpYWwgPiAwXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBpbmNyZWFzZSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIG5vdCBpbmNyZWFzZSdcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5jcmVhc2UnLCBhc3NlcnRJbmNyZWFzZXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbmNyZWFzZXMnLCBhc3NlcnRJbmNyZWFzZXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlY3JlYXNlKHN1YmplY3RbLCBwcm9wWywgbXNnXV0pXG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBgLmRlY3JlYXNlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGBzdWJqZWN0YCByZXR1cm5zIGEgbGVzc2VyIG51bWJlciB3aGVuIGl0J3MgaW52b2tlZCBhZnRlciBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIHdoZW4gaXQncyBpbnZva2VkIGJlZm9yZWhhbmQuIGAuZGVjcmVhc2VgIGFsc29cbiAgICogY2F1c2VzIGFsbCBgLmJ5YCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byBhc3NlcnQgaG93IG11Y2hcbiAgICogbGVzc2VyIG9mIGEgbnVtYmVyIGlzIHJldHVybmVkLiBJdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHJldHVyblxuICAgKiB2YWx1ZSBkZWNyZWFzZWQgYnkgdGhlIGV4cGVjdGVkIGFtb3VudCwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIGl0IGRlY3JlYXNlZFxuICAgKiBieSBhbnkgYW1vdW50LlxuICAgKlxuICAgKiAgICAgdmFyIHZhbCA9IDFcbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgdmFsIC09IDI7IH1cbiAgICogICAgICAgLCBnZXRWYWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWw7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKGdldFZhbCkuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKGdldFZhbCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHR3byBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBgLmRlY3JlYXNlYCBhc3NlcnRzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZVxuICAgKiBnaXZlbiBvYmplY3QgYHN1YmplY3RgJ3MgYHByb3BgIHByb3BlcnR5IGlzIGxlc3NlciBhZnRlciBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIGJlZm9yZWhhbmQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgLT0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZGVjcmVhc2VgLiBIb3dldmVyLCBpdCdzXG4gICAqIGRhbmdlcm91cyB0byBkbyBzby4gVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnNcbiAgICogYnkgYXNzZXJ0aW5nIHRoYXQgdGhlIHN1YmplY3QgZWl0aGVyIGluY3JlYXNlcywgb3IgdGhhdCBpdCBzdGF5cyB0aGUgc2FtZS5cbiAgICogSXQncyBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlblxuICAgKiB3cml0ZSBhbiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHN1YmplY3QgaXMgZXhwZWN0ZWQgdG8gaW5jcmVhc2UsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCBpdFxuICAgKiBpbmNyZWFzZWQgYnkgdGhlIGV4cGVjdGVkIGFtb3VudC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5ub3QuZGVjcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHN1YmplY3QgaXMgZXhwZWN0ZWQgdG8gc3RheSB0aGUgc2FtZSwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydFxuICAgKiBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5ub3QuY2hhbmdlKG15T2JqLCAndmFsJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmRlY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmRlY3JlYXNlYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZyB0d28gYXJndW1lbnRzLCBhbHdheXNcbiAgICogdXNlIHRoZSBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiAgICAgdmFyIHZhbCA9IDFcbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge31cbiAgICogICAgICAgLCBnZXRWYWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWw7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmRlY3JlYXNlKGdldFZhbCk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmRlY3JlYXNlc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5kZWNyZWFzZWAuXG4gICAqXG4gICAqIEBuYW1lIGRlY3JlYXNlXG4gICAqIEBhbGlhcyBkZWNyZWFzZXNcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHN1YmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnREZWNyZWFzZXMgKHN1YmplY3QsIHByb3AsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBmbiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuXG4gICAgdmFyIGluaXRpYWw7XG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdFtwcm9wXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyXG4gICAgbmV3IEFzc2VydGlvbihpbml0aWFsLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdudW1iZXInKTtcblxuICAgIGZuKCk7XG5cbiAgICB2YXIgZmluYWwgPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IHN1YmplY3QoKSA6IHN1YmplY3RbcHJvcF07XG4gICAgdmFyIG1zZ09iaiA9IHByb3AgPT09IHVuZGVmaW5lZCB8fCBwcm9wID09PSBudWxsID8gaW5pdGlhbCA6ICcuJyArIHByb3A7XG5cbiAgICBmbGFnKHRoaXMsICdkZWx0YU1zZ09iaicsIG1zZ09iaik7XG4gICAgZmxhZyh0aGlzLCAnaW5pdGlhbERlbHRhVmFsdWUnLCBpbml0aWFsKTtcbiAgICBmbGFnKHRoaXMsICdmaW5hbERlbHRhVmFsdWUnLCBmaW5hbCk7XG4gICAgZmxhZyh0aGlzLCAnZGVsdGFCZWhhdmlvcicsICdkZWNyZWFzZScpO1xuICAgIGZsYWcodGhpcywgJ3JlYWxEZWx0YScsIGluaXRpYWwgLSBmaW5hbCk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGZpbmFsIC0gaW5pdGlhbCA8IDBcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIGRlY3JlYXNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gbm90IGRlY3JlYXNlJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdkZWNyZWFzZScsIGFzc2VydERlY3JlYXNlcyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2RlY3JlYXNlcycsIGFzc2VydERlY3JlYXNlcyk7XG5cbiAgLyoqXG4gICAqICMjIyAuYnkoZGVsdGFbLCBtc2ddKVxuICAgKlxuICAgKiBXaGVuIGZvbGxvd2luZyBhbiBgLmluY3JlYXNlYCBhc3NlcnRpb24gaW4gdGhlIGNoYWluLCBgLmJ5YCBhc3NlcnRzIHRoYXRcbiAgICogdGhlIHN1YmplY3Qgb2YgdGhlIGAuaW5jcmVhc2VgIGFzc2VydGlvbiBpbmNyZWFzZWQgYnkgdGhlIGdpdmVuIGBkZWx0YWAuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpO1xuICAgKlxuICAgKiBXaGVuIGZvbGxvd2luZyBhIGAuZGVjcmVhc2VgIGFzc2VydGlvbiBpbiB0aGUgY2hhaW4sIGAuYnlgIGFzc2VydHMgdGhhdCB0aGVcbiAgICogc3ViamVjdCBvZiB0aGUgYC5kZWNyZWFzZWAgYXNzZXJ0aW9uIGRlY3JlYXNlZCBieSB0aGUgZ2l2ZW4gYGRlbHRhYC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgc3VidHJhY3RUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCAtPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpO1xuICAgKlxuICAgKiBXaGVuIGZvbGxvd2luZyBhIGAuY2hhbmdlYCBhc3NlcnRpb24gaW4gdGhlIGNoYWluLCBgLmJ5YCBhc3NlcnRzIHRoYXQgdGhlXG4gICAqIHN1YmplY3Qgb2YgdGhlIGAuY2hhbmdlYCBhc3NlcnRpb24gZWl0aGVyIGluY3JlYXNlZCBvciBkZWNyZWFzZWQgYnkgdGhlXG4gICAqIGdpdmVuIGBkZWx0YWAuIEhvd2V2ZXIsIGl0J3MgZGFuZ2Vyb3VzIHRvIHVzZSBgLmNoYW5nZS5ieWAuIFRoZSBwcm9ibGVtIGlzXG4gICAqIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zLiBJdCdzIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlXG4gICAqIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0c1xuICAgKiB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgLT0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5jaGFuZ2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmNoYW5nZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5ieWAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBhc3NlcnQgdGhhdCB0aGUgc3ViamVjdCBjaGFuZ2VkIGJ5IGl0cyBleHBlY3RlZCBkZWx0YSwgcmF0aGVyIHRoYW5cbiAgICogYXNzZXJ0aW5nIHRoYXQgaXQgZGlkbid0IGNoYW5nZSBieSBvbmUgb2YgY291bnRsZXNzIHVuZXhwZWN0ZWQgZGVsdGFzLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9O1xuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnV0Lm5vdC5ieSgzKTtcbiAgICpcbiAgICogYC5ieWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlIHRvXG4gICAqIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kXG4gICAqIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgzLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoYWRkVHdvLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgzKTtcbiAgICpcbiAgICogQG5hbWUgYnlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnREZWx0YShkZWx0YSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICB2YXIgbXNnT2JqID0gZmxhZyh0aGlzLCAnZGVsdGFNc2dPYmonKTtcbiAgICB2YXIgaW5pdGlhbCA9IGZsYWcodGhpcywgJ2luaXRpYWxEZWx0YVZhbHVlJyk7XG4gICAgdmFyIGZpbmFsID0gZmxhZyh0aGlzLCAnZmluYWxEZWx0YVZhbHVlJyk7XG4gICAgdmFyIGJlaGF2aW9yID0gZmxhZyh0aGlzLCAnZGVsdGFCZWhhdmlvcicpO1xuICAgIHZhciByZWFsRGVsdGEgPSBmbGFnKHRoaXMsICdyZWFsRGVsdGEnKTtcblxuICAgIHZhciBleHByZXNzaW9uO1xuICAgIGlmIChiZWhhdmlvciA9PT0gJ2NoYW5nZScpIHtcbiAgICAgIGV4cHJlc3Npb24gPSBNYXRoLmFicyhmaW5hbCAtIGluaXRpYWwpID09PSBNYXRoLmFicyhkZWx0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cHJlc3Npb24gPSByZWFsRGVsdGEgPT09IE1hdGguYWJzKGRlbHRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGV4cHJlc3Npb25cbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvICcgKyBiZWhhdmlvciArICcgYnkgJyArIGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBub3QgJyArIGJlaGF2aW9yICsgJyBieSAnICsgZGVsdGFcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYnknLCBhc3NlcnREZWx0YSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXh0ZW5zaWJsZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBleHRlbnNpYmxlLCB3aGljaCBtZWFucyB0aGF0IG5ldyBwcm9wZXJ0aWVzIGNhblxuICAgKiBiZSBhZGRlZCB0byBpdC4gUHJpbWl0aXZlcyBhcmUgbmV2ZXIgZXh0ZW5zaWJsZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmJlLmV4dGVuc2libGU7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZXh0ZW5zaWJsZWAuXG4gICAqXG4gICAqICAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSlcbiAgICogICAgICAgLCBzZWFsZWRPYmplY3QgPSBPYmplY3Quc2VhbCh7fSlcbiAgICogICAgICAgLCBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub25FeHRlbnNpYmxlT2JqZWN0KS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgICogICAgIGV4cGVjdChzZWFsZWRPYmplY3QpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICAgKiAgICAgZXhwZWN0KGZyb3plbk9iamVjdCkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmV4dGVuc2libGU7XG4gICAqXG4gICAqIEBuYW1lIGV4dGVuc2libGVcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdleHRlbnNpYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgLy8gSW4gRVM1LCBpZiB0aGUgYXJndW1lbnQgdG8gdGhpcyBtZXRob2QgaXMgYSBwcmltaXRpdmUsIHRoZW4gaXQgd2lsbCBjYXVzZSBhIFR5cGVFcnJvci5cbiAgICAvLyBJbiBFUzYsIGEgbm9uLW9iamVjdCBhcmd1bWVudCB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2FzIGEgbm9uLWV4dGVuc2libGUgb3JkaW5hcnkgb2JqZWN0LCBzaW1wbHkgcmV0dXJuIGZhbHNlLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc0V4dGVuc2libGVcbiAgICAvLyBUaGUgZm9sbG93aW5nIHByb3ZpZGVzIEVTNiBiZWhhdmlvciBmb3IgRVM1IGVudmlyb25tZW50cy5cblxuICAgIHZhciBpc0V4dGVuc2libGUgPSBvYmogPT09IE9iamVjdChvYmopICYmIE9iamVjdC5pc0V4dGVuc2libGUob2JqKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgaXNFeHRlbnNpYmxlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGV4dGVuc2libGUnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBleHRlbnNpYmxlJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnNlYWxlZFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzZWFsZWQsIHdoaWNoIG1lYW5zIHRoYXQgbmV3IHByb3BlcnRpZXMgY2FuJ3QgYmVcbiAgICogYWRkZWQgdG8gaXQsIGFuZCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW4ndCBiZSByZWNvbmZpZ3VyZWQgb3IgZGVsZXRlZC5cbiAgICogSG93ZXZlciwgaXQncyBwb3NzaWJsZSB0aGF0IGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbiBzdGlsbCBiZSByZWFzc2lnbmVkXG4gICAqIHRvIGRpZmZlcmVudCB2YWx1ZXMuIFByaW1pdGl2ZXMgYXJlIGFsd2F5cyBzZWFsZWQuXG4gICAqXG4gICAqICAgICB2YXIgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHNlYWxlZE9iamVjdCkudG8uYmUuc2VhbGVkO1xuICAgKiAgICAgZXhwZWN0KGZyb3plbk9iamVjdCkudG8uYmUuc2VhbGVkO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLnNlYWxlZDtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5zZWFsZWRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmJlLnNlYWxlZDtcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5zZWFsZWQ7XG4gICAqXG4gICAqIEBuYW1lIHNlYWxlZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3NlYWxlZCcsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIC8vIEluIEVTNSwgaWYgdGhlIGFyZ3VtZW50IHRvIHRoaXMgbWV0aG9kIGlzIGEgcHJpbWl0aXZlLCB0aGVuIGl0IHdpbGwgY2F1c2UgYSBUeXBlRXJyb3IuXG4gICAgLy8gSW4gRVM2LCBhIG5vbi1vYmplY3QgYXJndW1lbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdhcyBhIHNlYWxlZCBvcmRpbmFyeSBvYmplY3QsIHNpbXBseSByZXR1cm4gdHJ1ZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzU2VhbGVkXG4gICAgLy8gVGhlIGZvbGxvd2luZyBwcm92aWRlcyBFUzYgYmVoYXZpb3IgZm9yIEVTNSBlbnZpcm9ubWVudHMuXG5cbiAgICB2YXIgaXNTZWFsZWQgPSBvYmogPT09IE9iamVjdChvYmopID8gT2JqZWN0LmlzU2VhbGVkKG9iaikgOiB0cnVlO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpc1NlYWxlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBzZWFsZWQnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBzZWFsZWQnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZnJvemVuXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGZyb3plbiwgd2hpY2ggbWVhbnMgdGhhdCBuZXcgcHJvcGVydGllcyBjYW4ndCBiZVxuICAgKiBhZGRlZCB0byBpdCwgYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbid0IGJlIHJlYXNzaWduZWQgdG8gZGlmZmVyZW50XG4gICAqIHZhbHVlcywgcmVjb25maWd1cmVkLCBvciBkZWxldGVkLiBQcmltaXRpdmVzIGFyZSBhbHdheXMgZnJvemVuLlxuICAgKlxuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGZyb3plbk9iamVjdCkudG8uYmUuZnJvemVuO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmZyb3plbjtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5mcm96ZW5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmJlLmZyb3plbjtcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5mcm96ZW47XG4gICAqXG4gICAqIEBuYW1lIGZyb3plblxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2Zyb3plbicsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIC8vIEluIEVTNSwgaWYgdGhlIGFyZ3VtZW50IHRvIHRoaXMgbWV0aG9kIGlzIGEgcHJpbWl0aXZlLCB0aGVuIGl0IHdpbGwgY2F1c2UgYSBUeXBlRXJyb3IuXG4gICAgLy8gSW4gRVM2LCBhIG5vbi1vYmplY3QgYXJndW1lbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdhcyBhIGZyb3plbiBvcmRpbmFyeSBvYmplY3QsIHNpbXBseSByZXR1cm4gdHJ1ZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzRnJvemVuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBwcm92aWRlcyBFUzYgYmVoYXZpb3IgZm9yIEVTNSBlbnZpcm9ubWVudHMuXG5cbiAgICB2YXIgaXNGcm96ZW4gPSBvYmogPT09IE9iamVjdChvYmopID8gT2JqZWN0LmlzRnJvemVuKG9iaikgOiB0cnVlO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpc0Zyb3plblxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmcm96ZW4nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBmcm96ZW4nXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZmluaXRlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyLCBhbmQgaXNuJ3QgYE5hTmAgb3IgcG9zaXRpdmUvbmVnYXRpdmVcbiAgICogYEluZmluaXR5YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5maW5pdGU7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZmluaXRlYC4gSG93ZXZlciwgaXQnc1xuICAgKiBkYW5nZXJvdXMgdG8gZG8gc28uIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zXG4gICAqIGJ5IGFzc2VydGluZyB0aGF0IHRoZSBzdWJqZWN0IGVpdGhlciBpc24ndCBhIG51bWJlciwgb3IgdGhhdCBpdCdzIGBOYU5gLCBvclxuICAgKiB0aGF0IGl0J3MgcG9zaXRpdmUgYEluZmluaXR5YCwgb3IgdGhhdCBpdCdzIG5lZ2F0aXZlIGBJbmZpbml0eWAuIEl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW5cbiAgICogYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXNuJ3QgZXhwZWN0ZWQgdG8gYmUgYSBudW1iZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogdGhhdCBpdCdzIHRoZSBleHBlY3RlZCB0eXBlLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdCBpc24ndCBvbmUgb2ZcbiAgICogbWFueSB1bmV4cGVjdGVkIHR5cGVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5iZS5hKCdzdHJpbmcnKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8ubm90LmJlLmZpbml0ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBiZSBgTmFOYCwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCBleGFjdGx5XG4gICAqIHRoYXQuXG4gICAqXG4gICAqICAgICBleHBlY3QoTmFOKS50by5iZS5OYU47IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoTmFOKS50by5ub3QuYmUuZmluaXRlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGJlIHBvc2l0aXZlIGluZmluaXR5LCBpdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIGV4cGVjdChJbmZpbml0eSkudG8uZXF1YWwoSW5maW5pdHkpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KEluZmluaXR5KS50by5ub3QuYmUuZmluaXRlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGJlIG5lZ2F0aXZlIGluZmluaXR5LCBpdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgtSW5maW5pdHkpLnRvLmVxdWFsKC1JbmZpbml0eSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoLUluZmluaXR5KS50by5ub3QuYmUuZmluaXRlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJywgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmZpbml0ZTtcbiAgICpcbiAgICogQG5hbWUgZmluaXRlXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZmluaXRlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdudW1iZXInICYmIGlzRmluaXRlKG9iailcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYSBmaW5pdGUgbnVtYmVyJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYSBmaW5pdGUgbnVtYmVyJ1xuICAgICk7XG4gIH0pO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcbiAgY2hhaS5leHBlY3QgPSBmdW5jdGlvbiAodmFsLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBjaGFpLkFzc2VydGlvbih2YWwsIG1lc3NhZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhaWwoW21lc3NhZ2VdKVxuICAgKiAjIyMgLmZhaWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdLCBbb3BlcmF0b3JdKVxuICAgKlxuICAgKiBUaHJvdyBhIGZhaWx1cmUuXG4gICAqXG4gICAqICAgICBleHBlY3QuZmFpbCgpO1xuICAgKiAgICAgZXhwZWN0LmZhaWwoXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiKTtcbiAgICogICAgIGV4cGVjdC5mYWlsKDEsIDIpO1xuICAgKiAgICAgZXhwZWN0LmZhaWwoMSwgMiwgXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiKTtcbiAgICogICAgIGV4cGVjdC5mYWlsKDEsIDIsIFwiY3VzdG9tIGVycm9yIG1lc3NhZ2VcIiwgXCI+XCIpO1xuICAgKiAgICAgZXhwZWN0LmZhaWwoMSwgMiwgdW5kZWZpbmVkLCBcIj5cIik7XG4gICAqXG4gICAqIEBuYW1lIGZhaWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBjaGFpLmV4cGVjdC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBhY3R1YWw7XG4gICAgICAgIGFjdHVhbCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnZXhwZWN0LmZhaWwoKSc7XG4gICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSwge1xuICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgfSwgY2hhaS5leHBlY3QuZmFpbCk7XG4gIH07XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb247XG5cbiAgZnVuY3Rpb24gbG9hZFNob3VsZCAoKSB7XG4gICAgLy8gZXhwbGljaXRseSBkZWZpbmUgdGhpcyBtZXRob2QgYXMgZnVuY3Rpb24gYXMgdG8gaGF2ZSBpdCdzIG5hbWUgdG8gaW5jbHVkZSBhcyBgc3NmaWBcbiAgICBmdW5jdGlvbiBzaG91bGRHZXR0ZXIoKSB7XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN0cmluZ1xuICAgICAgICAgIHx8IHRoaXMgaW5zdGFuY2VvZiBOdW1iZXJcbiAgICAgICAgICB8fCB0aGlzIGluc3RhbmNlb2YgQm9vbGVhblxuICAgICAgICAgIHx8IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdGhpcyBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0aGlzLnZhbHVlT2YoKSwgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMsIG51bGwsIHNob3VsZEdldHRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFNldHRlcih2YWx1ZSkge1xuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvY2hhaS9pc3N1ZXMvODY6IHRoaXMgbWFrZXNcbiAgICAgIC8vIGB3aGF0ZXZlci5zaG91bGQgPSBzb21lVmFsdWVgIGFjdHVhbGx5IHNldCBgc29tZVZhbHVlYCwgd2hpY2ggaXNcbiAgICAgIC8vIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBgZ2xvYmFsLnNob3VsZCA9IHJlcXVpcmUoJ2NoYWknKS5zaG91bGQoKWAuXG4gICAgICAvL1xuICAgICAgLy8gTm90ZSB0aGF0IHdlIGhhdmUgdG8gdXNlIFtbRGVmaW5lUHJvcGVydHldXSBpbnN0ZWFkIG9mIFtbUHV0XV1cbiAgICAgIC8vIHNpbmNlIG90aGVyd2lzZSB3ZSB3b3VsZCB0cmlnZ2VyIHRoaXMgdmVyeSBzZXR0ZXIhXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Nob3VsZCcsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gbW9kaWZ5IE9iamVjdC5wcm90b3R5cGUgdG8gaGF2ZSBgc2hvdWxkYFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnc2hvdWxkJywge1xuICAgICAgc2V0OiBzaG91bGRTZXR0ZXJcbiAgICAgICwgZ2V0OiBzaG91bGRHZXR0ZXJcbiAgICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgc2hvdWxkID0ge307XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLmZhaWwoW21lc3NhZ2VdKVxuICAgICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAgICpcbiAgICAgKiBUaHJvdyBhIGZhaWx1cmUuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLmZhaWwoKTtcbiAgICAgKiAgICAgc2hvdWxkLmZhaWwoXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiKTtcbiAgICAgKiAgICAgc2hvdWxkLmZhaWwoMSwgMik7XG4gICAgICogICAgIHNob3VsZC5mYWlsKDEsIDIsIFwiY3VzdG9tIGVycm9yIG1lc3NhZ2VcIik7XG4gICAgICogICAgIHNob3VsZC5mYWlsKDEsIDIsIFwiY3VzdG9tIGVycm9yIG1lc3NhZ2VcIiwgXCI+XCIpO1xuICAgICAqICAgICBzaG91bGQuZmFpbCgxLCAyLCB1bmRlZmluZWQsIFwiPlwiKTtcbiAgICAgKlxuICAgICAqXG4gICAgICogQG5hbWUgZmFpbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICAgKiBAbmFtZXNwYWNlIEJERFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQuZmFpbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvcikge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICAgICAgICBhY3R1YWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdzaG91bGQuZmFpbCgpJztcbiAgICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgICAgfSwgc2hvdWxkLmZhaWwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgbm9uLXN0cmljdCBlcXVhbGl0eSAoYD09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLmVxdWFsKDMsICczJywgJz09IGNvZXJjZXMgdmFsdWVzIHRvIHN0cmluZ3MnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIGVxdWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5lcXVhbCA9IGZ1bmN0aW9uICh2YWwxLCB2YWwyLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsMSwgbXNnKS50by5lcXVhbCh2YWwyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC50aHJvdyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3N0cmluZy9yZWdleHBdLCBbc3RyaW5nL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvciB3aXRoIG1lc3NhZ2VcbiAgICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sICdmdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3InKTtcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IpO1xuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IsIC9mdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3IvKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIHRocm93XG4gICAgICogQGFsaWFzIFRocm93XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLlRocm93KGVycnQsIGVycnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLmV4aXN0XG4gICAgICpcbiAgICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGZvbyA9ICdoaSc7XG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLmV4aXN0KGZvbywgJ2ZvbyBleGlzdHMnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIGV4aXN0XG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLmV4aXN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5leGlzdDtcbiAgICB9XG5cbiAgICAvLyBuZWdhdGlvblxuICAgIHNob3VsZC5ub3QgPSB7fVxuXG4gICAgLyoqXG4gICAgICogIyMjIC5ub3QuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgICAqXG4gICAgICogQXNzZXJ0cyBub24tc3RyaWN0IGluZXF1YWxpdHkgKGAhPWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgICAqXG4gICAgICogICAgIHNob3VsZC5ub3QuZXF1YWwoMywgNCwgJ3RoZXNlIG51bWJlcnMgYXJlIG5vdCBlcXVhbCcpO1xuICAgICAqXG4gICAgICogQG5hbWUgbm90LmVxdWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5ub3QuZXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMiwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbDEsIG1zZykudG8ubm90LmVxdWFsKHZhbDIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLnRocm93KGZ1bmN0aW9uLCBbY29uc3RydWN0b3IvcmVnZXhwXSwgW21lc3NhZ2VdKVxuICAgICAqXG4gICAgICogQXNzZXJ0cyB0aGF0IGBmdW5jdGlvbmAgd2lsbCBfbm90XyB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuIGluc3RhbmNlIG9mXG4gICAgICogYGNvbnN0cnVjdG9yYCwgb3IgYWx0ZXJuYXRlbHkgdGhhdCBpdCB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciB3aXRoIG1lc3NhZ2VcbiAgICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQubm90LnRocm93KGZuLCBFcnJvciwgJ2Z1bmN0aW9uIGRvZXMgbm90IHRocm93Jyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBub3QudGhyb3dcbiAgICAgKiBAYWxpYXMgbm90LlRocm93XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5ub3QuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5ub3QuVGhyb3coZXJydCwgZXJycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAubm90LmV4aXN0XG4gICAgICpcbiAgICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGJhciA9IG51bGw7XG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLm5vdC5leGlzdChiYXIsICdiYXIgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIG5vdC5leGlzdFxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5ub3QuZXhpc3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5leGlzdDtcbiAgICB9XG5cbiAgICBzaG91bGRbJ3Rocm93J10gPSBzaG91bGRbJ1Rocm93J107XG4gICAgc2hvdWxkLm5vdFsndGhyb3cnXSA9IHNob3VsZC5ub3RbJ1Rocm93J107XG5cbiAgICByZXR1cm4gc2hvdWxkO1xuICB9O1xuXG4gIGNoYWkuc2hvdWxkID0gbG9hZFNob3VsZDtcbiAgY2hhaS5TaG91bGQgPSBsb2FkU2hvdWxkO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcbiAgLyohXG4gICAqIENoYWkgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb25cbiAgICAsIGZsYWcgPSB1dGlsLmZsYWc7XG5cbiAgLyohXG4gICAqIE1vZHVsZSBleHBvcnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiAjIyMgYXNzZXJ0KGV4cHJlc3Npb24sIG1lc3NhZ2UpXG4gICAqXG4gICAqIFdyaXRlIHlvdXIgb3duIHRlc3QgZXhwcmVzc2lvbnMuXG4gICAqXG4gICAqICAgICBhc3NlcnQoJ2ZvbycgIT09ICdiYXInLCAnZm9vIGlzIG5vdCBiYXInKTtcbiAgICogICAgIGFzc2VydChBcnJheS5pc0FycmF5KFtdKSwgJ2VtcHR5IGFycmF5cyBhcmUgYXJyYXlzJyk7XG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cHJlc3Npb24gdG8gdGVzdCBmb3IgdHJ1dGhpbmVzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSB0byBkaXNwbGF5IG9uIGVycm9yXG4gICAqIEBuYW1lIGFzc2VydFxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB2YXIgYXNzZXJ0ID0gY2hhaS5hc3NlcnQgPSBmdW5jdGlvbiAoZXhwcmVzcywgZXJybXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKG51bGwsIG51bGwsIGNoYWkuYXNzZXJ0LCB0cnVlKTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwcmVzc1xuICAgICAgLCBlcnJtc2dcbiAgICAgICwgJ1sgbmVnYXRpb24gbWVzc2FnZSB1bmF2YWlsYWJsZSBdJ1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZmFpbChbbWVzc2FnZV0pXG4gICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAqXG4gICAqIFRocm93IGEgZmFpbHVyZS4gTm9kZS5qcyBgYXNzZXJ0YCBtb2R1bGUtY29tcGF0aWJsZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5mYWlsKCk7XG4gICAqICAgICBhc3NlcnQuZmFpbChcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIpO1xuICAgKiAgICAgYXNzZXJ0LmZhaWwoMSwgMik7XG4gICAqICAgICBhc3NlcnQuZmFpbCgxLCAyLCBcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIpO1xuICAgKiAgICAgYXNzZXJ0LmZhaWwoMSwgMiwgXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiLCBcIj5cIik7XG4gICAqICAgICBhc3NlcnQuZmFpbCgxLCAyLCB1bmRlZmluZWQsIFwiPlwiKTtcbiAgICpcbiAgICogQG5hbWUgZmFpbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIC8vIENvbXBseSB3aXRoIE5vZGUncyBmYWlsKFttZXNzYWdlXSkgaW50ZXJmYWNlXG5cbiAgICAgICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICAgICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdhc3NlcnQuZmFpbCgpJztcbiAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlLCB7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICB9LCBhc3NlcnQuZmFpbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNPayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIHRydXRoeS5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc09rKCdldmVyeXRoaW5nJywgJ2V2ZXJ5dGhpbmcgaXMgb2snKTtcbiAgICogICAgIGFzc2VydC5pc09rKGZhbHNlLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICpcbiAgICogQG5hbWUgaXNPa1xuICAgKiBAYWxpYXMgb2tcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzT2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNPaywgdHJ1ZSkuaXMub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RPayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGZhbHN5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90T2soJ2V2ZXJ5dGhpbmcnLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICogICAgIGFzc2VydC5pc05vdE9rKGZhbHNlLCAndGhpcyB3aWxsIHBhc3MnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RPa1xuICAgKiBAYWxpYXMgbm90T2tcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90T2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RPaywgdHJ1ZSkuaXMubm90Lm9rO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGVxdWFsaXR5IChgPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5lcXVhbCgzLCAnMycsICc9PSBjb2VyY2VzIHZhbHVlcyB0byBzdHJpbmdzJyk7XG4gICAqXG4gICAqIEBuYW1lIGVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LmVxdWFsLCB0cnVlKTtcblxuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHAgPT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3thY3R9J1xuICAgICAgLCBleHBcbiAgICAgICwgYWN0XG4gICAgICAsIHRydWVcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGluZXF1YWxpdHkgKGAhPWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEVxdWFsKDMsIDQsICd0aGVzZSBudW1iZXJzIGFyZSBub3QgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQubm90RXF1YWwsIHRydWUpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCAhPSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHN0cmljdCBlcXVhbGl0eSAoYD09PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIHRydWUsICd0aGVzZSBib29sZWFucyBhcmUgc3RyaWN0bHkgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgc3RyaWN0RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LnN0cmljdEVxdWFsLCB0cnVlKS50by5lcXVhbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBzdHJpY3QgaW5lcXVhbGl0eSAoYCE9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKDMsICczJywgJ25vIGNvZXJjaW9uIGZvciBzdHJpY3QgZXF1YWxpdHknKTtcbiAgICpcbiAgICogQG5hbWUgbm90U3RyaWN0RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLCB0cnVlKS50by5ub3QuZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGFjdHVhbGAgaXMgZGVlcGx5IGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcEVxdWFsKHsgdGVhOiAnZ3JlZW4nIH0sIHsgdGVhOiAnZ3JlZW4nIH0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwRXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhbGlhcyBkZWVwU3RyaWN0RXF1YWxcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBFcXVhbCA9IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5kZWVwRXF1YWwsIHRydWUpLnRvLmVxbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydCB0aGF0IGBhY3R1YWxgIGlzIG5vdCBkZWVwbHkgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwRXF1YWwoeyB0ZWE6ICdncmVlbicgfSwgeyB0ZWE6ICdqYXNtaW5lJyB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQubm90RGVlcEVxdWFsLCB0cnVlKS50by5ub3QuZXFsKGV4cCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQWJvdmUodmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVBYm92ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiAoPikgYHZhbHVlVG9CZUFib3ZlYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0Fib3ZlKDUsIDIsICc1IGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiAyJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQWJvdmVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUFib3ZlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Fib3ZlID0gZnVuY3Rpb24gKHZhbCwgYWJ2LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNBYm92ZSwgdHJ1ZSkudG8uYmUuYWJvdmUoYWJ2KTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNBdExlYXN0KHZhbHVlVG9DaGVjaywgdmFsdWVUb0JlQXRMZWFzdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAoPj0pIGB2YWx1ZVRvQmVBdExlYXN0YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0F0TGVhc3QoNSwgMiwgJzUgaXMgZ3JlYXRlciBvciBlcXVhbCB0byAyJyk7XG4gICAqICAgICBhc3NlcnQuaXNBdExlYXN0KDMsIDMsICczIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0F0TGVhc3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUF0TGVhc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXRMZWFzdCA9IGZ1bmN0aW9uICh2YWwsIGF0bHN0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNBdExlYXN0LCB0cnVlKS50by5iZS5sZWFzdChhdGxzdCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQmVsb3codmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVCZWxvdywgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIHN0cmljdGx5IGxlc3MgdGhhbiAoPCkgYHZhbHVlVG9CZUJlbG93YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0JlbG93KDMsIDYsICczIGlzIHN0cmljdGx5IGxlc3MgdGhhbiA2Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQmVsb3dcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUJlbG93XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0JlbG93ID0gZnVuY3Rpb24gKHZhbCwgYmx3LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNCZWxvdywgdHJ1ZSkudG8uYmUuYmVsb3coYmx3KTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNBdE1vc3QodmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVBdE1vc3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVUb0NoZWNrYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gKDw9KSBgdmFsdWVUb0JlQXRNb3N0YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0F0TW9zdCgzLCA2LCAnMyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNicpO1xuICAgKiAgICAgYXNzZXJ0LmlzQXRNb3N0KDQsIDQsICc0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byA0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQXRNb3N0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVBdE1vc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXRNb3N0ID0gZnVuY3Rpb24gKHZhbCwgYXRtc3QsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0F0TW9zdCwgdHJ1ZSkudG8uYmUubW9zdChhdG1zdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNUcnVlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIHRydWUuXG4gICAqXG4gICAqICAgICB2YXIgdGVhU2VydmVkID0gdHJ1ZTtcbiAgICogICAgIGFzc2VydC5pc1RydWUodGVhU2VydmVkLCAndGhlIHRlYSBoYXMgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNUcnVlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1RydWUgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNUcnVlLCB0cnVlKS5pc1sndHJ1ZSddO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90VHJ1ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgdHJ1ZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RUcnVlKHRlYSwgJ2dyZWF0LCB0aW1lIGZvciB0ZWEhJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90VHJ1ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RUcnVlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90VHJ1ZSwgdHJ1ZSkudG8ubm90LmVxdWFsKHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRmFsc2UodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgZmFsc2UuXG4gICAqXG4gICAqICAgICB2YXIgdGVhU2VydmVkID0gZmFsc2U7XG4gICAqICAgICBhc3NlcnQuaXNGYWxzZSh0ZWFTZXJ2ZWQsICdubyB0ZWEgeWV0PyBobW0uLi4nKTtcbiAgICpcbiAgICogQG5hbWUgaXNGYWxzZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGYWxzZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0ZhbHNlLCB0cnVlKS5pc1snZmFsc2UnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEZhbHNlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBmYWxzZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RGYWxzZSh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEZhbHNlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZhbHNlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90RmFsc2UsIHRydWUpLnRvLm5vdC5lcXVhbChmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOdWxsKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG51bGwuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOdWxsKGVyciwgJ3RoZXJlIHdhcyBubyBlcnJvcicpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bGxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVsbCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc051bGwsIHRydWUpLnRvLmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90TnVsbCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgbnVsbC5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3ROdWxsKHRlYSwgJ2dyZWF0LCB0aW1lIGZvciB0ZWEhJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVsbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3ROdWxsID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90TnVsbCwgdHJ1ZSkudG8ubm90LmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTmFOXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB2YWx1ZSBpcyBOYU4uXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOYU4oTmFOLCAnTmFOIGlzIE5hTicpO1xuICAgKlxuICAgKiBAbmFtZSBpc05hTlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOYU4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOYU4sIHRydWUpLnRvLmJlLk5hTjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE5hTlxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdmFsdWUgaXMgbm90IE5hTi5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdE5hTig0LCAnNCBpcyBub3QgTmFOJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TmFOXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBhc3NlcnQuaXNOb3ROYU4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3ROYU4sIHRydWUpLm5vdC50by5iZS5OYU47XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZXhpc3RzXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciBmb28gPSAnaGknO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmV4aXN0cyhmb28sICdmb28gaXMgbmVpdGhlciBgbnVsbGAgbm9yIGB1bmRlZmluZWRgJyk7XG4gICAqXG4gICAqIEBuYW1lIGV4aXN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZXhpc3RzID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmV4aXN0cywgdHJ1ZSkudG8uZXhpc3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RXhpc3RzXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVpdGhlciBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgYmFyID0gbnVsbFxuICAgKiAgICAgICAsIGJhejtcbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RFeGlzdHMoYmFyKTtcbiAgICogICAgIGFzc2VydC5ub3RFeGlzdHMoYmF6LCAnYmF6IGlzIGVpdGhlciBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RFeGlzdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEV4aXN0cyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5ub3RFeGlzdHMsIHRydWUpLnRvLm5vdC5leGlzdDtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1VuZGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciB0ZWE7XG4gICAqICAgICBhc3NlcnQuaXNVbmRlZmluZWQodGVhLCAnbm8gdGVhIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNVbmRlZmluZWRcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzVW5kZWZpbmVkLCB0cnVlKS50by5lcXVhbCh1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ2N1cCBvZiBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc0RlZmluZWQodGVhLCAndGVhIGhhcyBiZWVuIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNEZWZpbmVkXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0RlZmluZWQgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNEZWZpbmVkLCB0cnVlKS50by5ub3QuZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Z1bmN0aW9uKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBzZXJ2ZVRlYSgpIHsgcmV0dXJuICdjdXAgb2YgdGVhJzsgfTtcbiAgICogICAgIGFzc2VydC5pc0Z1bmN0aW9uKHNlcnZlVGVhLCAnZ3JlYXQsIHdlIGNhbiBoYXZlIHRlYSBub3cnKTtcbiAgICpcbiAgICogQG5hbWUgaXNGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0Z1bmN0aW9uLCB0cnVlKS50by5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RnVuY3Rpb24odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIHZhciBzZXJ2ZVRlYSA9IFsgJ2hlYXQnLCAncG91cicsICdzaXAnIF07XG4gICAqICAgICBhc3NlcnQuaXNOb3RGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBoYXZlIGxpc3RlZCB0aGUgc3RlcHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdEZ1bmN0aW9uLCB0cnVlKS50by5ub3QuYmUuYSgnZnVuY3Rpb24nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc09iamVjdCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBvYmplY3Qgb2YgdHlwZSAnT2JqZWN0JyAoYXMgcmV2ZWFsZWQgYnkgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgKS5cbiAgICogX1RoZSBhc3NlcnRpb24gZG9lcyBub3QgbWF0Y2ggc3ViY2xhc3NlZCBvYmplY3RzLl9cbiAgICpcbiAgICogICAgIHZhciBzZWxlY3Rpb24gPSB7IG5hbWU6ICdDaGFpJywgc2VydmU6ICd3aXRoIHNwaWNlcycgfTtcbiAgICogICAgIGFzc2VydC5pc09iamVjdChzZWxlY3Rpb24sICd0ZWEgc2VsZWN0aW9uIGlzIGFuIG9iamVjdCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc09iamVjdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNPYmplY3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNPYmplY3QsIHRydWUpLnRvLmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90T2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIG9iamVjdCBvZiB0eXBlICdPYmplY3QnIChhcyByZXZlYWxlZCBieSBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2ApLlxuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9ICdjaGFpJ1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgbm90IGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KG51bGwsICdudWxsIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RPYmplY3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90T2JqZWN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90T2JqZWN0LCB0cnVlKS50by5ub3QuYmUuYSgnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNBcnJheSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBhcnJheS5cbiAgICpcbiAgICogICAgIHZhciBtZW51ID0gWyAnZ3JlZW4nLCAnY2hhaScsICdvb2xvbmcnIF07XG4gICAqICAgICBhc3NlcnQuaXNBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0FycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0FycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzQXJyYXksIHRydWUpLnRvLmJlLmFuKCdhcnJheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90QXJyYXkodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYW4gYXJyYXkuXG4gICAqXG4gICAqICAgICB2YXIgbWVudSA9ICdncmVlbnxjaGFpfG9vbG9uZyc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEFycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEFycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90QXJyYXksIHRydWUpLnRvLm5vdC5iZS5hbignYXJyYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1N0cmluZyh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciB0ZWFPcmRlciA9ICdjaGFpJztcbiAgICogICAgIGFzc2VydC5pc1N0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1N0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNTdHJpbmcsIHRydWUpLnRvLmJlLmEoJ3N0cmluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90U3RyaW5nKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYU9yZGVyID0gNDtcbiAgICogICAgIGFzc2VydC5pc05vdFN0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFN0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RTdHJpbmcsIHRydWUpLnRvLm5vdC5iZS5hKCdzdHJpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc051bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gMjtcbiAgICogICAgIGFzc2VydC5pc051bWJlcihjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTnVtYmVyLCB0cnVlKS50by5iZS5hKCdudW1iZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE51bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gJzIgY3VwcyBwbGVhc2UnO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90TnVtYmVyKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVtYmVyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE51bWJlciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdE51bWJlciwgdHJ1ZSkudG8ubm90LmJlLmEoJ251bWJlcicpO1xuICB9O1xuXG4gICAvKipcbiAgICogIyMjIC5pc0Zpbml0ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIuIFVubGlrZSBgLmlzTnVtYmVyYCwgdGhpcyB3aWxsIGZhaWwgZm9yIGBOYU5gIGFuZCBgSW5maW5pdHlgLlxuICAgKlxuICAgKiAgICAgdmFyIGN1cHMgPSAyO1xuICAgKiAgICAgYXNzZXJ0LmlzRmluaXRlKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNGaW5pdGUoTmFOKTsgLy8gdGhyb3dzXG4gICAqXG4gICAqIEBuYW1lIGlzRmluaXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGaW5pdGUgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNGaW5pdGUsIHRydWUpLnRvLmJlLmZpbml0ZTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Jvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gdHJ1ZVxuICAgKiAgICAgICAsIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQm9vbGVhbih0ZWFSZWFkeSwgJ2lzIHRoZSB0ZWEgcmVhZHknKTtcbiAgICogICAgIGFzc2VydC5pc0Jvb2xlYW4odGVhU2VydmVkLCAnaGFzIHRlYSBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Jvb2xlYW5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0Jvb2xlYW4sIHRydWUpLnRvLmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEJvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gJ3llcCdcbiAgICogICAgICAgLCB0ZWFTZXJ2ZWQgPSAnbm9wZSc7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RCb29sZWFuKHRlYVJlYWR5LCAnaXMgdGhlIHRlYSByZWFkeScpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90Qm9vbGVhbih0ZWFTZXJ2ZWQsICdoYXMgdGVhIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90Qm9vbGVhblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RCb29sZWFuID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90Qm9vbGVhbiwgdHJ1ZSkudG8ubm90LmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC50eXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQudHlwZU9mKHsgdGVhOiAnY2hhaScgfSwgJ29iamVjdCcsICd3ZSBoYXZlIGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZihbJ2NoYWknLCAnamFzbWluZSddLCAnYXJyYXknLCAnd2UgaGF2ZSBhbiBhcnJheScpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZigndGVhJywgJ3N0cmluZycsICd3ZSBoYXZlIGEgc3RyaW5nJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKC90ZWEvLCAncmVnZXhwJywgJ3dlIGhhdmUgYSByZWd1bGFyIGV4cHJlc3Npb24nKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YobnVsbCwgJ251bGwnLCAnd2UgaGF2ZSBhIG51bGwnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YodW5kZWZpbmVkLCAndW5kZWZpbmVkJywgJ3dlIGhhdmUgYW4gdW5kZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIHR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQudHlwZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LnR5cGVPZiwgdHJ1ZSkudG8uYmUuYSh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RUeXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIF9ub3RfIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90VHlwZU9mKCd0ZWEnLCAnbnVtYmVyJywgJ3N0cmluZ3MgYXJlIG5vdCBudW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZW9mIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFR5cGVPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5ub3RUeXBlT2YsIHRydWUpLnRvLm5vdC5iZS5hKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgdmFyIFRlYSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH1cbiAgICogICAgICAgLCBjaGFpID0gbmV3IFRlYSgnY2hhaScpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoY2hhaSwgVGVhLCAnY2hhaSBpcyBhbiBpbnN0YW5jZSBvZiB0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VPZlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbnN0YW5jZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0Lmluc3RhbmNlT2YsIHRydWUpLnRvLmJlLmluc3RhbmNlT2YodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5zdGFuY2VPZihvYmplY3QsIGNvbnN0cnVjdG9yLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgY2hhaSA9IG5ldyBTdHJpbmcoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbnN0YW5jZU9mKGNoYWksIFRlYSwgJ2NoYWkgaXMgbm90IGFuIGluc3RhbmNlIG9mIHRlYScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbnN0YW5jZU9mXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluc3RhbmNlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQubm90SW5zdGFuY2VPZiwgdHJ1ZSlcbiAgICAgIC50by5ub3QuYmUuaW5zdGFuY2VPZih0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgaW5jbHVkZXMgYG5lZWRsZWAuIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGVcbiAgICogaW5jbHVzaW9uIG9mIGEgdmFsdWUgaW4gYW4gYXJyYXksIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nLCBvciBhIHN1YnNldCBvZlxuICAgKiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKFsxLDIsM10sIDIsICdhcnJheSBjb250YWlucyB2YWx1ZScpO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoJ2Zvb2JhcicsICdmb28nLCAnc3RyaW5nIGNvbnRhaW5zIHN1YnN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoeyBmb286ICdiYXInLCBoZWxsbzogJ3VuaXZlcnNlJyB9LCB7IGZvbzogJ2JhcicgfSwgJ29iamVjdCBjb250YWlucyBwcm9wZXJ0eScpO1xuICAgKlxuICAgKiBTdHJpY3QgZXF1YWxpdHkgKD09PSkgaXMgdXNlZC4gV2hlbiBhc3NlcnRpbmcgdGhlIGluY2x1c2lvbiBvZiBhIHZhbHVlIGluXG4gICAqIGFuIGFycmF5LCB0aGUgYXJyYXkgaXMgc2VhcmNoZWQgZm9yIGFuIGVsZW1lbnQgdGhhdCdzIHN0cmljdGx5IGVxdWFsIHRvIHRoZVxuICAgKiBnaXZlbiB2YWx1ZS4gV2hlbiBhc3NlcnRpbmcgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBvYmplY3QsIHRoZSBvYmplY3RcbiAgICogaXMgc2VhcmNoZWQgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBrZXlzLCBjaGVja2luZyB0aGF0IGVhY2ggb25lIGlzIHByZXNlbnRcbiAgICogYW5kIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBnaXZlbiBwcm9wZXJ0eSB2YWx1ZS4gRm9yIGluc3RhbmNlOlxuICAgKlxuICAgKiAgICAgdmFyIG9iajEgPSB7YTogMX1cbiAgICogICAgICAgLCBvYmoyID0ge2I6IDJ9O1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoW29iajEsIG9iajJdLCBvYmoxKTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IG9iajF9KTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IG9iajEsIGJhcjogb2JqMn0pO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5pbmNsdWRlLCB0cnVlKS5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGRvZXMgbm90IGluY2x1ZGUgYG5lZWRsZWAuIENhbiBiZSB1c2VkIHRvIGFzc2VydFxuICAgKiB0aGUgYWJzZW5jZSBvZiBhIHZhbHVlIGluIGFuIGFycmF5LCBhIHN1YnN0cmluZyBpbiBhIHN0cmluZywgb3IgYSBzdWJzZXQgb2ZcbiAgICogcHJvcGVydGllcyBpbiBhbiBvYmplY3QuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZShbMSwyLDNdLCA0LCBcImFycmF5IGRvZXNuJ3QgY29udGFpbiB2YWx1ZVwiKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKCdmb29iYXInLCAnYmF6JywgXCJzdHJpbmcgZG9lc24ndCBjb250YWluIHN1YnN0cmluZ1wiKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKHsgZm9vOiAnYmFyJywgaGVsbG86ICd1bml2ZXJzZScgfSwgeyBmb286ICdiYXonIH0sICdvYmplY3QgZG9lc24ndCBjb250YWluIHByb3BlcnR5Jyk7XG4gICAqXG4gICAqIFN0cmljdCBlcXVhbGl0eSAoPT09KSBpcyB1c2VkLiBXaGVuIGFzc2VydGluZyB0aGUgYWJzZW5jZSBvZiBhIHZhbHVlIGluIGFuXG4gICAqIGFycmF5LCB0aGUgYXJyYXkgaXMgc2VhcmNoZWQgdG8gY29uZmlybSB0aGUgYWJzZW5jZSBvZiBhbiBlbGVtZW50IHRoYXQnc1xuICAgKiBzdHJpY3RseSBlcXVhbCB0byB0aGUgZ2l2ZW4gdmFsdWUuIFdoZW4gYXNzZXJ0aW5nIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW5cbiAgICogYW4gb2JqZWN0LCB0aGUgb2JqZWN0IGlzIHNlYXJjaGVkIHRvIGNvbmZpcm0gdGhhdCBhdCBsZWFzdCBvbmUgb2YgdGhlIGdpdmVuXG4gICAqIHByb3BlcnR5IGtleXMgaXMgZWl0aGVyIG5vdCBwcmVzZW50IG9yIG5vdCBzdHJpY3RseSBlcXVhbCB0byB0aGUgZ2l2ZW5cbiAgICogcHJvcGVydHkgdmFsdWUuIEZvciBpbnN0YW5jZTpcbiAgICpcbiAgICogICAgIHZhciBvYmoxID0ge2E6IDF9XG4gICAqICAgICAgICwgb2JqMiA9IHtiOiAyfTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKFtvYmoxLCBvYmoyXSwge2E6IDF9KTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IHthOiAxfX0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzogb2JqMSwgYmFyOiB7YjogMn19KTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90SW5jbHVkZSwgdHJ1ZSkubm90LmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGluY2x1ZGVzIGBuZWVkbGVgLiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlXG4gICAqIGluY2x1c2lvbiBvZiBhIHZhbHVlIGluIGFuIGFycmF5IG9yIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0LlxuICAgKiBEZWVwIGVxdWFsaXR5IGlzIHVzZWQuXG4gICAqXG4gICAqICAgICB2YXIgb2JqMSA9IHthOiAxfVxuICAgKiAgICAgICAsIG9iajIgPSB7YjogMn07XG4gICAqICAgICBhc3NlcnQuZGVlcEluY2x1ZGUoW29iajEsIG9iajJdLCB7YTogMX0pO1xuICAgKiAgICAgYXNzZXJ0LmRlZXBJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IHthOiAxfX0pO1xuICAgKiAgICAgYXNzZXJ0LmRlZXBJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IHthOiAxfSwgYmFyOiB7YjogMn19KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcEluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5kZWVwSW5jbHVkZSwgdHJ1ZSkuZGVlcC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBkb2VzIG5vdCBpbmNsdWRlIGBuZWVkbGVgLiBDYW4gYmUgdXNlZCB0byBhc3NlcnRcbiAgICogdGhlIGFic2VuY2Ugb2YgYSB2YWx1ZSBpbiBhbiBhcnJheSBvciBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICogRGVlcCBlcXVhbGl0eSBpcyB1c2VkLlxuICAgKlxuICAgKiAgICAgdmFyIG9iajEgPSB7YTogMX1cbiAgICogICAgICAgLCBvYmoyID0ge2I6IDJ9O1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBJbmNsdWRlKFtvYmoxLCBvYmoyXSwge2E6IDl9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwSW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiB7YTogOX19KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwSW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiB7YTogMX0sIGJhcjoge2I6IDl9fSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBJbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90RGVlcEluY2x1ZGUsIHRydWUpLm5vdC5kZWVwLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5uZXN0ZWRJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgaW5jbHVzaW9uIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW5cbiAgICogb2JqZWN0LlxuICAgKiBFbmFibGVzIHRoZSB1c2Ugb2YgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgcmVmZXJlbmNpbmcgbmVzdGVkXG4gICAqIHByb3BlcnRpZXMuXG4gICAqICdbXScgYW5kICcuJyBpbiBwcm9wZXJ0eSBuYW1lcyBjYW4gYmUgZXNjYXBlZCB1c2luZyBkb3VibGUgYmFja3NsYXNoZXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQubmVzdGVkSW5jbHVkZSh7Jy5hJzogeydiJzogJ3gnfX0sIHsnXFxcXC5hLltiXSc6ICd4J30pO1xuICAgKiAgICAgYXNzZXJ0Lm5lc3RlZEluY2x1ZGUoeydhJzogeydbYl0nOiAneCd9fSwgeydhLlxcXFxbYlxcXFxdJzogJ3gnfSk7XG4gICAqXG4gICAqIEBuYW1lIG5lc3RlZEluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5uZXN0ZWRJbmNsdWRlLCB0cnVlKS5uZXN0ZWQuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE5lc3RlZEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBkb2VzIG5vdCBpbmNsdWRlICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGFic2VuY2Ugb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhblxuICAgKiBvYmplY3QuXG4gICAqIEVuYWJsZXMgdGhlIHVzZSBvZiBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciByZWZlcmVuY2luZyBuZXN0ZWRcbiAgICogcHJvcGVydGllcy5cbiAgICogJ1tdJyBhbmQgJy4nIGluIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBlc2NhcGVkIHVzaW5nIGRvdWJsZSBiYWNrc2xhc2hlcy5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3ROZXN0ZWRJbmNsdWRlKHsnLmEnOiB7J2InOiAneCd9fSwgeydcXFxcLmEuYic6ICd5J30pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZEluY2x1ZGUoeydhJzogeydbYl0nOiAneCd9fSwgeydhLlxcXFxbYlxcXFxdJzogJ3knfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE5lc3RlZEluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3ROZXN0ZWRJbmNsdWRlLCB0cnVlKVxuICAgICAgLm5vdC5uZXN0ZWQuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBOZXN0ZWRJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgaW5jbHVzaW9uIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW5cbiAgICogb2JqZWN0IHdoaWxlIGNoZWNraW5nIGZvciBkZWVwIGVxdWFsaXR5LlxuICAgKiBFbmFibGVzIHRoZSB1c2Ugb2YgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgcmVmZXJlbmNpbmcgbmVzdGVkXG4gICAqIHByb3BlcnRpZXMuXG4gICAqICdbXScgYW5kICcuJyBpbiBwcm9wZXJ0eSBuYW1lcyBjYW4gYmUgZXNjYXBlZCB1c2luZyBkb3VibGUgYmFja3NsYXNoZXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcE5lc3RlZEluY2x1ZGUoe2E6IHtiOiBbe3g6IDF9XX19LCB7J2EuYlswXSc6IHt4OiAxfX0pO1xuICAgKiAgICAgYXNzZXJ0LmRlZXBOZXN0ZWRJbmNsdWRlKHsnLmEnOiB7J1tiXSc6IHt4OiAxfX19LCB7J1xcXFwuYS5cXFxcW2JcXFxcXSc6IHt4OiAxfX0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwTmVzdGVkSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcE5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmRlZXBOZXN0ZWRJbmNsdWRlLCB0cnVlKVxuICAgICAgLmRlZXAubmVzdGVkLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwTmVzdGVkSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGRvZXMgbm90IGluY2x1ZGUgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgYWJzZW5jZSBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuXG4gICAqIG9iamVjdCB3aGlsZSBjaGVja2luZyBmb3IgZGVlcCBlcXVhbGl0eS5cbiAgICogRW5hYmxlcyB0aGUgdXNlIG9mIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIHJlZmVyZW5jaW5nIG5lc3RlZFxuICAgKiBwcm9wZXJ0aWVzLlxuICAgKiAnW10nIGFuZCAnLicgaW4gcHJvcGVydHkgbmFtZXMgY2FuIGJlIGVzY2FwZWQgdXNpbmcgZG91YmxlIGJhY2tzbGFzaGVzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRJbmNsdWRlKHthOiB7YjogW3t4OiAxfV19fSwgeydhLmJbMF0nOiB7eTogMX19KVxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRJbmNsdWRlKHsnLmEnOiB7J1tiXSc6IHt4OiAxfX19LCB7J1xcXFwuYS5cXFxcW2JcXFxcXSc6IHt5OiAyfX0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwTmVzdGVkSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcE5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRJbmNsdWRlLCB0cnVlKVxuICAgICAgLm5vdC5kZWVwLm5lc3RlZC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAub3duSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuXG4gICAqIG9iamVjdCB3aGlsZSBpZ25vcmluZyBpbmhlcml0ZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogICAgIGFzc2VydC5vd25JbmNsdWRlKHsgYTogMSB9LCB7IGE6IDEgfSk7XG4gICAqXG4gICAqIEBuYW1lIG93bkluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm93bkluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm93bkluY2x1ZGUsIHRydWUpLm93bi5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90T3duSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGFic2VuY2Ugb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhblxuICAgKiBvYmplY3Qgd2hpbGUgaWdub3JpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqICAgICBPYmplY3QucHJvdG90eXBlLmIgPSAyO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE93bkluY2x1ZGUoeyBhOiAxIH0sIHsgYjogMiB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90T3duSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90T3duSW5jbHVkZSA9IGZ1bmN0aW9uKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90T3duSW5jbHVkZSwgdHJ1ZSkubm90Lm93bi5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcE93bkluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBpbmNsdWRlcyAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBpbmNsdXNpb24gb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhblxuICAgKiBvYmplY3Qgd2hpbGUgaWdub3JpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMgYW5kIGNoZWNraW5nIGZvciBkZWVwIGVxdWFsaXR5LlxuICAgKlxuICAgKiAgICAgIGFzc2VydC5kZWVwT3duSW5jbHVkZSh7YToge2I6IDJ9fSwge2E6IHtiOiAyfX0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwT3duSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcE93bkluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmRlZXBPd25JbmNsdWRlLCB0cnVlKVxuICAgICAgLmRlZXAub3duLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAubm90RGVlcE93bkluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBpbmNsdWRlcyAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBhYnNlbmNlIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW5cbiAgICogb2JqZWN0IHdoaWxlIGlnbm9yaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGFuZCBjaGVja2luZyBmb3IgZGVlcCBlcXVhbGl0eS5cbiAgICpcbiAgICogICAgICBhc3NlcnQubm90RGVlcE93bkluY2x1ZGUoe2E6IHtiOiAyfX0sIHthOiB7YzogM319KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcE93bkluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBPd25JbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3REZWVwT3duSW5jbHVkZSwgdHJ1ZSlcbiAgICAgIC5ub3QuZGVlcC5vd24uaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHZhbHVlLCByZWdleHAsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgbWF0Y2hlcycpO1xuICAgKlxuICAgKiBAbmFtZSBtYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5tYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubWF0Y2gsIHRydWUpLnRvLm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RNYXRjaCh2YWx1ZSwgcmVnZXhwLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGRvZXMgbm90IG1hdGNoIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90TWF0Y2goJ2Zvb2JhcicsIC9eZm9vLywgJ3JlZ2V4cCBkb2VzIG5vdCBtYXRjaCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RNYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RNYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90TWF0Y2gsIHRydWUpLnRvLm5vdC5tYXRjaChyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZCBieVxuICAgKiBgcHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYScpO1xuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RvU3RyaW5nJyk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5wcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5wcm9wZXJ0eSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkXG4gICAqIGJ5IGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3RQcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZCBieVxuICAgKiBgcHJvcGVydHlgIHdpdGggYSB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrXG4gICAqICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ3RlYScsICdpcyBnb29kJyk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5wcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LnByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZFxuICAgKiBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVja1xuICAgKiAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RQcm9wZXJ0eVZhbCh7IHRlYTogJ2lzIGdvb2QnIH0sICd0ZWEnLCAnaXMgYmFkJyk7XG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAnY29mZmVlJywgJ2lzIGdvb2QnKTtcbiAgICpcbiAgICogQG5hbWUgbm90UHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90UHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YCB3aXRoIGEgdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGdyZWVuOiAnbWF0Y2hhJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kZWVwUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkXG4gICAqIGJ5IGBwcm9wZXJ0eWAgd2l0aCB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ3RlYScsIHsgYmxhY2s6ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBncmVlbjogJ29vbG9uZycgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICdjb2ZmZWUnLCB7IGdyZWVuOiAnbWF0Y2hhJyB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm93blByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLiBJbmhlcml0ZWRcbiAgICogcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vd25Qcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgb3duUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm93blByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm93blByb3BlcnR5LCB0cnVlKVxuICAgICAgLnRvLmhhdmUub3duLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE93blByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieVxuICAgKiBgcHJvcGVydHlgLiBJbmhlcml0ZWQgcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICdjb2ZmZWUnKTtcbiAgICogICAgIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSh7fSwgJ3RvU3RyaW5nJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE93blByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5vd24ucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAub3duUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIGFuZCBhIHZhbHVlXG4gICAqIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBgdmFsdWVgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKiBJbmhlcml0ZWQgcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vd25Qcm9wZXJ0eVZhbCh7IGNvZmZlZTogJ2lzIGdvb2QnfSwgJ2NvZmZlZScsICdpcyBnb29kJyk7XG4gICAqXG4gICAqIEBuYW1lIG93blByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vd25Qcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQub3duUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5vd24ucHJvcGVydHkocHJvcCwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE93blByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YFxuICAgKiB3aXRoIGEgdmFsdWUgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIGB2YWx1ZWAuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICogKD09PSkuIEluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZW4ndCBjaGVja2VkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE93blByb3BlcnR5VmFsKHsgdGVhOiAnaXMgYmV0dGVyJ30sICd0ZWEnLCAnaXMgd29yc2UnKTtcbiAgICogICAgIGFzc2VydC5ub3RPd25Qcm9wZXJ0eVZhbCh7fSwgJ3RvU3RyaW5nJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE93blByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RPd25Qcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90T3duUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUub3duLnByb3BlcnR5KHByb3AsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwT3duUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIGFuZCBhIHZhbHVlXG4gICAqIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBgdmFsdWVgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay4gSW5oZXJpdGVkXG4gICAqIHByb3BlcnRpZXMgYXJlbid0IGNoZWNrZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcE93blByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGdyZWVuOiAnbWF0Y2hhJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcE93blByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwT3duUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWx1ZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRlZXBPd25Qcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLmRlZXAub3duLnByb3BlcnR5KHByb3AsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwT3duUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgXG4gICAqIHdpdGggYSB2YWx1ZSBlcXVhbCB0byB0aGUgcHJvdmlkZWQgYHZhbHVlYC4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqIEluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZW4ndCBjaGVja2VkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBibGFjazogJ21hdGNoYScgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGdyZWVuOiAnb29sb25nJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ2NvZmZlZScsIHsgZ3JlZW46ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCh7fSwgJ3RvU3RyaW5nJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBPd25Qcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsdWUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuZGVlcC5vd24ucHJvcGVydHkocHJvcCwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5lc3RlZFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YCwgd2hpY2ggY2FuIGJlIGEgc3RyaW5nIHVzaW5nIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yXG4gICAqIG5lc3RlZCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQubmVzdGVkUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJyk7XG4gICAqXG4gICAqIEBuYW1lIG5lc3RlZFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3ROZXN0ZWRQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCB3aGljaFxuICAgKiBjYW4gYmUgYSBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgbmVzdGVkIHJlZmVyZW5jZS4gVGhlXG4gICAqIHByb3BlcnR5IGNhbm5vdCBleGlzdCBvbiB0aGUgb2JqZWN0IG5vciBhbnl3aGVyZSBpbiBpdHMgcHJvdG90eXBlIGNoYWluLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5vb2xvbmcnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TmVzdGVkUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5LCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLm5lc3RlZC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5uZXN0ZWRQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBuZXN0ZWRcbiAgICogcmVmZXJlbmNlLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicsICdtYXRjaGEnKTtcbiAgICpcbiAgICogQG5hbWUgbmVzdGVkUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubmVzdGVkUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3ROZXN0ZWRQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoXG4gICAqIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvclxuICAgKiBuZXN0ZWQgcmVmZXJlbmNlLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicsICdrb25hY2hhJyk7XG4gICAqICAgICBhc3NlcnQubm90TmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlLmdyZWVuJywgJ21hdGNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBub3ROZXN0ZWRQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TmVzdGVkUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5uZXN0ZWQucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwTmVzdGVkUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgd2l0aCBhIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBuZXN0ZWRcbiAgICogcmVmZXJlbmNlLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwTmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46IHsgbWF0Y2hhOiAneXVtJyB9IH0gfSwgJ3RlYS5ncmVlbicsIHsgbWF0Y2hhOiAneXVtJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcE5lc3RlZFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwTmVzdGVkUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kZWVwTmVzdGVkUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5kZWVwLm5lc3RlZC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoXG4gICAqIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvclxuICAgKiBuZXN0ZWQgcmVmZXJlbmNlLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwTmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46IHsgbWF0Y2hhOiAneXVtJyB9IH0gfSwgJ3RlYS5ncmVlbicsIHsgb29sb25nOiAneXVtJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwTmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46IHsgbWF0Y2hhOiAneXVtJyB9IH0gfSwgJ3RlYS5ncmVlbicsIHsgbWF0Y2hhOiAneXVjaycgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiB7IG1hdGNoYTogJ3l1bScgfSB9IH0sICd0ZWEuYmxhY2snLCB7IG1hdGNoYTogJ3l1bScgfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmRlZXAubmVzdGVkLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5sZW5ndGhPZihvYmplY3QsIGxlbmd0aCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgYGxlbmd0aGAgb3IgYHNpemVgIHdpdGggdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmxlbmd0aE9mKFsxLDIsM10sIDMsICdhcnJheSBoYXMgbGVuZ3RoIG9mIDMnKTtcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZignZm9vYmFyJywgNiwgJ3N0cmluZyBoYXMgbGVuZ3RoIG9mIDYnKTtcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZihuZXcgU2V0KFsxLDIsM10pLCAzLCAnc2V0IGhhcyBzaXplIG9mIDMnKTtcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZihuZXcgTWFwKFtbJ2EnLDFdLFsnYicsMl0sWydjJywzXV0pLCAzLCAnbWFwIGhhcyBzaXplIG9mIDMnKTtcbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmxlbmd0aE9mID0gZnVuY3Rpb24gKGV4cCwgbGVuLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubGVuZ3RoT2YsIHRydWUpLnRvLmhhdmUubGVuZ3RoT2YobGVuKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5oYXNBbnlLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmhhc0FueUtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCBbJ2ZvbycsICdpRG9udEV4aXN0JywgJ2JheiddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge2ZvbzogMzAsIGlEb250RXhpc3Q6IDk5LCBiYXo6IDEzMzd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7Zm9vOiAxfSwgJ2tleSddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSksIFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10pO1xuICAgKlxuICAgKiBAbmFtZSBoYXNBbnlLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaGFzQW55S2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5oYXNBbnlLZXlzLCB0cnVlKS50by5oYXZlLmFueS5rZXlzKGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaGFzQWxsS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGFsbCBhbmQgb25seSBhbGwgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaGFzQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnZm9vJywgJ2JhcicsICdiYXonXSk7XG4gICAqICAgICBhc3NlcnQuaGFzQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtmb286IDMwLCBiYXI6IDk5LCBiYXo6IDEzMzddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7Zm9vOiAxfSwgJ2tleSddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSk7XG4gICAqXG4gICAqIEBuYW1lIGhhc0FsbEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmhhc0FsbEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaGFzQWxsS2V5cywgdHJ1ZSkudG8uaGF2ZS5hbGwua2V5cyhrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmNvbnRhaW5zQWxsS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGFsbCBvZiB0aGUgYGtleXNgIHByb3ZpZGVkIGJ1dCBtYXkgaGF2ZSBtb3JlIGtleXMgbm90IGxpc3RlZC5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwgWydmb28nLCAnYmF6J10pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnZm9vJywgJ2JhcicsICdiYXonXSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge2ZvbzogMzAsIGJhejogMTMzN30pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtmb286IDMwLCBiYXI6IDk5LCBiYXo6IDEzMzd9KTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tmb286IDF9XSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7Zm9vOiAxfSwgJ2tleSddKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddLCBbe2ZvbzogJ2Jhcid9XSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSk7XG4gICAqXG4gICAqIEBuYW1lIGNvbnRhaW5zQWxsS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY29udGFpbnNBbGxLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cywgdHJ1ZSlcbiAgICAgIC50by5jb250YWluLmFsbC5rZXlzKGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdEhhdmVBbnlLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgbm9uZSBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCBbJ29uZScsICd0d28nLCAnZXhhbXBsZSddKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCB7b25lOiAxLCB0d286IDIsIGV4YW1wbGU6ICdmb28nfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7b25lOiAndHdvJ30sICdleGFtcGxlJ10pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cyhuZXcgU2V0KFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10sIFt7b25lOiAndHdvJ30sICdleGFtcGxlJ10pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SGF2ZUFueUtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuYW55LmtleXMoa2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90SGF2ZUFsbEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgbm90IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnb25lJywgJ3R3bycsICdleGFtcGxlJ10pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtvbmU6IDEsIHR3bzogMiwgZXhhbXBsZTogJ2Zvbyd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbEtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tvbmU6ICd0d28nfSwgJ2V4YW1wbGUnXSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tvbmU6ICd0d28nfSwgJ2V4YW1wbGUnXSk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RIYXZlQWxsS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5hbGwua2V5cyhrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmhhc0FueURlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFNpbmNlIFNldHMgYW5kIE1hcHMgY2FuIGhhdmUgb2JqZWN0cyBhcyBrZXlzIHlvdSBjYW4gdXNlIHRoaXMgYXNzZXJ0aW9uIHRvIHBlcmZvcm1cbiAgICogYSBkZWVwIGNvbXBhcmlzb24uXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgWzEsIDJdXSksIFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIFt7b25lOiAnb25lJ30sIHt0aHJlZTogJ3RocmVlJ31dKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdEhhdmVBbGxLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaGFzQW55RGVlcEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaGFzQW55RGVlcEtleXMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5hbnkuZGVlcC5rZXlzKGtleXMpO1xuICB9XG5cbiAvKipcbiAgICogIyMjIC5oYXNBbGxEZWVwS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGFsbCBhbmQgb25seSBhbGwgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogU2luY2UgU2V0cyBhbmQgTWFwcyBjYW4gaGF2ZSBvYmplY3RzIGFzIGtleXMgeW91IGNhbiB1c2UgdGhpcyBhc3NlcnRpb24gdG8gcGVyZm9ybVxuICAgKiBhIGRlZXAgY29tcGFyaXNvbi5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaGFzQWxsRGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ11dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgW3t0d286ICd0d28nfSwgJ3ZhbHVlVHdvJ11dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqICAgICBhc3NlcnQuaGFzQWxsRGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9XSksIHtvbmU6ICdvbmUnfSk7XG4gICAqICAgICBhc3NlcnQuaGFzQWxsRGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqXG4gICAqIEBuYW1lIGhhc0FsbERlZXBLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaGFzQWxsRGVlcEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaGFzQWxsRGVlcEtleXMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5hbGwuZGVlcC5rZXlzKGtleXMpO1xuICB9XG5cbiAvKipcbiAgICogIyMjIC5jb250YWluc0FsbERlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBjb250YWlucyBhbGwgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogU2luY2UgU2V0cyBhbmQgTWFwcyBjYW4gaGF2ZSBvYmplY3RzIGFzIGtleXMgeW91IGNhbiB1c2UgdGhpcyBhc3NlcnRpb24gdG8gcGVyZm9ybVxuICAgKiBhIGRlZXAgY29tcGFyaXNvbi5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgWzEsIDJdXSksIHtvbmU6ICdvbmUnfSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgW3t0d286ICd0d28nfSwgJ3ZhbHVlVHdvJ11dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsRGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqXG4gICAqIEBuYW1lIGNvbnRhaW5zQWxsRGVlcEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmNvbnRhaW5zQWxsRGVlcEtleXMsIHRydWUpXG4gICAgICAudG8uY29udGFpbi5hbGwuZGVlcC5rZXlzKGtleXMpO1xuICB9XG5cbiAvKipcbiAgICogIyMjIC5kb2VzTm90SGF2ZUFueURlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgbm9uZSBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBTaW5jZSBTZXRzIGFuZCBNYXBzIGNhbiBoYXZlIG9iamVjdHMgYXMga2V5cyB5b3UgY2FuIHVzZSB0aGlzIGFzc2VydGlvbiB0byBwZXJmb3JtXG4gICAqIGEgZGVlcCBjb21wYXJpc29uLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwge3RoaXNEb2VzTm90OiAnZXhpc3QnfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgW3t0d286ICd0d28nfSwgJ3ZhbHVlVHdvJ11dKSwgW3t0d2VudHk6ICd0d2VudHknfSwge2ZpZnR5OiAnZmlmdHknfV0pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwge3R3ZW50eTogJ3R3ZW50eSd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIFt7dHdlbnR5OiAndHdlbnR5J30sIHtmaWZ0eTogJ2ZpZnR5J31dKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdEhhdmVBbnlEZWVwS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5hbnkuZGVlcC5rZXlzKGtleXMpO1xuICB9XG5cbiAvKipcbiAgICogIyMjIC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIG5vdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBTaW5jZSBTZXRzIGFuZCBNYXBzIGNhbiBoYXZlIG9iamVjdHMgYXMga2V5cyB5b3UgY2FuIHVzZSB0aGlzIGFzc2VydGlvbiB0byBwZXJmb3JtXG4gICAqIGEgZGVlcCBjb21wYXJpc29uLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwge3RoaXNEb2VzTm90OiAnZXhpc3QnfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgW3t0d286ICd0d28nfSwgJ3ZhbHVlVHdvJ11dKSwgW3t0d2VudHk6ICd0d2VudHknfSwge29uZTogJ29uZSd9XSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCB7dHdlbnR5OiAndHdlbnR5J30pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsRGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3tvbmU6ICdvbmUnfSwge2ZpZnR5OiAnZmlmdHknfV0pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SGF2ZUFsbERlZXBLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEhhdmVBbGxEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmFsbC5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLnRocm93cyhmbiwgW2Vycm9yTGlrZS9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIElmIGBlcnJvckxpa2VgIGlzIGFuIGBFcnJvcmAgY29uc3RydWN0b3IsIGFzc2VydHMgdGhhdCBgZm5gIHdpbGwgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhblxuICAgKiBpbnN0YW5jZSBvZiBgZXJyb3JMaWtlYC5cbiAgICogSWYgYGVycm9yTGlrZWAgaXMgYW4gYEVycm9yYCBpbnN0YW5jZSwgYXNzZXJ0cyB0aGF0IHRoZSBlcnJvciB0aHJvd24gaXMgdGhlIHNhbWVcbiAgICogaW5zdGFuY2UgYXMgYGVycm9yTGlrZWAuXG4gICAqIElmIGBlcnJNc2dNYXRjaGVyYCBpcyBwcm92aWRlZCwgaXQgYWxzbyBhc3NlcnRzIHRoYXQgdGhlIGVycm9yIHRocm93biB3aWxsIGhhdmUgYVxuICAgKiBtZXNzYWdlIG1hdGNoaW5nIGBlcnJNc2dNYXRjaGVyYC5cbiAgICpcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sICdFcnJvciB0aHJvd24gbXVzdCBoYXZlIHRoaXMgbXNnJyk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCAvRXJyb3IgdGhyb3duIG11c3QgaGF2ZSBhIG1zZyB0aGF0IG1hdGNoZXMgdGhpcy8pO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgZXJyb3JJbnN0YW5jZSk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBSZWZlcmVuY2VFcnJvciwgJ0Vycm9yIHRocm93biBtdXN0IGJlIGEgUmVmZXJlbmNlRXJyb3IgYW5kIGhhdmUgdGhpcyBtc2cnKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIGVycm9ySW5zdGFuY2UsICdFcnJvciB0aHJvd24gbXVzdCBiZSB0aGUgc2FtZSBlcnJvckluc3RhbmNlIGFuZCBoYXZlIHRoaXMgbXNnJyk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBSZWZlcmVuY2VFcnJvciwgL0Vycm9yIHRocm93biBtdXN0IGJlIGEgUmVmZXJlbmNlRXJyb3IgYW5kIG1hdGNoIHRoaXMvKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIGVycm9ySW5zdGFuY2UsIC9FcnJvciB0aHJvd24gbXVzdCBiZSB0aGUgc2FtZSBlcnJvckluc3RhbmNlIGFuZCBtYXRjaCB0aGlzLyk7XG4gICAqXG4gICAqIEBuYW1lIHRocm93c1xuICAgKiBAYWxpYXMgdGhyb3dcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3RvcnxFcnJvcn0gZXJyb3JMaWtlXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gZXJyTXNnTWF0Y2hlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiAoZm4sIGVycm9yTGlrZSwgZXJyTXNnTWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZXJyb3JMaWtlIHx8IGVycm9yTGlrZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgZXJyTXNnTWF0Y2hlciA9IGVycm9yTGlrZTtcbiAgICAgIGVycm9yTGlrZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGFzc2VydEVyciA9IG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LnRocm93cywgdHJ1ZSlcbiAgICAgIC50by50aHJvdyhlcnJvckxpa2UsIGVyck1zZ01hdGNoZXIpO1xuICAgIHJldHVybiBmbGFnKGFzc2VydEVyciwgJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RUaHJvdyhmbiwgW2Vycm9yTGlrZS9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIElmIGBlcnJvckxpa2VgIGlzIGFuIGBFcnJvcmAgY29uc3RydWN0b3IsIGFzc2VydHMgdGhhdCBgZm5gIHdpbGwgX25vdF8gdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhblxuICAgKiBpbnN0YW5jZSBvZiBgZXJyb3JMaWtlYC5cbiAgICogSWYgYGVycm9yTGlrZWAgaXMgYW4gYEVycm9yYCBpbnN0YW5jZSwgYXNzZXJ0cyB0aGF0IHRoZSBlcnJvciB0aHJvd24gaXMgX25vdF8gdGhlIHNhbWVcbiAgICogaW5zdGFuY2UgYXMgYGVycm9yTGlrZWAuXG4gICAqIElmIGBlcnJNc2dNYXRjaGVyYCBpcyBwcm92aWRlZCwgaXQgYWxzbyBhc3NlcnRzIHRoYXQgdGhlIGVycm9yIHRocm93biB3aWxsIF9ub3RfIGhhdmUgYVxuICAgKiBtZXNzYWdlIG1hdGNoaW5nIGBlcnJNc2dNYXRjaGVyYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sICdBbnkgRXJyb3IgdGhyb3duIG11c3Qgbm90IGhhdmUgdGhpcyBtZXNzYWdlJyk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCAvQW55IEVycm9yIHRocm93biBtdXN0IG5vdCBtYXRjaCB0aGlzLyk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBFcnJvcik7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBlcnJvckluc3RhbmNlKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIEVycm9yLCAnRXJyb3IgbXVzdCBub3QgaGF2ZSB0aGlzIG1lc3NhZ2UnKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIGVycm9ySW5zdGFuY2UsICdFcnJvciBtdXN0IG5vdCBoYXZlIHRoaXMgbWVzc2FnZScpO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgRXJyb3IsIC9FcnJvciBtdXN0IG5vdCBtYXRjaCB0aGlzLyk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBlcnJvckluc3RhbmNlLCAvRXJyb3IgbXVzdCBub3QgbWF0Y2ggdGhpcy8pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90VGhyb3dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBlcnJvckxpa2VcbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBlcnJNc2dNYXRjaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJyb3JMaWtlLCBlcnJNc2dNYXRjaGVyLCBtc2cpIHtcbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBlcnJvckxpa2UgfHwgZXJyb3JMaWtlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBlcnJNc2dNYXRjaGVyID0gZXJyb3JMaWtlO1xuICAgICAgZXJyb3JMaWtlID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kb2VzTm90VGhyb3csIHRydWUpXG4gICAgICAudG8ubm90LnRocm93KGVycm9yTGlrZSwgZXJyTXNnTWF0Y2hlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAub3BlcmF0b3IodmFsMSwgb3BlcmF0b3IsIHZhbDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQ29tcGFyZXMgdHdvIHZhbHVlcyB1c2luZyBgb3BlcmF0b3JgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm9wZXJhdG9yKDEsICc8JywgMiwgJ2V2ZXJ5dGhpbmcgaXMgb2snKTtcbiAgICogICAgIGFzc2VydC5vcGVyYXRvcigxLCAnPicsIDIsICd0aGlzIHdpbGwgZmFpbCcpO1xuICAgKlxuICAgKiBAbmFtZSBvcGVyYXRvclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWwxXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWwyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vcGVyYXRvciA9IGZ1bmN0aW9uICh2YWwsIG9wZXJhdG9yLCB2YWwyLCBtc2cpIHtcbiAgICB2YXIgb2s7XG4gICAgc3dpdGNoKG9wZXJhdG9yKSB7XG4gICAgICBjYXNlICc9PSc6XG4gICAgICAgIG9rID0gdmFsID09IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgb2sgPSB2YWwgPT09IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPic6XG4gICAgICAgIG9rID0gdmFsID4gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc+PSc6XG4gICAgICAgIG9rID0gdmFsID49IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIG9rID0gdmFsIDwgdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc8PSc6XG4gICAgICAgIG9rID0gdmFsIDw9IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnIT0nOlxuICAgICAgICBvayA9IHZhbCAhPSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgIG9rID0gdmFsICE9PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG1zZyA9IG1zZyA/IG1zZyArICc6ICcgOiBtc2c7XG4gICAgICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKFxuICAgICAgICAgIG1zZyArICdJbnZhbGlkIG9wZXJhdG9yIFwiJyArIG9wZXJhdG9yICsgJ1wiJyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgYXNzZXJ0Lm9wZXJhdG9yXG4gICAgICAgICk7XG4gICAgfVxuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihvaywgbXNnLCBhc3NlcnQub3BlcmF0b3IsIHRydWUpO1xuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICB0cnVlID09PSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIHV0aWwuaW5zcGVjdCh2YWwpICsgJyB0byBiZSAnICsgb3BlcmF0b3IgKyAnICcgKyB1dGlsLmluc3BlY3QodmFsMilcbiAgICAgICwgJ2V4cGVjdGVkICcgKyB1dGlsLmluc3BlY3QodmFsKSArICcgdG8gbm90IGJlICcgKyBvcGVyYXRvciArICcgJyArIHV0aWwuaW5zcGVjdCh2YWwyKSApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmNsb3NlVG8oYWN0dWFsLCBleHBlY3RlZCwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgYGV4cGVjdGVkYCwgdG8gd2l0aGluIGEgKy8tIGBkZWx0YWAgcmFuZ2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuY2xvc2VUbygxLjUsIDEsIDAuNSwgJ251bWJlcnMgYXJlIGNsb3NlJyk7XG4gICAqXG4gICAqIEBuYW1lIGNsb3NlVG9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFjdHVhbFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jbG9zZVRvID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBkZWx0YSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LmNsb3NlVG8sIHRydWUpLnRvLmJlLmNsb3NlVG8oZXhwLCBkZWx0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuYXBwcm94aW1hdGVseShhY3R1YWwsIGV4cGVjdGVkLCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5hcHByb3hpbWF0ZWx5KDEuNSwgMSwgMC41LCAnbnVtYmVycyBhcmUgY2xvc2UnKTtcbiAgICpcbiAgICogQG5hbWUgYXBwcm94aW1hdGVseVxuICAgKiBAcGFyYW0ge051bWJlcn0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmFwcHJveGltYXRlbHkgPSBmdW5jdGlvbiAoYWN0LCBleHAsIGRlbHRhLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuYXBwcm94aW1hdGVseSwgdHJ1ZSlcbiAgICAgIC50by5iZS5hcHByb3hpbWF0ZWx5KGV4cCwgZGVsdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiBhbnkgb3JkZXIuIFVzZXMgYVxuICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuc2FtZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSwgMyBdLCAnc2FtZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIHNhbWVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc2FtZU1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5zYW1lTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLnNhbWUubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFNhbWVNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGRvbid0IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiBhbnkgb3JkZXIuXG4gICAqIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U2FtZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgNSwgMSwgMyBdLCAnbm90IHNhbWUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTYW1lTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFNhbWVNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQubm90U2FtZU1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuc2FtZS5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuc2FtZURlZXBNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiBhbnkgb3JkZXIuIFVzZXMgYVxuICAgKiBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnNhbWVEZWVwTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgW3sgYjogMiB9LCB7IGE6IDEgfSwgeyBjOiAzIH1dLCAnc2FtZSBkZWVwIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZURlZXBNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc2FtZURlZXBNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQuc2FtZURlZXBNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuc2FtZS5kZWVwLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RTYW1lRGVlcE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgZG9uJ3QgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIGFueSBvcmRlci5cbiAgICogVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U2FtZURlZXBNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbeyBiOiAyIH0sIHsgYTogMSB9LCB7IGY6IDUgfV0sICdub3Qgc2FtZSBkZWVwIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90U2FtZURlZXBNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U2FtZURlZXBNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQubm90U2FtZURlZXBNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLnNhbWUuZGVlcC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuc2FtZU9yZGVyZWRNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICogVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lT3JkZXJlZE1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMSwgMiwgMyBdLCAnc2FtZSBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZU9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc2FtZU9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQuc2FtZU9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuc2FtZS5vcmRlcmVkLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RTYW1lT3JkZXJlZE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgZG9uJ3QgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIHRoZSBzYW1lXG4gICAqIG9yZGVyLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFNhbWVPcmRlcmVkTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxLCAzIF0sICdub3Qgc2FtZSBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90U2FtZU9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U2FtZU9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQubm90U2FtZU9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLnNhbWUub3JkZXJlZC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuc2FtZURlZXBPcmRlcmVkTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiBhc3NlcnQuc2FtZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sICdzYW1lIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIHNhbWVEZWVwT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lRGVlcE9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQuc2FtZURlZXBPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLnNhbWUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGRvbid0IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiB0aGUgc2FtZVxuICAgKiBvcmRlci4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqIGFzc2VydC5ub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyB6OiA1IH0gXSwgJ25vdCBzYW1lIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqIGFzc2VydC5ub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYjogMiB9LCB7IGE6IDEgfSwgeyBjOiAzIH0gXSwgJ25vdCBzYW1lIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFNhbWVEZWVwT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQubm90U2FtZURlZXBPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5zYW1lLmRlZXAub3JkZXJlZC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZU1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiBhbnkgb3JkZXIuIFVzZXMgYVxuICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuIER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSwgMiBdLCAnaW5jbHVkZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZU1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQuaW5jbHVkZU1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaW5jbHVkZS5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpc24ndCBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIGFueSBvcmRlci4gVXNlcyBhXG4gICAqIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS4gRHVwbGljYXRlcyBhcmUgaWdub3JlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlTWVtYmVycyhbIDEsIDIsIDMgXSwgWyA1LCAxIF0sICdub3QgaW5jbHVkZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZU1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQubm90SW5jbHVkZU1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmluY2x1ZGUubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZURlZXBNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzIGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gYW55IG9yZGVyLiBVc2VzIGEgZGVlcFxuICAgKiBlcXVhbGl0eSBjaGVjay4gRHVwbGljYXRlcyBhcmUgaWdub3JlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlRGVlcE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBiOiAyIH0sIHsgYTogMSB9LCB7IGI6IDIgfSBdLCAnaW5jbHVkZSBkZWVwIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZURlZXBNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZURlZXBNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0LmluY2x1ZGVEZWVwTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5pbmNsdWRlLmRlZXAubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZURlZXBNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzbid0IGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gYW55IG9yZGVyLiBVc2VzIGFcbiAgICogZGVlcCBlcXVhbGl0eSBjaGVjay4gRHVwbGljYXRlcyBhcmUgaWdub3JlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlRGVlcE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBiOiAyIH0sIHsgZjogNSB9IF0sICdub3QgaW5jbHVkZSBkZWVwIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZURlZXBNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZURlZXBNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaW5jbHVkZS5kZWVwLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGVPcmRlcmVkTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIHRoZSBzYW1lIG9yZGVyXG4gICAqIGJlZ2lubmluZyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGluIGBzdXBlcnNldGAuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHlcbiAgICogY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZU9yZGVyZWRNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDEsIDIgXSwgJ2luY2x1ZGUgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5pbmNsdWRlT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaW5jbHVkZS5vcmRlcmVkLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGVPcmRlcmVkTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpc24ndCBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIHRoZSBzYW1lIG9yZGVyXG4gICAqIGJlZ2lubmluZyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGluIGBzdXBlcnNldGAuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHlcbiAgICogY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEgXSwgJ25vdCBpbmNsdWRlIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVPcmRlcmVkTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAzIF0sICdub3QgaW5jbHVkZSBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGVPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaW5jbHVkZS5vcmRlcmVkLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiB0aGUgc2FtZSBvcmRlclxuICAgKiBiZWdpbm5pbmcgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBpbiBgc3VwZXJzZXRgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eVxuICAgKiBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYTogMSB9LCB7IGI6IDIgfSBdLCAnaW5jbHVkZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5pbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmluY2x1ZGUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXNuJ3QgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiB0aGUgc2FtZSBvcmRlclxuICAgKiBiZWdpbm5pbmcgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBpbiBgc3VwZXJzZXRgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eVxuICAgKiBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYTogMSB9LCB7IGY6IDUgfSBdLCAnbm90IGluY2x1ZGUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYjogMiB9LCB7IGE6IDEgfSBdLCAnbm90IGluY2x1ZGUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYjogMiB9LCB7IGM6IDMgfSBdLCAnbm90IGluY2x1ZGUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaW5jbHVkZS5kZWVwLm9yZGVyZWQubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAub25lT2YoaW5MaXN0LCBsaXN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBub24tb2JqZWN0LCBub24tYXJyYXkgdmFsdWUgYGluTGlzdGAgYXBwZWFycyBpbiB0aGUgZmxhdCBhcnJheSBgbGlzdGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQub25lT2YoMSwgWyAyLCAxIF0sICdOb3QgZm91bmQgaW4gbGlzdCcpO1xuICAgKlxuICAgKiBAbmFtZSBvbmVPZlxuICAgKiBAcGFyYW0geyp9IGluTGlzdFxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBsaXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vbmVPZiA9IGZ1bmN0aW9uIChpbkxpc3QsIGxpc3QsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oaW5MaXN0LCBtc2csIGFzc2VydC5vbmVPZiwgdHJ1ZSkudG8uYmUub25lT2YobGlzdCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5jaGFuZ2VzKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGNoYW5nZXMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDIyIH07XG4gICAqICAgICBhc3NlcnQuY2hhbmdlcyhmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGNoYW5nZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jaGFuZ2VzID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5jaGFuZ2VzLCB0cnVlKS50by5jaGFuZ2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gICAvKipcbiAgICogIyMjIC5jaGFuZ2VzQnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGNoYW5nZXMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgYnkgYW4gYW1vdW50IChkZWx0YSkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCArPSAyIH07XG4gICAqICAgICBhc3NlcnQuY2hhbmdlc0J5KGZuLCBvYmosICd2YWwnLCAyKTtcbiAgICpcbiAgICogQG5hbWUgY2hhbmdlc0J5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jaGFuZ2VzQnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmNoYW5nZXNCeSwgdHJ1ZSlcbiAgICAgIC50by5jaGFuZ2Uob2JqLCBwcm9wKS5ieShkZWx0YSk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuZG9lc05vdENoYW5nZShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2ZvbycpOyB9O1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RDaGFuZ2UoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90Q2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdENoYW5nZSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRvZXNOb3RDaGFuZ2UsIHRydWUpXG4gICAgICAudG8ubm90LmNoYW5nZShvYmosIHByb3ApO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuY2hhbmdlc0J1dE5vdEJ5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgb3Igb2YgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgKz0gMTAgfTtcbiAgICogICAgIGFzc2VydC5jaGFuZ2VzQnV0Tm90QnkoZm4sIG9iaiwgJ3ZhbCcsIDUpO1xuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VzQnV0Tm90QnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNoYW5nZXNCdXROb3RCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuY2hhbmdlc0J1dE5vdEJ5LCB0cnVlKVxuICAgICAgLnRvLmNoYW5nZShvYmosIHByb3ApLmJ1dC5ub3QuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jcmVhc2VzKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGluY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSAxMyB9O1xuICAgKiAgICAgYXNzZXJ0LmluY3JlYXNlcyhmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY3JlYXNlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY3JlYXNlcyA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmluY3JlYXNlcywgdHJ1ZSlcbiAgICAgIC50by5pbmNyZWFzZShvYmosIHByb3ApO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jcmVhc2VzQnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGluY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5IG9yIGEgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCArPSAxMCB9O1xuICAgKiAgICAgYXNzZXJ0LmluY3JlYXNlc0J5KGZuLCBvYmosICd2YWwnLCAxMCk7XG4gICAqXG4gICAqIEBuYW1lIGluY3JlYXNlc0J5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNyZWFzZXNCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuaW5jcmVhc2VzQnksIHRydWUpXG4gICAgICAudG8uaW5jcmVhc2Uob2JqLCBwcm9wKS5ieShkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90SW5jcmVhc2UoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgaW5jcmVhc2UgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gOCB9O1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RJbmNyZWFzZShmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RJbmNyZWFzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RJbmNyZWFzZSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRvZXNOb3RJbmNyZWFzZSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaW5jcmVhc2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY3JlYXNlc0J1dE5vdEJ5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGluY3JlYXNlIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDE1IH07XG4gICAqICAgICBhc3NlcnQuaW5jcmVhc2VzQnV0Tm90QnkoZm4sIG9iaiwgJ3ZhbCcsIDEwKTtcbiAgICpcbiAgICogQG5hbWUgaW5jcmVhc2VzQnV0Tm90QnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY3JlYXNlc0J1dE5vdEJ5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5pbmNyZWFzZXNCdXROb3RCeSwgdHJ1ZSlcbiAgICAgIC50by5pbmNyZWFzZShvYmosIHByb3ApLmJ1dC5ub3QuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2VzKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRlY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA1IH07XG4gICAqICAgICBhc3NlcnQuZGVjcmVhc2VzKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVjcmVhc2VzID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZGVjcmVhc2VzLCB0cnVlKVxuICAgICAgLnRvLmRlY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kZWNyZWFzZXNCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZGVjcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgLT0gNSB9O1xuICAgKiAgICAgYXNzZXJ0LmRlY3JlYXNlc0J5KGZuLCBvYmosICd2YWwnLCA1KTtcbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VzQnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlY3JlYXNlc0J5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kZWNyZWFzZXNCeSwgdHJ1ZSlcbiAgICAgIC50by5kZWNyZWFzZShvYmosIHByb3ApLmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3REZWNyZWFzZShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBkZWNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gMTUgfTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90RGVjcmVhc2UoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90RGVjcmVhc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90RGVjcmVhc2UgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kb2VzTm90RGVjcmVhc2UsIHRydWUpXG4gICAgICAudG8ubm90LmRlY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90RGVjcmVhc2VCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgZGVjcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA1IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdERlY3JlYXNlQnkoZm4sIG9iaiwgJ3ZhbCcsIDEpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90RGVjcmVhc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3REZWNyZWFzZUJ5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZG9lc05vdERlY3JlYXNlQnksIHRydWUpXG4gICAgICAudG8ubm90LmRlY3JlYXNlKG9iaiwgcHJvcCkuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2VzQnV0Tm90QnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGRlY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5IG9yIGEgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gNSB9O1xuICAgKiAgICAgYXNzZXJ0LmRlY3JlYXNlc0J1dE5vdEJ5KGZuLCBvYmosICd2YWwnLCAxKTtcbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VzQnV0Tm90QnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlY3JlYXNlc0J1dE5vdEJ5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kZWNyZWFzZXNCdXROb3RCeSwgdHJ1ZSlcbiAgICAgIC50by5kZWNyZWFzZShvYmosIHByb3ApLmJ1dC5ub3QuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyohXG4gICAqICMjIyAuaWZFcnJvcihvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgaWYgdmFsdWUgaXMgbm90IGEgZmFsc2UgdmFsdWUsIGFuZCB0aHJvd3MgaWYgaXQgaXMgYSB0cnVlIHZhbHVlLlxuICAgKiBUaGlzIGlzIGFkZGVkIHRvIGFsbG93IGZvciBjaGFpIHRvIGJlIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgTm9kZSdzXG4gICAqIGFzc2VydCBjbGFzcy5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0kgYW0gYSBjdXN0b20gZXJyb3InKTtcbiAgICogICAgIGFzc2VydC5pZkVycm9yKGVycik7IC8vIFJldGhyb3dzIGVyciFcbiAgICpcbiAgICogQG5hbWUgaWZFcnJvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmICh2YWwpIHtcbiAgICAgIHRocm93KHZhbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRXh0ZW5zaWJsZShvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBleHRlbnNpYmxlIChjYW4gaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdCkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNFeHRlbnNpYmxlKHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNFeHRlbnNpYmxlXG4gICAqIEBhbGlhcyBleHRlbnNpYmxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNFeHRlbnNpYmxlID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzRXh0ZW5zaWJsZSwgdHJ1ZSkudG8uYmUuZXh0ZW5zaWJsZTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEV4dGVuc2libGUob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgX25vdF8gZXh0ZW5zaWJsZS5cbiAgICpcbiAgICogICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICogICAgIHZhciBzZWFsZWRPYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlKG5vbkV4dGVuc2libGVPYmplY3QpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZShzZWFsZWRPYmplY3QpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZShmcm96ZW5PYmplY3QpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEV4dGVuc2libGVcbiAgICogQGFsaWFzIG5vdEV4dGVuc2libGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEV4dGVuc2libGUgPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlLCB0cnVlKS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1NlYWxlZChvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBzZWFsZWQgKGNhbm5vdCBoYXZlIG5ldyBwcm9wZXJ0aWVzIGFkZGVkIHRvIGl0XG4gICAqIGFuZCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW5ub3QgYmUgcmVtb3ZlZCkuXG4gICAqXG4gICAqICAgICB2YXIgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pc1NlYWxlZChzZWFsZWRPYmplY3QpO1xuICAgKiAgICAgYXNzZXJ0LmlzU2VhbGVkKGZyb3plbk9iamVjdCk7XG4gICAqXG4gICAqIEBuYW1lIGlzU2VhbGVkXG4gICAqIEBhbGlhcyBzZWFsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1NlYWxlZCA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc1NlYWxlZCwgdHJ1ZSkudG8uYmUuc2VhbGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90U2VhbGVkKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIF9ub3RfIHNlYWxlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdFNlYWxlZCh7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90U2VhbGVkXG4gICAqIEBhbGlhcyBub3RTZWFsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdFNlYWxlZCA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc05vdFNlYWxlZCwgdHJ1ZSkudG8ubm90LmJlLnNlYWxlZDtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Zyb3plbihvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBmcm96ZW4gKGNhbm5vdCBoYXZlIG5ldyBwcm9wZXJ0aWVzIGFkZGVkIHRvIGl0XG4gICAqIGFuZCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW5ub3QgYmUgbW9kaWZpZWQpLlxuICAgKlxuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKiAgICAgYXNzZXJ0LmZyb3plbihmcm96ZW5PYmplY3QpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Zyb3plblxuICAgKiBAYWxpYXMgZnJvemVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGcm96ZW4gPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNGcm96ZW4sIHRydWUpLnRvLmJlLmZyb3plbjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEZyb3plbihvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBfbm90XyBmcm96ZW4uXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RGcm96ZW4oe30pO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEZyb3plblxuICAgKiBAYWxpYXMgbm90RnJvemVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGcm96ZW4gPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNOb3RGcm96ZW4sIHRydWUpLnRvLm5vdC5iZS5mcm96ZW47XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNFbXB0eSh0YXJnZXQpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGRvZXMgbm90IGNvbnRhaW4gYW55IHZhbHVlcy5cbiAgICogRm9yIGFycmF5cyBhbmQgc3RyaW5ncywgaXQgY2hlY2tzIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICogRm9yIGBNYXBgIGFuZCBgU2V0YCBpbnN0YW5jZXMsIGl0IGNoZWNrcyB0aGUgYHNpemVgIHByb3BlcnR5LlxuICAgKiBGb3Igbm9uLWZ1bmN0aW9uIG9iamVjdHMsIGl0IGdldHMgdGhlIGNvdW50IG9mIG93blxuICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzRW1wdHkoW10pO1xuICAgKiAgICAgYXNzZXJ0LmlzRW1wdHkoJycpO1xuICAgKiAgICAgYXNzZXJ0LmlzRW1wdHkobmV3IE1hcCk7XG4gICAqICAgICBhc3NlcnQuaXNFbXB0eSh7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzRW1wdHlcbiAgICogQGFsaWFzIGVtcHR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ3xNYXB8U2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNFbXB0eSA9IGZ1bmN0aW9uKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzRW1wdHksIHRydWUpLnRvLmJlLmVtcHR5O1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RW1wdHkodGFyZ2V0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBjb250YWlucyB2YWx1ZXMuXG4gICAqIEZvciBhcnJheXMgYW5kIHN0cmluZ3MsIGl0IGNoZWNrcyB0aGUgYGxlbmd0aGAgcHJvcGVydHkuXG4gICAqIEZvciBgTWFwYCBhbmQgYFNldGAgaW5zdGFuY2VzLCBpdCBjaGVja3MgdGhlIGBzaXplYCBwcm9wZXJ0eS5cbiAgICogRm9yIG5vbi1mdW5jdGlvbiBvYmplY3RzLCBpdCBnZXRzIHRoZSBjb3VudCBvZiBvd25cbiAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEVtcHR5KFsxLCAyXSk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFbXB0eSgnMzQnKTtcbiAgICogICAgIGFzc2VydC5pc05vdEVtcHR5KG5ldyBTZXQoWzUsIDZdKSk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFbXB0eSh7IGtleTogNyB9KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RFbXB0eVxuICAgKiBAYWxpYXMgbm90RW1wdHlcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfE1hcHxTZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEVtcHR5ID0gZnVuY3Rpb24odmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RFbXB0eSwgdHJ1ZSkudG8ubm90LmJlLmVtcHR5O1xuICB9O1xuXG4gIC8qIVxuICAgKiBBbGlhc2VzLlxuICAgKi9cblxuICAoZnVuY3Rpb24gYWxpYXMobmFtZSwgYXMpe1xuICAgIGFzc2VydFthc10gPSBhc3NlcnRbbmFtZV07XG4gICAgcmV0dXJuIGFsaWFzO1xuICB9KVxuICAoJ2lzT2snLCAnb2snKVxuICAoJ2lzTm90T2snLCAnbm90T2snKVxuICAoJ3Rocm93cycsICd0aHJvdycpXG4gICgndGhyb3dzJywgJ1Rocm93JylcbiAgKCdpc0V4dGVuc2libGUnLCAnZXh0ZW5zaWJsZScpXG4gICgnaXNOb3RFeHRlbnNpYmxlJywgJ25vdEV4dGVuc2libGUnKVxuICAoJ2lzU2VhbGVkJywgJ3NlYWxlZCcpXG4gICgnaXNOb3RTZWFsZWQnLCAnbm90U2VhbGVkJylcbiAgKCdpc0Zyb3plbicsICdmcm96ZW4nKVxuICAoJ2lzTm90RnJvemVuJywgJ25vdEZyb3plbicpXG4gICgnaXNFbXB0eScsICdlbXB0eScpXG4gICgnaXNOb3RFbXB0eScsICdub3RFbXB0eScpO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciB1c2VkID0gW107XG5cbi8qIVxuICogQ2hhaSB2ZXJzaW9uXG4gKi9cblxuZXhwb3J0cy52ZXJzaW9uID0gJzQuMi4wJztcblxuLyohXG4gKiBBc3NlcnRpb24gRXJyb3JcbiAqL1xuXG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnYXNzZXJ0aW9uLWVycm9yJyk7XG5cbi8qIVxuICogVXRpbHMgZm9yIHBsdWdpbnMgKG5vdCBleHBvcnRlZClcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vY2hhaS91dGlscycpO1xuXG4vKipcbiAqICMgLnVzZShmdW5jdGlvbilcbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byBleHRlbmQgdGhlIGludGVybmFscyBvZiBDaGFpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAcmV0dXJucyB7dGhpc30gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIGlmICghfnVzZWQuaW5kZXhPZihmbikpIHtcbiAgICBmbihleHBvcnRzLCB1dGlsKTtcbiAgICB1c2VkLnB1c2goZm4pO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG59O1xuXG4vKiFcbiAqIFV0aWxpdHkgRnVuY3Rpb25zXG4gKi9cblxuZXhwb3J0cy51dGlsID0gdXRpbDtcblxuLyohXG4gKiBDb25maWd1cmF0aW9uXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY2hhaS9jb25maWcnKTtcbmV4cG9ydHMuY29uZmlnID0gY29uZmlnO1xuXG4vKiFcbiAqIFByaW1hcnkgYEFzc2VydGlvbmAgcHJvdG90eXBlXG4gKi9cblxudmFyIGFzc2VydGlvbiA9IHJlcXVpcmUoJy4vY2hhaS9hc3NlcnRpb24nKTtcbmV4cG9ydHMudXNlKGFzc2VydGlvbik7XG5cbi8qIVxuICogQ29yZSBBc3NlcnRpb25zXG4gKi9cblxudmFyIGNvcmUgPSByZXF1aXJlKCcuL2NoYWkvY29yZS9hc3NlcnRpb25zJyk7XG5leHBvcnRzLnVzZShjb3JlKTtcblxuLyohXG4gKiBFeHBlY3QgaW50ZXJmYWNlXG4gKi9cblxudmFyIGV4cGVjdCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2UvZXhwZWN0Jyk7XG5leHBvcnRzLnVzZShleHBlY3QpO1xuXG4vKiFcbiAqIFNob3VsZCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgc2hvdWxkID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9zaG91bGQnKTtcbmV4cG9ydHMudXNlKHNob3VsZCk7XG5cbi8qIVxuICogQXNzZXJ0IGludGVyZmFjZVxuICovXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL2Fzc2VydCcpO1xuZXhwb3J0cy51c2UoYXNzZXJ0KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvY2hhaScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogIVxuICogdHlwZS1kZXRlY3RcbiAqIENvcHlyaWdodChjKSAyMDEzIGpha2UgbHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cbnZhciBnZXRQcm90b3R5cGVPZkV4aXN0cyA9IHR5cGVvZiBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPT09ICdmdW5jdGlvbic7XG52YXIgcHJvbWlzZUV4aXN0cyA9IHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nO1xudmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBzZWxmOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG52YXIgaXNEb20gPSAnbG9jYXRpb24nIGluIGdsb2JhbE9iamVjdCAmJiAnZG9jdW1lbnQnIGluIGdsb2JhbE9iamVjdDtcbnZhciBodG1sRWxlbWVudEV4aXN0cyA9IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaXNBcnJheUV4aXN0cyA9IHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nO1xudmFyIHN5bWJvbEV4aXN0cyA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xudmFyIG1hcEV4aXN0cyA9IHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnO1xudmFyIHNldEV4aXN0cyA9IHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnO1xudmFyIHdlYWtNYXBFeGlzdHMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgd2Vha1NldEV4aXN0cyA9IHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJztcbnZhciBkYXRhVmlld0V4aXN0cyA9IHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc3ltYm9sSXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xFeGlzdHMgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgPSBzeW1ib2xFeGlzdHMgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc2V0RW50cmllc0V4aXN0cyA9IHNldEV4aXN0cyAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nO1xudmFyIG1hcEVudHJpZXNFeGlzdHMgPSBtYXBFeGlzdHMgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBzZXRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mRXhpc3RzICYmIHNldEVudHJpZXNFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBTZXQoKS5lbnRyaWVzKCkpO1xudmFyIG1hcEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2ZFeGlzdHMgJiYgbWFwRW50cmllc0V4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IE1hcCgpLmVudHJpZXMoKSk7XG52YXIgYXJyYXlJdGVyYXRvckV4aXN0cyA9IHN5bWJvbEl0ZXJhdG9yRXhpc3RzICYmIHR5cGVvZiBBcnJheS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBhcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gYXJyYXlJdGVyYXRvckV4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoW11bU3ltYm9sLml0ZXJhdG9yXSgpKTtcbnZhciBzdHJpbmdJdGVyYXRvckV4aXN0cyA9IHN5bWJvbEl0ZXJhdG9yRXhpc3RzICYmIHR5cGVvZiBBcnJheS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBzdHJpbmdJdGVyYXRvclByb3RvdHlwZSA9IHN0cmluZ0l0ZXJhdG9yRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZignJ1tTeW1ib2wuaXRlcmF0b3JdKCkpO1xudmFyIHRvU3RyaW5nTGVmdFNsaWNlTGVuZ3RoID0gODtcbnZhciB0b1N0cmluZ1JpZ2h0U2xpY2VMZW5ndGggPSAtMTtcbi8qKlxuICogIyMjIHR5cGVPZiAob2JqKVxuICpcbiAqIFVzZXMgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiBhbiBvYmplY3QsXG4gKiBub3JtYWxpc2luZyBiZWhhdmlvdXIgYWNyb3NzIGVuZ2luZSB2ZXJzaW9ucyAmIHdlbGwgb3B0aW1pc2VkLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHJldHVybiB7U3RyaW5nfSBvYmplY3QgdHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0eXBlRGV0ZWN0KG9iaikge1xuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgKiBQcmU6XG4gICAqICAgc3RyaW5nIGxpdGVyYWwgICAgIHggMywwMzksMDM1IG9wcy9zZWMgwrExLjYyJSAoNzggcnVucyBzYW1wbGVkKVxuICAgKiAgIGJvb2xlYW4gbGl0ZXJhbCAgICB4IDEsNDI0LDEzOCBvcHMvc2VjIMKxNC41NCUgKDc1IHJ1bnMgc2FtcGxlZClcbiAgICogICBudW1iZXIgbGl0ZXJhbCAgICAgeCAxLDY1MywxNTMgb3BzL3NlYyDCsTEuOTElICg4MiBydW5zIHNhbXBsZWQpXG4gICAqICAgdW5kZWZpbmVkICAgICAgICAgIHggOSw5NzgsNjYwIG9wcy9zZWMgwrExLjkyJSAoNzUgcnVucyBzYW1wbGVkKVxuICAgKiAgIGZ1bmN0aW9uICAgICAgICAgICB4IDIsNTU2LDc2OSBvcHMvc2VjIMKxMS43MyUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgICogUG9zdDpcbiAgICogICBzdHJpbmcgbGl0ZXJhbCAgICAgeCAzOCw1NjQsNzk2IG9wcy9zZWMgwrExLjE1JSAoNzkgcnVucyBzYW1wbGVkKVxuICAgKiAgIGJvb2xlYW4gbGl0ZXJhbCAgICB4IDMxLDE0OCw5NDAgb3BzL3NlYyDCsTEuMTAlICg3OSBydW5zIHNhbXBsZWQpXG4gICAqICAgbnVtYmVyIGxpdGVyYWwgICAgIHggMzIsNjc5LDMzMCBvcHMvc2VjIMKxMS45MCUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgICogICB1bmRlZmluZWQgICAgICAgICAgeCAzMiwzNjMsMzY4IG9wcy9zZWMgwrExLjA3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiAgIGZ1bmN0aW9uICAgICAgICAgICB4IDMxLDI5Niw4NzAgb3BzL3NlYyDCsTAuOTYlICg4MyBydW5zIHNhbXBsZWQpXG4gICAqL1xuICB2YXIgdHlwZW9mT2JqID0gdHlwZW9mIG9iajtcbiAgaWYgKHR5cGVvZk9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZW9mT2JqO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIG51bGwgICAgICAgICAgICAgICB4IDI4LDY0NSw3NjUgb3BzL3NlYyDCsTEuMTclICg4MiBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgbnVsbCAgICAgICAgICAgICAgIHggMzYsNDI4LDk2MiBvcHMvc2VjIMKxMS4zNyUgKDg0IHJ1bnMgc2FtcGxlZClcbiAgICovXG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93KWBgXG4gICAqICAtIE5vZGUgPT09IFwiW29iamVjdCBnbG9iYWxdXCJcbiAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgZ2xvYmFsXVwiXG4gICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gUGhhbnRvbUpTID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBJRSAxMSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBJRSBFZGdlID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcylgYFxuICAgKiAgLSBDaHJvbWUgV29ya2VyID09PSBcIltvYmplY3QgZ2xvYmFsXVwiXG4gICAqICAtIEZpcmVmb3ggV29ya2VyID09PSBcIltvYmplY3QgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICogIC0gU2FmYXJpIFdvcmtlciA9PT0gXCJbb2JqZWN0IERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqICAtIElFIDExIFdvcmtlciA9PT0gXCJbb2JqZWN0IFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqICAtIElFIEVkZ2UgV29ya2VyID09PSBcIltvYmplY3QgV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICovXG4gIGlmIChvYmogPT09IGdsb2JhbE9iamVjdCkge1xuICAgIHJldHVybiAnZ2xvYmFsJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBhcnJheSBsaXRlcmFsICAgICAgeCAyLDg4OCwzNTIgb3BzL3NlYyDCsTAuNjclICg4MiBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgYXJyYXkgbGl0ZXJhbCAgICAgIHggMjIsNDc5LDY1MCBvcHMvc2VjIMKxMC45NiUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgICovXG4gIGlmIChpc0FycmF5RXhpc3RzICYmIEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiAnQXJyYXknO1xuICB9XG5cbiAgaWYgKGlzRG9tKSB7XG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Jyb3dzZXJzLmh0bWwjbG9jYXRpb24pXG4gICAgICogV2hhdFdHIEhUTUwkNy43LjMgLSBUaGUgYExvY2F0aW9uYCBpbnRlcmZhY2VcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5sb2NhdGlvbilgYFxuICAgICAqICAtIElFIDw9MTEgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKiAgLSBJRSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKi9cbiAgICBpZiAob2JqID09PSBnbG9iYWxPYmplY3QubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiAnTG9jYXRpb24nO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNkb2N1bWVudClcbiAgICAgKiBXaGF0V0cgSFRNTCQzLjEuMSAtIFRoZSBgRG9jdW1lbnRgIG9iamVjdFxuICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAqICAgICAgIChodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwjSUQtMjY4MDkyNjgpXG4gICAgICogICAgICAgd2hpY2ggc3VnZ2VzdHMgdGhhdCBicm93c2VycyBzaG91bGQgdXNlIEhUTUxUYWJsZUNlbGxFbGVtZW50IGZvclxuICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAqICAgICAgIFdoYXRXRyBIVE1MIHN0YXRlczpcbiAgICAgKiAgICAgICAgID4gRm9yIGhpc3RvcmljYWwgcmVhc29ucywgV2luZG93IG9iamVjdHMgbXVzdCBhbHNvIGhhdmUgYVxuICAgICAqICAgICAgICAgPiB3cml0YWJsZSwgY29uZmlndXJhYmxlLCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lZFxuICAgICAqICAgICAgICAgPiBIVE1MRG9jdW1lbnQgd2hvc2UgdmFsdWUgaXMgdGhlIERvY3VtZW50IGludGVyZmFjZSBvYmplY3QuXG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudClgYFxuICAgICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSAxMSA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIElFIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqL1xuICAgIGlmIChvYmogPT09IGdsb2JhbE9iamVjdC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuICdEb2N1bWVudCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNtaW1ldHlwZWFycmF5KVxuICAgICAqIFdoYXRXRyBIVE1MJDguNi4xLjUgLSBQbHVnaW5zIC0gSW50ZXJmYWNlIE1pbWVUeXBlQXJyYXlcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5hdmlnYXRvci5taW1lVHlwZXMpYGBcbiAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgTVNNaW1lVHlwZXNDb2xsZWN0aW9uXVwiXG4gICAgICovXG4gICAgaWYgKG9iaiA9PT0gKGdsb2JhbE9iamVjdC5uYXZpZ2F0b3IgfHwge30pLm1pbWVUeXBlcykge1xuICAgICAgcmV0dXJuICdNaW1lVHlwZUFycmF5JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3BsdWdpbmFycmF5KVxuICAgICAqIFdoYXRXRyBIVE1MJDguNi4xLjUgLSBQbHVnaW5zIC0gSW50ZXJmYWNlIFBsdWdpbkFycmF5XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYXZpZ2F0b3IucGx1Z2lucylgYFxuICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBNU1BsdWdpbnNDb2xsZWN0aW9uXVwiXG4gICAgICovXG4gICAgaWYgKG9iaiA9PT0gKGdsb2JhbE9iamVjdC5uYXZpZ2F0b3IgfHwge30pLnBsdWdpbnMpIHtcbiAgICAgIHJldHVybiAnUGx1Z2luQXJyYXknO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjcGx1Z2luYXJyYXkpXG4gICAgICogV2hhdFdHIEhUTUwkNC40LjQgLSBUaGUgYGJsb2NrcXVvdGVgIGVsZW1lbnQgLSBJbnRlcmZhY2UgYEhUTUxRdW90ZUVsZW1lbnRgXG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdibG9ja3F1b3RlJykpYGBcbiAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgSFRNTEJsb2NrRWxlbWVudF1cIlxuICAgICAqL1xuICAgIGlmIChodG1sRWxlbWVudEV4aXN0cyAmJiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBvYmoudGFnTmFtZSA9PT0gJ0JMT0NLUVVPVEUnKSB7XG4gICAgICByZXR1cm4gJ0hUTUxRdW90ZUVsZW1lbnQnO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNodG1sdGFibGVkYXRhY2VsbGVsZW1lbnQpXG4gICAgICogV2hhdFdHIEhUTUwkNC45LjkgLSBUaGUgYHRkYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MVGFibGVEYXRhQ2VsbEVsZW1lbnRgXG4gICAgICogTm90ZTogTW9zdCBicm93c2VycyBjdXJyZW50bHkgYWRoZXIgdG8gdGhlIFczQyBET00gTGV2ZWwgMiBzcGVjXG4gICAgICogICAgICAgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1IVE1ML2h0bWwuaHRtbCNJRC04MjkxNTA3NSlcbiAgICAgKiAgICAgICB3aGljaCBzdWdnZXN0cyB0aGF0IGJyb3dzZXJzIHNob3VsZCB1c2UgSFRNTFRhYmxlQ2VsbEVsZW1lbnQgZm9yXG4gICAgICogICAgICAgYm90aCBURCBhbmQgVEggZWxlbWVudHMuIFdoYXRXRyBzZXBhcmF0ZXMgdGhlc2UuXG4gICAgICogVGVzdDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJykpXG4gICAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqL1xuICAgIGlmIChodG1sRWxlbWVudEV4aXN0cyAmJiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBvYmoudGFnTmFtZSA9PT0gJ1REJykge1xuICAgICAgcmV0dXJuICdIVE1MVGFibGVEYXRhQ2VsbEVsZW1lbnQnO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNodG1sdGFibGVoZWFkZXJjZWxsZWxlbWVudClcbiAgICAgKiBXaGF0V0cgSFRNTCQ0LjkuOSAtIFRoZSBgdGRgIGVsZW1lbnQgLSBJbnRlcmZhY2UgYEhUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50YFxuICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAqICAgICAgIChodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwjSUQtODI5MTUwNzUpXG4gICAgICogICAgICAgd2hpY2ggc3VnZ2VzdHMgdGhhdCBicm93c2VycyBzaG91bGQgdXNlIEhUTUxUYWJsZUNlbGxFbGVtZW50IGZvclxuICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAqIFRlc3Q6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpKVxuICAgICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAoaHRtbEVsZW1lbnRFeGlzdHMgJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgb2JqLnRhZ05hbWUgPT09ICdUSCcpIHtcbiAgICAgIHJldHVybiAnSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnQnO1xuICAgIH1cbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgRmxvYXQ2NEFycmF5ICAgICAgIHggNjI1LDY0NCBvcHMvc2VjIMKxMS41OCUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEZsb2F0MzJBcnJheSAgICAgICB4IDEsMjc5LDg1MiBvcHMvc2VjIMKxMi45MSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQzMkFycmF5ICAgICAgICB4IDEsMTc4LDE4NSBvcHMvc2VjIMKxMS45NSUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQxNkFycmF5ICAgICAgICB4IDEsMDA4LDM4MCBvcHMvc2VjIMKxMi4yNSUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQ4QXJyYXkgICAgICAgICB4IDEsMTI4LDA0MCBvcHMvc2VjIMKxMi4xMSUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDMyQXJyYXkgICAgICAgICB4IDEsMTcwLDExOSBvcHMvc2VjIMKxMi44OCUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDE2QXJyYXkgICAgICAgICB4IDEsMTc2LDM0OCBvcHMvc2VjIMKxNS43OSUgKDg2IHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDhBcnJheSAgICAgICAgICB4IDEsMDU4LDcwNyBvcHMvc2VjIMKxNC45NCUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQ4Q2xhbXBlZEFycmF5ICB4IDEsMTEwLDYzMyBvcHMvc2VjIMKxNC4yMCUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgRmxvYXQ2NEFycmF5ICAgICAgIHggNywxMDUsNjcxIG9wcy9zZWMgwrExMy40NyUgKDY0IHJ1bnMgc2FtcGxlZClcbiAgKiAgIEZsb2F0MzJBcnJheSAgICAgICB4IDUsODg3LDkxMiBvcHMvc2VjIMKxMS40NiUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQzMkFycmF5ICAgICAgICB4IDYsNDkxLDY2MSBvcHMvc2VjIMKxMS43NiUgKDc5IHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQxNkFycmF5ICAgICAgICB4IDYsNTU5LDc5NSBvcHMvc2VjIMKxMS42NyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQ4QXJyYXkgICAgICAgICB4IDYsNDYzLDk2NiBvcHMvc2VjIMKxMS40MyUgKDg1IHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDMyQXJyYXkgICAgICAgICB4IDUsNjQxLDg0MSBvcHMvc2VjIMKxMy40OSUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDE2QXJyYXkgICAgICAgICB4IDYsNTgzLDUxMSBvcHMvc2VjIMKxMS45OCUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDhBcnJheSAgICAgICAgICB4IDYsNjA2LDA3OCBvcHMvc2VjIMKxMS43NCUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQ4Q2xhbXBlZEFycmF5ICB4IDYsNjAyLDIyNCBvcHMvc2VjIMKxMS43NyUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgdmFyIHN0cmluZ1RhZyA9IChzeW1ib2xUb1N0cmluZ1RhZ0V4aXN0cyAmJiBvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSk7XG4gIGlmICh0eXBlb2Ygc3RyaW5nVGFnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHJpbmdUYWc7XG4gIH1cblxuICBpZiAoZ2V0UHJvdG90eXBlT2ZFeGlzdHMpIHtcbiAgICB2YXIgb2JqUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgcmVnZXggbGl0ZXJhbCAgICAgIHggMSw3NzIsMzg1IG9wcy9zZWMgwrExLjg1JSAoNzcgcnVucyBzYW1wbGVkKVxuICAgICogICByZWdleCBjb25zdHJ1Y3RvciAgeCAyLDE0Myw2MzQgb3BzL3NlYyDCsTIuNDYlICg3OCBydW5zIHNhbXBsZWQpXG4gICAgKiBQb3N0OlxuICAgICogICByZWdleCBsaXRlcmFsICAgICAgeCAzLDkyOCwwMDkgb3BzL3NlYyDCsTAuNjUlICg3OCBydW5zIHNhbXBsZWQpXG4gICAgKiAgIHJlZ2V4IGNvbnN0cnVjdG9yICB4IDMsOTMxLDEwOCBvcHMvc2VjIMKxMC41OCUgKDg0IHJ1bnMgc2FtcGxlZClcbiAgICAqL1xuICAgIGlmIChvYmpQcm90b3R5cGUgPT09IFJlZ0V4cC5wcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnUmVnRXhwJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgICogUHJlOlxuICAgICogICBkYXRlICAgICAgICAgICAgICAgeCAyLDEzMCwwNzQgb3BzL3NlYyDCsTQuNDIlICg2OCBydW5zIHNhbXBsZWQpXG4gICAgKiBQb3N0OlxuICAgICogICBkYXRlICAgICAgICAgICAgICAgeCAzLDk1Myw3Nzkgb3BzL3NlYyDCsTEuMzUlICg3NyBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAob2JqUHJvdG90eXBlID09PSBEYXRlLnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdEYXRlJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy1wcm9taXNlLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnKVxuICAgICAqIEVTNiQyNS40LjUuNCAtIFByb21pc2UucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIlByb21pc2VcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFByb21pc2UucmVzb2x2ZSgpKWBgXG4gICAgICogIC0gQ2hyb21lIDw9NDcgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKiAgLSBFZGdlIDw9MjAgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKiAgLSBGaXJlZm94IDI5LUxhdGVzdCA9PT0gXCJbb2JqZWN0IFByb21pc2VdXCJcbiAgICAgKiAgLSBTYWZhcmkgNy4xLUxhdGVzdCA9PT0gXCJbb2JqZWN0IFByb21pc2VdXCJcbiAgICAgKi9cbiAgICBpZiAocHJvbWlzZUV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFByb21pc2UucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1Byb21pc2UnO1xuICAgIH1cblxuICAgIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAgKiBQcmU6XG4gICAgKiAgIHNldCAgICAgICAgICAgICAgICB4IDIsMjIyLDE4NiBvcHMvc2VjIMKxMS4zMSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICAqIFBvc3Q6XG4gICAgKiAgIHNldCAgICAgICAgICAgICAgICB4IDQsNTQ1LDg3OSBvcHMvc2VjIMKxMS4xMyUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgICAqL1xuICAgIGlmIChzZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBTZXQucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1NldCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgbWFwICAgICAgICAgICAgICAgIHggMiwzOTYsODQyIG9wcy9zZWMgwrExLjU5JSAoODEgcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgbWFwICAgICAgICAgICAgICAgIHggNCwxODMsOTQ1IG9wcy9zZWMgwrE2LjU5JSAoODIgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKG1hcEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IE1hcC5wcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnTWFwJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgICogUHJlOlxuICAgICogICB3ZWFrc2V0ICAgICAgICAgICAgeCAxLDMyMywyMjAgb3BzL3NlYyDCsTIuMTclICg3NiBydW5zIHNhbXBsZWQpXG4gICAgKiBQb3N0OlxuICAgICogICB3ZWFrc2V0ICAgICAgICAgICAgeCA0LDIzNyw1MTAgb3BzL3NlYyDCsTIuMDElICg3NyBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAod2Vha1NldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFdlYWtTZXQucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1dlYWtTZXQnO1xuICAgIH1cblxuICAgIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAgKiBQcmU6XG4gICAgKiAgIHdlYWttYXAgICAgICAgICAgICB4IDEsNTAwLDI2MCBvcHMvc2VjIMKxMi4wMiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgICAqIFBvc3Q6XG4gICAgKiAgIHdlYWttYXAgICAgICAgICAgICB4IDMsODgxLDM4NCBvcHMvc2VjIMKxMS40NSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICAqL1xuICAgIGlmICh3ZWFrTWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gV2Vha01hcC5wcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnV2Vha01hcCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtZGF0YXZpZXcucHJvdG90eXBlLUBAdG9zdHJpbmd0YWcpXG4gICAgICogRVM2JDI0LjIuNC4yMSAtIERhdGFWaWV3LnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJEYXRhVmlld1wiOlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpYGBcbiAgICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKi9cbiAgICBpZiAoZGF0YVZpZXdFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBEYXRhVmlldy5wcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnRGF0YVZpZXcnO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVtYXBpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICAgKiBFUzYkMjMuMS41LjIuMiAtICVNYXBJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiTWFwIEl0ZXJhdG9yXCI6XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgTWFwKCkuZW50cmllcygpKWBgXG4gICAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKG1hcEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IG1hcEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ01hcCBJdGVyYXRvcic7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJXNldGl0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgICAqIEVTNiQyMy4yLjUuMi4yIC0gJVNldEl0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJTZXQgSXRlcmF0b3JcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBTZXQoKS5lbnRyaWVzKCkpYGBcbiAgICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKi9cbiAgICBpZiAoc2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gc2V0SXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnU2V0IEl0ZXJhdG9yJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICAgKiBFUzYkMjIuMS41LjIuMiAtICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJBcnJheSBJdGVyYXRvclwiOlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoW11bU3ltYm9sLml0ZXJhdG9yXSgpKWBgXG4gICAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKGFycmF5SXRlcmF0b3JFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBhcnJheUl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ0FycmF5IEl0ZXJhdG9yJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAgICogRVM2JDIxLjEuNS4yLjIgLSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIlN0cmluZyBJdGVyYXRvclwiOlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoJydbU3ltYm9sLml0ZXJhdG9yXSgpKWBgXG4gICAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKHN0cmluZ0l0ZXJhdG9yRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gc3RyaW5nSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnU3RyaW5nIEl0ZXJhdG9yJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgICogUHJlOlxuICAgICogICBvYmplY3QgZnJvbSBudWxsICAgeCAyLDQyNCwzMjAgb3BzL3NlYyDCsTEuNjclICg3NiBydW5zIHNhbXBsZWQpXG4gICAgKiBQb3N0OlxuICAgICogICBvYmplY3QgZnJvbSBudWxsICAgeCA1LDgzOCwwMDAgb3BzL3NlYyDCsTAuOTklICg4NCBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAob2JqUHJvdG90eXBlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ09iamVjdCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE9iamVjdFxuICAgIC5wcm90b3R5cGVcbiAgICAudG9TdHJpbmdcbiAgICAuY2FsbChvYmopXG4gICAgLnNsaWNlKHRvU3RyaW5nTGVmdFNsaWNlTGVuZ3RoLCB0b1N0cmluZ1JpZ2h0U2xpY2VMZW5ndGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMudHlwZURldGVjdCA9IG1vZHVsZS5leHBvcnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFscyBTeW1ib2w6IHRydWUsIFVpbnQ4QXJyYXk6IHRydWUsIFdlYWtNYXA6IHRydWUgKi9cbi8qIVxuICogZGVlcC1lcWxcbiAqIENvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuZnVuY3Rpb24gRmFrZU1hcCgpIHtcbiAgdGhpcy5jbGVhcigpO1xufVxuRmFrZU1hcC5wcm90b3R5cGUgPSB7XG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhck1hcCgpIHtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldE1hcChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy52YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gZ2V0TWFwKGtleSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1t0aGlzLmtleXMuaW5kZXhPZihrZXkpXTtcbiAgfSxcbiAgZGVsZXRlOiBmdW5jdGlvbiBkZWxldGVNYXAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy52YWx1ZXMgPSB0aGlzLnZhbHVlcy5zbGljZSgwLCBpbmRleCkuY29uY2F0KHRoaXMudmFsdWVzLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgICAgdGhpcy5rZXlzID0gdGhpcy5rZXlzLnNsaWNlKDAsIGluZGV4KS5jb25jYXQodGhpcy5rZXlzLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbn07XG5cbnZhciBNZW1vaXplTWFwID0gbnVsbDtcbmlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJykge1xuICBNZW1vaXplTWFwID0gV2Vha01hcDtcbn0gZWxzZSB7XG4gIE1lbW9pemVNYXAgPSBGYWtlTWFwO1xufVxuXG4vKiFcbiAqIENoZWNrIHRvIHNlZSBpZiB0aGUgTWVtb2l6ZU1hcCBoYXMgcmVjb3JkZWQgYSByZXN1bHQgb2YgdGhlIHR3byBvcGVyYW5kc1xuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNZW1vaXplTWFwfSBtZW1vaXplTWFwXG4gKiBAcmV0dXJucyB7Qm9vbGVhbnxudWxsfSByZXN1bHRcbiovXG5mdW5jdGlvbiBtZW1vaXplQ29tcGFyZShsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG1lbW9pemVNYXApIHtcbiAgLy8gVGVjaG5pY2FsbHksIFdlYWtNYXAga2V5cyBjYW4gKm9ubHkqIGJlIG9iamVjdHMsIG5vdCBwcmltaXRpdmVzLlxuICBpZiAoIW1lbW9pemVNYXAgfHwgaXNQcmltaXRpdmUobGVmdEhhbmRPcGVyYW5kKSB8fCBpc1ByaW1pdGl2ZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBsZWZ0SGFuZE1hcCA9IG1lbW9pemVNYXAuZ2V0KGxlZnRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZE1hcCkge1xuICAgIHZhciByZXN1bHQgPSBsZWZ0SGFuZE1hcC5nZXQocmlnaHRIYW5kT3BlcmFuZCk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qIVxuICogU2V0IHRoZSByZXN1bHQgb2YgdGhlIGVxdWFsaXR5IGludG8gdGhlIE1lbW9pemVNYXBcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWVtb2l6ZU1hcH0gbWVtb2l6ZU1hcFxuICogQHBhcmFtIHtCb29sZWFufSByZXN1bHRcbiovXG5mdW5jdGlvbiBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbWVtb2l6ZU1hcCwgcmVzdWx0KSB7XG4gIC8vIFRlY2huaWNhbGx5LCBXZWFrTWFwIGtleXMgY2FuICpvbmx5KiBiZSBvYmplY3RzLCBub3QgcHJpbWl0aXZlcy5cbiAgaWYgKCFtZW1vaXplTWFwIHx8IGlzUHJpbWl0aXZlKGxlZnRIYW5kT3BlcmFuZCkgfHwgaXNQcmltaXRpdmUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGxlZnRIYW5kTWFwID0gbWVtb2l6ZU1hcC5nZXQobGVmdEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kTWFwKSB7XG4gICAgbGVmdEhhbmRNYXAuc2V0KHJpZ2h0SGFuZE9wZXJhbmQsIHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgbGVmdEhhbmRNYXAgPSBuZXcgTWVtb2l6ZU1hcCgpO1xuICAgIGxlZnRIYW5kTWFwLnNldChyaWdodEhhbmRPcGVyYW5kLCByZXN1bHQpO1xuICAgIG1lbW9pemVNYXAuc2V0KGxlZnRIYW5kT3BlcmFuZCwgbGVmdEhhbmRNYXApO1xuICB9XG59XG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBFcXVhbDtcbm1vZHVsZS5leHBvcnRzLk1lbW9pemVNYXAgPSBNZW1vaXplTWFwO1xuXG4vKipcbiAqIEFzc2VydCBkZWVwbHkgbmVzdGVkIHNhbWVWYWx1ZSBlcXVhbGl0eSBiZXR3ZWVuIHR3byBvYmplY3RzIG9mIGFueSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAob3B0aW9uYWwpIEFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuY29tcGFyYXRvcl0gKG9wdGlvbmFsKSBPdmVycmlkZSBkZWZhdWx0IGFsZ29yaXRobSwgZGV0ZXJtaW5pbmcgY3VzdG9tIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWVtb2l6ZV0gKG9wdGlvbmFsKSBQcm92aWRlIGEgY3VzdG9tIG1lbW9pemF0aW9uIG9iamVjdCB3aGljaCB3aWxsIGNhY2hlIHRoZSByZXN1bHRzIG9mXG4gICAgY29tcGxleCBvYmplY3RzIGZvciBhIHNwZWVkIGJvb3N0LiBCeSBwYXNzaW5nIGBmYWxzZWAgeW91IGNhbiBkaXNhYmxlIG1lbW9pemF0aW9uLCBidXQgdGhpcyB3aWxsIGNhdXNlIGNpcmN1bGFyXG4gICAgcmVmZXJlbmNlcyB0byBibG93IHRoZSBzdGFjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVxdWFsIG1hdGNoXG4gKi9cbmZ1bmN0aW9uIGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgLy8gSWYgd2UgaGF2ZSBhIGNvbXBhcmF0b3IsIHdlIGNhbid0IGFzc3VtZSBhbnl0aGluZzsgc28gYmFpbCB0byBpdHMgY2hlY2sgZmlyc3QuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29tcGFyYXRvcikge1xuICAgIHJldHVybiBleHRlbnNpdmVEZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBzaW1wbGVSZXN1bHQgPSBzaW1wbGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAoc2ltcGxlUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNpbXBsZVJlc3VsdDtcbiAgfVxuXG4gIC8vIERlZXBlciBjb21wYXJpc29ucyBhcmUgcHVzaGVkIHRocm91Z2ggdG8gYSBsYXJnZXIgZnVuY3Rpb25cbiAgcmV0dXJuIGV4dGVuc2l2ZURlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIE1hbnkgY29tcGFyaXNvbnMgY2FuIGJlIGNhbmNlbGVkIG91dCBlYXJseSB2aWEgc2ltcGxlIGVxdWFsaXR5IG9yIHByaW1pdGl2ZSBjaGVja3MuXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEByZXR1cm4ge0Jvb2xlYW58bnVsbH0gZXF1YWwgbWF0Y2hcbiAqL1xuZnVuY3Rpb24gc2ltcGxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKSB7XG4gIC8vIEVxdWFsIHJlZmVyZW5jZXMgKGV4Y2VwdCBmb3IgTnVtYmVycykgY2FuIGJlIHJldHVybmVkIGVhcmx5XG4gIGlmIChsZWZ0SGFuZE9wZXJhbmQgPT09IHJpZ2h0SGFuZE9wZXJhbmQpIHtcbiAgICAvLyBIYW5kbGUgKy0wIGNhc2VzXG4gICAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZCAhPT0gMCB8fCAxIC8gbGVmdEhhbmRPcGVyYW5kID09PSAxIC8gcmlnaHRIYW5kT3BlcmFuZDtcbiAgfVxuXG4gIC8vIGhhbmRsZSBOYU4gY2FzZXNcbiAgaWYgKFxuICAgIGxlZnRIYW5kT3BlcmFuZCAhPT0gbGVmdEhhbmRPcGVyYW5kICYmIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmlnaHRIYW5kT3BlcmFuZCAhPT0gcmlnaHRIYW5kT3BlcmFuZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEFueXRoaW5nIHRoYXQgaXMgbm90IGFuICdvYmplY3QnLCBpLmUuIHN5bWJvbHMsIGZ1bmN0aW9ucywgYm9vbGVhbnMsIG51bWJlcnMsXG4gIC8vIHN0cmluZ3MsIGFuZCB1bmRlZmluZWQsIGNhbiBiZSBjb21wYXJlZCBieSByZWZlcmVuY2UuXG4gIGlmIChpc1ByaW1pdGl2ZShsZWZ0SGFuZE9wZXJhbmQpIHx8IGlzUHJpbWl0aXZlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgLy8gRWFzeSBvdXQgYi9jIGl0IHdvdWxkIGhhdmUgcGFzc2VkIHRoZSBmaXJzdCBlcXVhbGl0eSBjaGVja1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyohXG4gKiBUaGUgbWFpbiBsb2dpYyBvZiB0aGUgYGRlZXBFcXVhbGAgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChvcHRpb25hbCkgQWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jb21wYXJhdG9yXSAob3B0aW9uYWwpIE92ZXJyaWRlIGRlZmF1bHQgYWxnb3JpdGhtLCBkZXRlcm1pbmluZyBjdXN0b20gZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tZW1vaXplXSAob3B0aW9uYWwpIFByb3ZpZGUgYSBjdXN0b20gbWVtb2l6YXRpb24gb2JqZWN0IHdoaWNoIHdpbGwgY2FjaGUgdGhlIHJlc3VsdHMgb2ZcbiAgICBjb21wbGV4IG9iamVjdHMgZm9yIGEgc3BlZWQgYm9vc3QuIEJ5IHBhc3NpbmcgYGZhbHNlYCB5b3UgY2FuIGRpc2FibGUgbWVtb2l6YXRpb24sIGJ1dCB0aGlzIHdpbGwgY2F1c2UgY2lyY3VsYXJcbiAgICByZWZlcmVuY2VzIHRvIGJsb3cgdGhlIHN0YWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiovXG5mdW5jdGlvbiBleHRlbnNpdmVEZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLm1lbW9pemUgPSBvcHRpb25zLm1lbW9pemUgPT09IGZhbHNlID8gZmFsc2UgOiBvcHRpb25zLm1lbW9pemUgfHwgbmV3IE1lbW9pemVNYXAoKTtcbiAgdmFyIGNvbXBhcmF0b3IgPSBvcHRpb25zICYmIG9wdGlvbnMuY29tcGFyYXRvcjtcblxuICAvLyBDaGVjayBpZiBhIG1lbW9pemVkIHJlc3VsdCBleGlzdHMuXG4gIHZhciBtZW1vaXplUmVzdWx0TGVmdCA9IG1lbW9pemVDb21wYXJlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplKTtcbiAgaWYgKG1lbW9pemVSZXN1bHRMZWZ0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG1lbW9pemVSZXN1bHRMZWZ0O1xuICB9XG4gIHZhciBtZW1vaXplUmVzdWx0UmlnaHQgPSBtZW1vaXplQ29tcGFyZShyaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSk7XG4gIGlmIChtZW1vaXplUmVzdWx0UmlnaHQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbWVtb2l6ZVJlc3VsdFJpZ2h0O1xuICB9XG5cbiAgLy8gSWYgYSBjb21wYXJhdG9yIGlzIHByZXNlbnQsIHVzZSBpdC5cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgY29tcGFyYXRvclJlc3VsdCA9IGNvbXBhcmF0b3IobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgICAvLyBDb21wYXJhdG9ycyBtYXkgcmV0dXJuIG51bGwsIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBnbyBiYWNrIHRvIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgaWYgKGNvbXBhcmF0b3JSZXN1bHQgPT09IGZhbHNlIHx8IGNvbXBhcmF0b3JSZXN1bHQgPT09IHRydWUpIHtcbiAgICAgIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIGNvbXBhcmF0b3JSZXN1bHQpO1xuICAgICAgcmV0dXJuIGNvbXBhcmF0b3JSZXN1bHQ7XG4gICAgfVxuICAgIC8vIFRvIGFsbG93IGNvbXBhcmF0b3JzIHRvIG92ZXJyaWRlICphbnkqIGJlaGF2aW9yLCB3ZSByYW4gdGhlbSBmaXJzdC4gU2luY2UgaXQgZGlkbid0IGRlY2lkZVxuICAgIC8vIHdoYXQgdG8gZG8sIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRvIHJldHVybiB0aGUgYmFzaWMgdGVzdHMgZmlyc3QgYmVmb3JlIHdlIG1vdmUgb24uXG4gICAgdmFyIHNpbXBsZVJlc3VsdCA9IHNpbXBsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gICAgaWYgKHNpbXBsZVJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgLy8gRG9uJ3QgbWVtb2l6ZSB0aGlzLCBpdCB0YWtlcyBsb25nZXIgdG8gc2V0L3JldHJpZXZlIHRoYW4gdG8ganVzdCBjb21wYXJlLlxuICAgICAgcmV0dXJuIHNpbXBsZVJlc3VsdDtcbiAgICB9XG4gIH1cblxuICB2YXIgbGVmdEhhbmRUeXBlID0gdHlwZShsZWZ0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRUeXBlICE9PSB0eXBlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgZmFsc2UpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlbXBvcmFyaWx5IHNldCB0aGUgb3BlcmFuZHMgaW4gdGhlIG1lbW9pemUgb2JqZWN0IHRvIHByZXZlbnQgYmxvd2luZyB0aGUgc3RhY2tcbiAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgdHJ1ZSk7XG5cbiAgdmFyIHJlc3VsdCA9IGV4dGVuc2l2ZURlZXBFcXVhbEJ5VHlwZShsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kVHlwZSwgb3B0aW9ucyk7XG4gIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGV4dGVuc2l2ZURlZXBFcXVhbEJ5VHlwZShsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kVHlwZSwgb3B0aW9ucykge1xuICBzd2l0Y2ggKGxlZnRIYW5kVHlwZSkge1xuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICBjYXNlICdEYXRlJzpcbiAgICAgIC8vIElmIHRoZXNlIHR5cGVzIGFyZSB0aGVpciBpbnN0YW5jZSB0eXBlcyAoZS5nLiBgbmV3IE51bWJlcmApIHRoZW4gcmUtZGVlcEVxdWFsIGFnYWluc3QgdGhlaXIgdmFsdWVzXG4gICAgICByZXR1cm4gZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZC52YWx1ZU9mKCksIHJpZ2h0SGFuZE9wZXJhbmQudmFsdWVPZigpKTtcbiAgICBjYXNlICdQcm9taXNlJzpcbiAgICBjYXNlICdTeW1ib2wnOlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdXZWFrTWFwJzpcbiAgICBjYXNlICdXZWFrU2V0JzpcbiAgICBjYXNlICdFcnJvcic6XG4gICAgICByZXR1cm4gbGVmdEhhbmRPcGVyYW5kID09PSByaWdodEhhbmRPcGVyYW5kO1xuICAgIGNhc2UgJ0FyZ3VtZW50cyc6XG4gICAgY2FzZSAnSW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6XG4gICAgY2FzZSAnSW50MTZBcnJheSc6XG4gICAgY2FzZSAnVWludDE2QXJyYXknOlxuICAgIGNhc2UgJ0ludDMyQXJyYXknOlxuICAgIGNhc2UgJ1VpbnQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOlxuICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6XG4gICAgY2FzZSAnQXJyYXknOlxuICAgICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdSZWdFeHAnOlxuICAgICAgcmV0dXJuIHJlZ2V4cEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gICAgY2FzZSAnR2VuZXJhdG9yJzpcbiAgICAgIHJldHVybiBnZW5lcmF0b3JFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ0RhdGFWaWV3JzpcbiAgICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKG5ldyBVaW50OEFycmF5KGxlZnRIYW5kT3BlcmFuZC5idWZmZXIpLCBuZXcgVWludDhBcnJheShyaWdodEhhbmRPcGVyYW5kLmJ1ZmZlciksIG9wdGlvbnMpO1xuICAgIGNhc2UgJ0FycmF5QnVmZmVyJzpcbiAgICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKG5ldyBVaW50OEFycmF5KGxlZnRIYW5kT3BlcmFuZCksIG5ldyBVaW50OEFycmF5KHJpZ2h0SGFuZE9wZXJhbmQpLCBvcHRpb25zKTtcbiAgICBjYXNlICdTZXQnOlxuICAgICAgcmV0dXJuIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ01hcCc6XG4gICAgICByZXR1cm4gZW50cmllc0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBvYmplY3RFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgZXF1YWxpdHkuXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtSZWdFeHB9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIHJlZ2V4cEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCkge1xuICByZXR1cm4gbGVmdEhhbmRPcGVyYW5kLnRvU3RyaW5nKCkgPT09IHJpZ2h0SGFuZE9wZXJhbmQudG9TdHJpbmcoKTtcbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byBTZXRzL01hcHMgZm9yIGVxdWFsaXR5LiBGYXN0ZXIgdGhhbiBvdGhlciBlcXVhbGl0eSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtTZXR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtTZXR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZW50cmllc0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICAvLyBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBTZXQjZW50cmllcyBvciBTZXQjQEBpdGVyYXRvciwgc28gd2UgbmVlZCBtYW51YWxseSBwb3B1bGF0ZSB1c2luZyBTZXQjZm9yRWFjaFxuICBpZiAobGVmdEhhbmRPcGVyYW5kLnNpemUgIT09IHJpZ2h0SGFuZE9wZXJhbmQuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobGVmdEhhbmRPcGVyYW5kLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgbGVmdEhhbmRJdGVtcyA9IFtdO1xuICB2YXIgcmlnaHRIYW5kSXRlbXMgPSBbXTtcbiAgbGVmdEhhbmRPcGVyYW5kLmZvckVhY2goZnVuY3Rpb24gZ2F0aGVyRW50cmllcyhrZXksIHZhbHVlKSB7XG4gICAgbGVmdEhhbmRJdGVtcy5wdXNoKFsga2V5LCB2YWx1ZSBdKTtcbiAgfSk7XG4gIHJpZ2h0SGFuZE9wZXJhbmQuZm9yRWFjaChmdW5jdGlvbiBnYXRoZXJFbnRyaWVzKGtleSwgdmFsdWUpIHtcbiAgICByaWdodEhhbmRJdGVtcy5wdXNoKFsga2V5LCB2YWx1ZSBdKTtcbiAgfSk7XG4gIHJldHVybiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kSXRlbXMuc29ydCgpLCByaWdodEhhbmRJdGVtcy5zb3J0KCksIG9wdGlvbnMpO1xufVxuXG4vKiFcbiAqIFNpbXBsZSBlcXVhbGl0eSBmb3IgZmxhdCBpdGVyYWJsZSBvYmplY3RzIHN1Y2ggYXMgQXJyYXlzLCBUeXBlZEFycmF5cyBvciBOb2RlLmpzIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtJdGVyYWJsZX0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHZhciBsZW5ndGggPSBsZWZ0SGFuZE9wZXJhbmQubGVuZ3RoO1xuICBpZiAobGVuZ3RoICE9PSByaWdodEhhbmRPcGVyYW5kLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTE7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmRbaW5kZXhdLCByaWdodEhhbmRPcGVyYW5kW2luZGV4XSwgb3B0aW9ucykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiFcbiAqIFNpbXBsZSBlcXVhbGl0eSBmb3IgZ2VuZXJhdG9yIG9iamVjdHMgc3VjaCBhcyB0aG9zZSByZXR1cm5lZCBieSBnZW5lcmF0b3IgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtJdGVyYWJsZX0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBnZW5lcmF0b3JFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwoZ2V0R2VuZXJhdG9yRW50cmllcyhsZWZ0SGFuZE9wZXJhbmQpLCBnZXRHZW5lcmF0b3JFbnRyaWVzKHJpZ2h0SGFuZE9wZXJhbmQpLCBvcHRpb25zKTtcbn1cblxuLyohXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgYW4gQEBpdGVyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBoYXMgYW4gQEBpdGVyYXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gaGFzSXRlcmF0b3JGdW5jdGlvbih0YXJnZXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB0YXJnZXRbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyohXG4gKiBHZXRzIGFsbCBpdGVyYXRvciBlbnRyaWVzIGZyb20gdGhlIGdpdmVuIE9iamVjdC4gSWYgdGhlIE9iamVjdCBoYXMgbm8gQEBpdGVyYXRvciBmdW5jdGlvbiwgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cbiAqIFRoaXMgd2lsbCBjb25zdW1lIHRoZSBpdGVyYXRvciAtIHdoaWNoIGNvdWxkIGhhdmUgc2lkZSBlZmZlY3RzIGRlcGVuZGluZyBvbiB0aGUgQEBpdGVyYXRvciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIGVudHJpZXMgZnJvbSB0aGUgQEBpdGVyYXRvciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckVudHJpZXModGFyZ2V0KSB7XG4gIGlmIChoYXNJdGVyYXRvckZ1bmN0aW9uKHRhcmdldCkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdldEdlbmVyYXRvckVudHJpZXModGFyZ2V0W1N5bWJvbC5pdGVyYXRvcl0oKSk7XG4gICAgfSBjYXRjaCAoaXRlcmF0b3JFcnJvcikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW107XG59XG5cbi8qIVxuICogR2V0cyBhbGwgZW50cmllcyBmcm9tIGEgR2VuZXJhdG9yLiBUaGlzIHdpbGwgY29uc3VtZSB0aGUgZ2VuZXJhdG9yIC0gd2hpY2ggY291bGQgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gKlxuICogQHBhcmFtIHtHZW5lcmF0b3J9IHRhcmdldFxuICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBlbnRyaWVzIGZyb20gdGhlIEdlbmVyYXRvci5cbiAqL1xuZnVuY3Rpb24gZ2V0R2VuZXJhdG9yRW50cmllcyhnZW5lcmF0b3IpIHtcbiAgdmFyIGdlbmVyYXRvclJlc3VsdCA9IGdlbmVyYXRvci5uZXh0KCk7XG4gIHZhciBhY2N1bXVsYXRvciA9IFsgZ2VuZXJhdG9yUmVzdWx0LnZhbHVlIF07XG4gIHdoaWxlIChnZW5lcmF0b3JSZXN1bHQuZG9uZSA9PT0gZmFsc2UpIHtcbiAgICBnZW5lcmF0b3JSZXN1bHQgPSBnZW5lcmF0b3IubmV4dCgpO1xuICAgIGFjY3VtdWxhdG9yLnB1c2goZ2VuZXJhdG9yUmVzdWx0LnZhbHVlKTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qIVxuICogR2V0cyBhbGwgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBrZXlzIGZyb20gYSB0YXJnZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIGtleXMgZnJvbSB0aGUgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlS2V5cyh0YXJnZXQpIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG4vKiFcbiAqIERldGVybWluZXMgaWYgdHdvIG9iamVjdHMgaGF2ZSBtYXRjaGluZyB2YWx1ZXMsIGdpdmVuIGEgc2V0IG9mIGtleXMuIERlZmVycyB0byBkZWVwRXF1YWwgZm9yIHRoZSBlcXVhbGl0eSBjaGVjayBvZlxuICogZWFjaCBrZXkuIElmIGFueSB2YWx1ZSBvZiB0aGUgZ2l2ZW4ga2V5IGlzIG5vdCBlcXVhbCwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGZhbHNlIChlYXJseSkuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBrZXlzIEFuIGFycmF5IG9mIGtleXMgdG8gY29tcGFyZSB0aGUgdmFsdWVzIG9mIGxlZnRIYW5kT3BlcmFuZCBhbmQgcmlnaHRIYW5kT3BlcmFuZCBhZ2FpbnN0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5mdW5jdGlvbiBrZXlzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZFtrZXlzW2ldXSwgcmlnaHRIYW5kT3BlcmFuZFtrZXlzW2ldXSwgb3B0aW9ucykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiFcbiAqIFJlY3Vyc2l2ZWx5IGNoZWNrIHRoZSBlcXVhbGl0eSBvZiB0d28gT2JqZWN0cy4gT25jZSBiYXNpYyBzYW1lbmVzcyBoYXMgYmVlbiBlc3RhYmxpc2hlZCBpdCB3aWxsIGRlZmVyIHRvIGBkZWVwRXF1YWxgXG4gKiBmb3IgZWFjaCBlbnVtZXJhYmxlIGtleSBpbiB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBvYmplY3RFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlZnRIYW5kS2V5cyA9IGdldEVudW1lcmFibGVLZXlzKGxlZnRIYW5kT3BlcmFuZCk7XG4gIHZhciByaWdodEhhbmRLZXlzID0gZ2V0RW51bWVyYWJsZUtleXMocmlnaHRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZEtleXMubGVuZ3RoICYmIGxlZnRIYW5kS2V5cy5sZW5ndGggPT09IHJpZ2h0SGFuZEtleXMubGVuZ3RoKSB7XG4gICAgbGVmdEhhbmRLZXlzLnNvcnQoKTtcbiAgICByaWdodEhhbmRLZXlzLnNvcnQoKTtcbiAgICBpZiAoaXRlcmFibGVFcXVhbChsZWZ0SGFuZEtleXMsIHJpZ2h0SGFuZEtleXMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5c0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRLZXlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBsZWZ0SGFuZEVudHJpZXMgPSBnZXRJdGVyYXRvckVudHJpZXMobGVmdEhhbmRPcGVyYW5kKTtcbiAgdmFyIHJpZ2h0SGFuZEVudHJpZXMgPSBnZXRJdGVyYXRvckVudHJpZXMocmlnaHRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZEVudHJpZXMubGVuZ3RoICYmIGxlZnRIYW5kRW50cmllcy5sZW5ndGggPT09IHJpZ2h0SGFuZEVudHJpZXMubGVuZ3RoKSB7XG4gICAgbGVmdEhhbmRFbnRyaWVzLnNvcnQoKTtcbiAgICByaWdodEhhbmRFbnRyaWVzLnNvcnQoKTtcbiAgICByZXR1cm4gaXRlcmFibGVFcXVhbChsZWZ0SGFuZEVudHJpZXMsIHJpZ2h0SGFuZEVudHJpZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGxlZnRIYW5kS2V5cy5sZW5ndGggPT09IDAgJiZcbiAgICAgIGxlZnRIYW5kRW50cmllcy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHJpZ2h0SGFuZEtleXMubGVuZ3RoID09PSAwICYmXG4gICAgICByaWdodEhhbmRFbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiFcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSBwcmltaXRpdmUuXG4gKlxuICogVGhpcyBpbnRlbnRpb25hbGx5IHJldHVybnMgdHJ1ZSBmb3IgYWxsIG9iamVjdHMgdGhhdCBjYW4gYmUgY29tcGFyZWQgYnkgcmVmZXJlbmNlLFxuICogaW5jbHVkaW5nIGZ1bmN0aW9ucyBhbmQgc3ltYm9scy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBkZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxbCcpXG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0JylcblxudmFyIERFRkFVTFRfVE9MRVJBTkNFID0gMWUtNlxuXG4vKipcbiAqIHNtYWxsIHV0aWxpdHkgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyICh2YWwpIHtcbiAgcmV0dXJuIHR5cGUodmFsKSA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gYm90aE51bWJlcnMgKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBpc051bWJlcihyaWdodCkgJiYgaXNOdW1iZXIobGVmdClcbn1cblxuZnVuY3Rpb24gYWxtb3N0RXF1YWwgKGxlZnQsIHJpZ2h0LCB0b2wpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGxlZnQgLSByaWdodCkgPD0gdG9sXG59XG5cbi8qKlxuICogTWFrZXMgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byBkZWVwRXF1YWwuXG4gKiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gd2lsbCByZXR1cm4gbnVsbCBpZiBib3RoIGFyZ3VtZW50cyBhcmUgbm90IG51bWJlcnMsXG4gKiBpbmRpY2F0aW5nIHRoYXQgZGVlcEVxdWFsIHNob3VsZCBwcm9jZWVkIHdpdGggb3RoZXIgZXF1YWxpdHkgY2hlY2tzXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmF0b3IgKHRvbGVyYW5jZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGJvdGhOdW1iZXJzKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgcmV0dXJuIGFsbW9zdEVxdWFsKGxlZnQsIHJpZ2h0LCB0b2xlcmFuY2UpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIGdsb2JhbCB0b2xlcmFuY2UgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gY2hhaS51c2VcbiAqIEBzZWUgaHR0cDovL2NoYWlqcy5jb20vZ3VpZGUvcGx1Z2lucy9cbiAqL1xuZnVuY3Rpb24gY2hhaUFsbW9zdCAoY3VzdG9tVG9sZXJhbmNlKSB7XG4gIHZhciBzdGFuZGFyZFRvbGVyYW5jZSA9IGN1c3RvbVRvbGVyYW5jZSB8fCBERUZBVUxUX1RPTEVSQU5DRVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY2hhaSwgdXRpbHMpIHtcbiAgICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb25cbiAgICB2YXIgZmxhZyA9IHV0aWxzLmZsYWdcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgc2hhbGxvdyBlcXVhbGl0eSBmdW5jdGlvbiB0byBvdmVycmlkZVxuICAgICAqIC5lcXVhbCwgLmVxdWFscywgLmVxIHRoYXQgdGVzdHMgJ2FsbW9zdCcgZXF1YWxpdHlcbiAgICAgKiBpZiBib3RoIHZhbHVlcyBhcmUgbnVtYmVycyBhbmQgYSAndG9sZXJhbmNlJyBmbGFnIGlzIHNldC5cbiAgICAgKiBTZW5kcyB0byBkZWVwIGVxdWFsaXR5IGNoZWNrIGlmIGRlZXAgZmxhZyBpcyBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVycmlkZUFzc2VydEVxdWFsIChfc3VwZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBhc3NlcnRFcXVhbCAodmFsLCBtc2cpIHtcbiAgICAgICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZylcblxuICAgICAgICB2YXIgZGVlcCA9IGZsYWcodGhpcywgJ2RlZXAnKVxuICAgICAgICB2YXIgdG9sZXJhbmNlID0gZmxhZyh0aGlzLCAndG9sZXJhbmNlJylcblxuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVxbCh2YWwpXG4gICAgICAgIH0gZWxzZSBpZiAodG9sZXJhbmNlICYmIGJvdGhOdW1iZXJzKHZhbCwgdGhpcy5fb2JqKSkge1xuICAgICAgICAgIHRoaXMuYXNzZXJ0KGFsbW9zdEVxdWFsKHZhbCwgdGhpcy5fb2JqLCB0b2xlcmFuY2UpLFxuICAgICAgICAgICAgJ2V4cGVjdGVkICN7dGhpc30gdG8gYWxtb3N0IGVxdWFsICN7ZXhwfScsXG4gICAgICAgICAgICAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYWxtb3N0IGVxdWFsICN7ZXhwfScsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICB0aGlzLl9vYmosXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBkZWVwIGVxdWFsaXR5IGZ1bmN0aW9uIHRvIG92ZXJyaWRlXG4gICAgICogLmVxbCwgLmVxbHMgdGhhdCB0ZXN0cyAnYWxtb3N0JyBlcXVhbGl0eSBpZiBib3RoIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZXMgYXJlIG51bWJlcnMgYW5kIHRvbGVyYW5jZSBmbGFnIGlzIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG92ZXJyaWRlQXNzZXJ0RXFsIChfc3VwZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBhc3NlcnRFcWwgKHZhbCwgbXNnKSB7XG4gICAgICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpXG5cbiAgICAgICAgdmFyIHRvbGVyYW5jZSA9IGZsYWcodGhpcywgJ3RvbGVyYW5jZScpXG5cbiAgICAgICAgaWYgKHRvbGVyYW5jZSkge1xuICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgZGVlcEVxdWFsKHZhbCwgdGhpcy5fb2JqLCB7IGNvbXBhcmF0b3I6IGNvbXBhcmF0b3IodG9sZXJhbmNlKSB9KSxcbiAgICAgICAgICAgICdleHBlY3RlZCAje3RoaXN9IHRvIGRlZXBseSBhbG1vc3QgZXF1YWwgI3tleHB9JyxcbiAgICAgICAgICAgICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBkZWVwbHkgYWxtb3N0IGVxdWFsICN7ZXhwfScsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICB0aGlzLl9vYmosXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogLmFsbW9zdCgpIG1ldGhvZC4gVG8gYmUgdXNlZCBhdCB0aGUgZW5kIG9mIHRoZSBjaGFpbiBsaWtlOlxuICAgICAqIGV4cGVjdCg0KS50by5ub3QuYmUuYWxtb3N0KDUsIDEuNSkuIFNpbXBseSBhZGRzIHRvbGVyYW5jZSBmbGFnIHRoZW4gY2FsbHNcbiAgICAgKiAuZXF1YWwuIFRoaXMgd2lsbCByZWRpcmVjdCB0byAuZXFsIGlmIGRlZXAgZmxhZyBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXRob2QgKHZhbCwgdG9sZXJhbmNlT3ZlcnJpZGUpIHtcbiAgICAgIHZhciB0b2xlcmFuY2UgPSB0b2xlcmFuY2VPdmVycmlkZSB8fCBzdGFuZGFyZFRvbGVyYW5jZVxuXG4gICAgICBmbGFnKHRoaXMsICd0b2xlcmFuY2UnLCB0b2xlcmFuY2UpXG5cbiAgICAgIHJldHVybiB0aGlzLmVxdWFsKHZhbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAuYWxtb3N0IGNoYWluYWJsZSBwcm9wZXJ0eSB0byBiZSB1c2VkIGxpa2U6XG4gICAgICogZXhwZWN0KDMuOTk5OTk5OTkpLnRvLmFsbW9zdC5lcXVhbCg0KS4gU2ltcGx5IGFkZHNcbiAgICAgKiB0b2xlcmFuY2UgZmxhZyB0byBiZSByZWFkIGJ5IGVxdWFsaXR5IGNoZWNraW5nIG1ldGhvZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbmluZ0JlaGF2aW9yICgpIHtcbiAgICAgIGZsYWcodGhpcywgJ3RvbGVyYW5jZScsIHN0YW5kYXJkVG9sZXJhbmNlKVxuICAgIH1cblxuICAgIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2FsbW9zdCcsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcilcblxuICAgIEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2VxdWFsJywgb3ZlcnJpZGVBc3NlcnRFcXVhbClcbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcXVhbHMnLCBvdmVycmlkZUFzc2VydEVxdWFsKVxuICAgIEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2VxJywgb3ZlcnJpZGVBc3NlcnRFcXVhbClcblxuICAgIEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2VxbCcsIG92ZXJyaWRlQXNzZXJ0RXFsKVxuICAgIEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2VxbHMnLCBvdmVycmlkZUFzc2VydEVxbClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoYWlBbG1vc3RcbiIsImltcG9ydCB7XG5cdElNUE9SVEFOVCxcblx0UkVHRVhfS0VCQUIsXG5cdFJFR0VYX1NQQUNFLFxuXHRSRUdFWF9ESUdJVFMsXG5cdFJFR0VYX0xFTl9WQUwsXG5cdFBPU1NJQkxFX1BSRUZJWEVTLFxuXHRSRVFVSVJFU19VTklUX1ZBTFVFXG59IGZyb20gJy4uL3NyYy9jb25zdGFudHMnXG5pbXBvcnQgcXVpY2tjc3MgZnJvbSAnLi4vYnVpbGQvcXVpY2tjc3MuZXNtLmpzJ1xuaW1wb3J0IGNoYWkgZnJvbSAnY2hhaSdcbmltcG9ydCBjaGFpQWxtb3N0IGZyb20gJ2NoYWktYWxtb3N0J1xuY2hhaS51c2UoY2hhaUFsbW9zdClcbm1vY2hhLnNldHVwKCd0ZGQnKVxubW9jaGEuc2xvdyg0MDApXG5tb2NoYS50aW1lb3V0KDEyMDAwKVxubW9jaGEuYmFpbCgpIHVubGVzcyB3aW5kb3cuX19rYXJtYV9fXG5leHBlY3QgPSBjaGFpLmV4cGVjdFxuZGl2cyA9ICQoKCc8ZGl2IC8+JyBmb3IgaSBpbiBbMS4uM10pLmpvaW4gJycpLmFwcGVuZFRvKCdib2R5JylcbnN0eWxlcyA9IGRpdnMudG9BcnJheSgpLm1hcCAoZGl2KS0+IGdldENvbXB1dGVkU3R5bGUoZGl2KVxuXG5yZXNldERpdnMgPSAoKS0+XG5cdGZvciBkaXYgaW4gZGl2c1xuXHRcdGRpdi5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcblx0XHRjb250aW51ZSBpZiBhcmd1bWVudHNbMF0gaXMgdHJ1ZVxuXHRcdGRpdi5zdHlsZS53aWR0aCA9ICc0MHB4J1xuXHRcdGRpdi5zdHlsZS5oZWlnaHQgPSAnNDBweCdcblx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2JsdWUnXG5cdHJldHVyblxuXG5cbnN1aXRlIFwiUXVpY2tDc3NcIiwgKCktPlxuXHRzZXR1cChyZXNldERpdnMpXG5cdHN1aXRlVGVhcmRvd24ocmVzZXREaXZzKVxuXG5cdHRlc3QgXCJBcHBseSBCYXNpYyBTdHlsZXNcIiwgKCktPlxuXHRcdHF1aWNrY3NzKGRpdnNbMF0sICd3aWR0aCcsICcxMHB4Jylcblx0XHRleHBlY3Qoc3R5bGVzWzBdLndpZHRoKS50by5lcXVhbCAnMTBweCdcblx0XHRcblx0XHRxdWlja2NzcyhkaXZzWzFdLCAnd2lkdGgnLCAnNTB2dycpXG5cdFx0ZXhwZWN0KGRpdnNbMV0uc3R5bGUud2lkdGgpLnRvLmVxdWFsICc1MHZ3J1xuXHRcdGV4cGVjdChNYXRoLnJvdW5kIHBhcnNlRmxvYXQoc3R5bGVzWzBdLndpZHRoKSkubm90LnRvLmVxdWFsIDQwXG5cblxuXHR0ZXN0IFwiU3VmZml4IHVuaXQtbGVzcyB2YWx1ZXMgZm9yIGxlbmd0aCBwcm9wZXJ0aWVzXCIsICgpLT5cblx0XHRxdWlja2NzcyhkaXZzWzBdLCAnd2lkdGgnLCAnMTAnKVxuXHRcdHF1aWNrY3NzKGRpdnNbMV0sICd3aWR0aCcsIDEwKVxuXHRcdHF1aWNrY3NzKGRpdnNbMl0sICd3aWR0aCcsICcxMCUnKVxuXHRcdGV4cGVjdChkaXZzWzBdLnN0eWxlLndpZHRoKS50by5lcXVhbCAnMTBweCdcblx0XHRleHBlY3QoZGl2c1sxXS5zdHlsZS53aWR0aCkudG8uZXF1YWwgJzEwcHgnXG5cdFx0ZXhwZWN0KGRpdnNbMl0uc3R5bGUud2lkdGgpLnRvLmVxdWFsICcxMCUnXG5cdFx0ZXhwZWN0KHN0eWxlc1swXS53aWR0aCkudG8uZXF1YWwgJzEwcHgnXG5cdFx0ZXhwZWN0KHN0eWxlc1sxXS53aWR0aCkudG8uZXF1YWwgJzEwcHgnXG5cdFx0ZXhwZWN0KE1hdGgucm91bmQgcGFyc2VGbG9hdChzdHlsZXNbMl0ud2lkdGgpKS5ub3QudG8uZXF1YWwgNDBcblx0XHRcblx0XHRxdWlja2NzcyhkaXZzWzBdLCAnbWFyZ2luVG9wJywgJzEwJylcblx0XHRxdWlja2NzcyhkaXZzWzFdLCAnbWFyZ2luVG9wJywgMTApXG5cdFx0cXVpY2tjc3MoZGl2c1syXSwgJ21hcmdpblRvcCcsICcxMCUnKVxuXHRcdGV4cGVjdChkaXZzWzBdLnN0eWxlLm1hcmdpblRvcCkudG8uZXF1YWwgJzEwcHgnXG5cdFx0ZXhwZWN0KGRpdnNbMV0uc3R5bGUubWFyZ2luVG9wKS50by5lcXVhbCAnMTBweCdcblx0XHRleHBlY3QoZGl2c1syXS5zdHlsZS5tYXJnaW5Ub3ApLnRvLmVxdWFsICcxMCUnXG5cdFx0XG5cdFx0cXVpY2tjc3MoZGl2c1swXSwgJ2ZvbnRTaXplJywgJzEwJylcblx0XHRxdWlja2NzcyhkaXZzWzFdLCAnZm9udFNpemUnLCAxMClcblx0XHRxdWlja2NzcyhkaXZzWzJdLCAnZm9udFNpemUnLCAnMTAlJylcblx0XHRleHBlY3QoZGl2c1swXS5zdHlsZS5mb250U2l6ZSkudG8uZXF1YWwgJzEwcHgnXG5cdFx0ZXhwZWN0KGRpdnNbMV0uc3R5bGUuZm9udFNpemUpLnRvLmVxdWFsICcxMHB4J1xuXHRcdGV4cGVjdChkaXZzWzJdLnN0eWxlLmZvbnRTaXplKS50by5lcXVhbCAnMTAlJ1xuXHRcdFxuXHRcdHF1aWNrY3NzKGRpdnNbMF0sICdsaW5lSGVpZ2h0JywgJzEwJylcblx0XHRxdWlja2NzcyhkaXZzWzFdLCAnbGluZUhlaWdodCcsIDEwKVxuXHRcdHF1aWNrY3NzKGRpdnNbMl0sICdsaW5lSGVpZ2h0JywgJzEwJScpXG5cdFx0ZXhwZWN0KGRpdnNbMF0uc3R5bGUubGluZUhlaWdodCkudG8uZXF1YWwgJzEwZW0nXG5cdFx0ZXhwZWN0KGRpdnNbMV0uc3R5bGUubGluZUhlaWdodCkudG8uZXF1YWwgJzEwZW0nXG5cdFx0ZXhwZWN0KGRpdnNbMl0uc3R5bGUubGluZUhlaWdodCkudG8uZXF1YWwgJzEwJSdcblx0XG5cblx0dGVzdCBcIlN1ZmZpeCB3b24ndCBiZSBhZGRlZCBmb3IgdW5pdC1sZXNzIHZhbHVlcyBvbiBub24tbGVuZ3RoIHByb3BlcnRpZXNcIiwgKCktPlxuXHRcdHF1aWNrY3NzKGRpdnNbMF0sICd3aWR0aCcsICdhdXRvJylcblx0XHRleHBlY3QoZGl2c1swXS5zdHlsZS53aWR0aCkudG8uZXF1YWwgJ2F1dG8nXG5cdFx0ZXhwZWN0KE1hdGgucm91bmQgcGFyc2VGbG9hdChzdHlsZXNbMF0ud2lkdGgpKS5ub3QudG8uZXF1YWwgNDBcblx0XHRcblx0XHRxdWlja2NzcyhkaXZzWzFdLCAnb3BhY2l0eScsIC41KVxuXHRcdGV4cGVjdChkaXZzWzFdLnN0eWxlLm9wYWNpdHkpLnRvLmVxdWFsICcwLjUnXG5cdFx0ZXhwZWN0KHN0eWxlc1sxXS5vcGFjaXR5KS50by5lcXVhbCAnMC41J1xuXG5cblx0dGVzdCBcIkFuIGl0ZXJhYmxlIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMgY2FuIGJlIHBhc3NlZFwiLCAoKS0+XG5cdFx0cXVpY2tjc3MgZGl2cywgJ3dpZHRoJywgMTVcblx0XHRleHBlY3QoZGl2c1swXS5zdHlsZS53aWR0aCkudG8uZXF1YWwgJzE1cHgnXG5cdFx0ZXhwZWN0KGRpdnNbMV0uc3R5bGUud2lkdGgpLnRvLmVxdWFsICcxNXB4J1xuXHRcdGV4cGVjdChkaXZzWzJdLnN0eWxlLndpZHRoKS50by5lcXVhbCAnMTVweCdcblxuXG5cdHRlc3QgXCJBIHN0eWxlIG9iamVjdCBjYW4gYmUgcGFzc2VkXCIsICgpLT5cblx0XHRxdWlja2NzcyBkaXZzWzBdLFxuXHRcdFx0J3Bvc2l0aW9uJzogJ2ZpeGVkJ1xuXHRcdFx0J3dpZHRoJzogJzU1J1xuXHRcdFx0J2hlaWdodCc6IDEyXG5cdFx0XHQnb3BhY2l0eSc6IDAuOFxuXG5cdFx0ZXhwZWN0KGRpdnNbMF0uc3R5bGUucG9zaXRpb24pLnRvLmVxdWFsICdmaXhlZCdcblx0XHRleHBlY3QoZGl2c1swXS5zdHlsZS53aWR0aCkudG8uZXF1YWwgJzU1cHgnXG5cdFx0ZXhwZWN0KGRpdnNbMF0uc3R5bGUuaGVpZ2h0KS50by5lcXVhbCAnMTJweCdcblx0XHRleHBlY3QoZGl2c1swXS5zdHlsZS5vcGFjaXR5KS50by5lcXVhbCAnMC44J1xuXG5cblx0dGVzdCBcIkFuIGl0ZXJhYmxlIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMgY2FuIGJlIHBhc3NlZCBhbG9uZyB3aXRoIGEgc3R5bGUgb2JqZWN0XCIsICgpLT5cblx0XHRxdWlja2NzcyBkaXZzLCB7d2lkdGg6JzMycHgnLCBoZWlnaHQ6Jzk5cHgnfVxuXHRcblx0XHRleHBlY3QoZGl2c1swXS5zdHlsZS53aWR0aCkudG8uZXF1YWwgJzMycHgnXG5cdFx0ZXhwZWN0KGRpdnNbMV0uc3R5bGUud2lkdGgpLnRvLmVxdWFsICczMnB4J1xuXHRcdGV4cGVjdChkaXZzWzJdLnN0eWxlLndpZHRoKS50by5lcXVhbCAnMzJweCdcblx0XHRleHBlY3QoZGl2c1swXS5zdHlsZS5oZWlnaHQpLnRvLmVxdWFsICc5OXB4J1xuXHRcdGV4cGVjdChkaXZzWzFdLnN0eWxlLmhlaWdodCkudG8uZXF1YWwgJzk5cHgnXG5cdFx0ZXhwZWN0KGRpdnNbMl0uc3R5bGUuaGVpZ2h0KS50by5lcXVhbCAnOTlweCdcblxuXG5cdHRlc3QgXCJLZWJhYi1jYXNlZC9jYW1lbC1jYXNlZCBwcm9wZXJ0aWVzIHdpbGwgYmUgbm9ybWFsaXplZFwiLCAoKS0+XG5cdFx0cXVpY2tjc3MgZGl2c1swXSwgJ21hcmdpbi10b3AnLCAnMTBweCdcblx0XHRleHBlY3QoZGl2c1swXS5zdHlsZS5tYXJnaW5Ub3ApLnRvLmVxdWFsICcxMHB4J1xuXHRcdGV4cGVjdChzdHlsZXNbMF0ubWFyZ2luVG9wKS50by5lcXVhbCAnMTBweCdcblxuXHRcdHF1aWNrY3NzIGRpdnNbMF0sICdtYXJnaW5Cb3R0b20nLCAnMTJweCdcblx0XHRleHBlY3QoZGl2c1swXS5zdHlsZS5tYXJnaW5Cb3R0b20pLnRvLmVxdWFsICcxMnB4J1xuXHRcdGV4cGVjdChzdHlsZXNbMF0ubWFyZ2luQm90dG9tKS50by5lcXVhbCAnMTJweCdcblxuXG5cblx0dGVzdCBcIkludmFsaWQgcHJvcGVydGllcyB3aWxsIGJlIGlnbm9yZWRcIiwgKCktPlxuXHRcdHF1aWNrY3NzIGRpdnNbMV0sICd0b3BNYXJnaW4nLCAnMjVweCdcblxuXHRcdGV4cGVjdChkaXZzWzBdLnN0eWxlLnRvcE1hcmdpbikubm90LnRvLmV4aXN0XG5cdFx0ZXhwZWN0KHN0eWxlc1swXS50b3BNYXJnaW4pLm5vdC50by5leGlzdFxuXG5cblx0dGVzdCBcIklmIGEgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGUgY3VycmVudCBjb21wdXRlZCB2YWx1ZSBmb3IgdGhlIHNlbGVjdGVkIHByb3BlcnR5IHdpbGwgYmUgcmV0dXJuZWRcIiwgKCktPlxuXHRcdHF1aWNrY3NzIGRpdnNbMl0sICdtYXJnaW5Ub3AnLCAnNXZoJ1xuXHRcdGNvbXB1dGVkVmFsdWUgPSBzdHlsZXNbMl0ubWFyZ2luVG9wXG5cdFx0XG5cdFx0ZXhwZWN0KHF1aWNrY3NzIGRpdnNbMl0sICdtYXJnaW5Ub3AnLCAnNXZoJykudG8uZXF1YWwodW5kZWZpbmVkKVxuXHRcdGV4cGVjdChxdWlja2NzcyBkaXZzWzJdLCAnbWFyZ2luVG9wJywgJzV2aCcpLnRvLmVxdWFsKHVuZGVmaW5lZClcblx0XHRleHBlY3QocXVpY2tjc3MgZGl2c1syXSwgJ21hcmdpblRvcCcpLnRvLmVxdWFsKHN0eWxlc1syXS5tYXJnaW5Ub3ApXG5cdFx0ZXhwZWN0KHF1aWNrY3NzIGRpdnNbMl0sICd0b3BNYXJnaW4nKS50by5lcXVhbCh1bmRlZmluZWQpXG5cblxuXHR0ZXN0IFwiSWYgYSBudWxsIHZhbHVlIGlzIHByb3ZpZGVkIGZvciBhIHByb3BlcnR5LCB0aGUgcHJvcGVydHkgd2lsbCBiZSBkZWxldGVkXCIsICgpLT5cblx0XHRxdWlja2NzcyBkaXZzWzFdLCAnbWFyZ2luVG9wJywgJzEwcHgnXG5cdFx0ZXhwZWN0KGRpdnNbMV0uc3R5bGUubWFyZ2luVG9wKS50by5lcXVhbCAnMTBweCdcblx0XHRleHBlY3Qoc3R5bGVzWzFdLm1hcmdpblRvcCkudG8uZXF1YWwgJzEwcHgnXG5cdFx0XG5cdFx0cXVpY2tjc3MgZGl2c1sxXSwgJ21hcmdpblRvcCcsIG51bGxcblx0XHRleHBlY3QoZGl2c1sxXS5zdHlsZS5tYXJnaW5Ub3ApLnRvLmVxdWFsICcnXG5cdFx0ZXhwZWN0KHN0eWxlc1sxXS5tYXJnaW5Ub3ApLnRvLmVxdWFsICcwcHgnXG5cblx0XHRxdWlja2NzcyBkaXZzWzFdLCAnbWFyZ2luVG9wJywgJzEwcHgnXG5cdFx0ZXhwZWN0KGRpdnNbMV0uc3R5bGUubWFyZ2luVG9wKS50by5lcXVhbCAnMTBweCdcblx0XHRleHBlY3Qoc3R5bGVzWzFdLm1hcmdpblRvcCkudG8uZXF1YWwgJzEwcHgnXG5cdFx0XG5cdFx0cXVpY2tjc3MgZGl2c1sxXSwgeydtYXJnaW5Ub3AnOiBudWxsfVxuXHRcdGV4cGVjdChkaXZzWzFdLnN0eWxlLm1hcmdpblRvcCkudG8uZXF1YWwgJydcblx0XHRleHBlY3Qoc3R5bGVzWzFdLm1hcmdpblRvcCkudG8uZXF1YWwgJzBweCdcblxuXG5cdHRlc3QgXCIhaW1wb3J0YW50IGZsYWcgd2lsbCBiZSBzZXQgd2hlbiB0cnV0aHkgdmFsdWUgd2lsbCBiZSBwYXNzZWQgYXMgdGhlIDR0aCBhcmd1bWVudCB0byBRdWlja0Nzc1wiLCAoKS0+XG5cdFx0cmVzZXREaXZzKHRydWUpXG5cdFx0ZXhwZWN0KGRpdnNbMF0uZ2V0QXR0cmlidXRlICdzdHlsZScpLnRvLm9uZU9mIFsnJywgbnVsbF1cblxuXHRcdHF1aWNrY3NzKGRpdnNbMF0sICd3aWR0aCcsICc1MHB4Jylcblx0XHRleHBlY3QoZGl2c1swXS5nZXRBdHRyaWJ1dGUgJ3N0eWxlJykudG8uaW5jbHVkZSAnNTBweCdcblx0XHRleHBlY3QoZGl2c1swXS5nZXRBdHRyaWJ1dGUgJ3N0eWxlJykubm90LnRvLmluY2x1ZGUgJzUwcHggIWltcG9ydGFudCdcblx0XHRcblx0XHRxdWlja2NzcyhkaXZzWzBdLCAnd2lkdGgnLCAnNTBweCcsIHRydWUpXG5cdFx0ZXhwZWN0KGRpdnNbMF0uZ2V0QXR0cmlidXRlICdzdHlsZScpLnRvLmluY2x1ZGUgJzUwcHggIWltcG9ydGFudCdcblx0XHRcblx0XHRxdWlja2NzcyhkaXZzWzBdLCAnaGVpZ2h0JywgJzc1cHgnLCB0cnVlKVxuXHRcdGV4cGVjdChkaXZzWzBdLmdldEF0dHJpYnV0ZSAnc3R5bGUnKS50by5pbmNsdWRlICc3NXB4ICFpbXBvcnRhbnQnXG5cdFx0XG5cdFx0cXVpY2tjc3MoZGl2c1swXSwgJ2hlaWdodCcsICc3NXB4Jylcblx0XHQjIGV4cGVjdChkaXZzWzBdLmdldEF0dHJpYnV0ZSAnc3R5bGUnKS5ub3QudG8uaW5jbHVkZSAnNzVweCAhaW1wb3J0YW50J1xuXG5cblx0dGVzdCBcInF1aWNrY3NzLnN1cHBvcnRzICYgcXVpY2tjc3Muc3VwcG9ydHNQcm9wZXJ0eVwiLCAoKS0+XG5cdFx0ZXhwZWN0KHR5cGVvZiBxdWlja2Nzcy5zdXBwb3J0cykudG8uZXF1YWwgJ2Z1bmN0aW9uJ1xuXHRcdGV4cGVjdCh0eXBlb2YgcXVpY2tjc3Muc3VwcG9ydHNQcm9wZXJ0eSkudG8uZXF1YWwgJ2Z1bmN0aW9uJ1xuXHRcdGV4cGVjdChxdWlja2Nzcy5zdXBwb3J0cygnZGlzcGxheScsJ2lubGluZScpKS50by5iZS50cnVlXG5cdFx0ZXhwZWN0KHF1aWNrY3NzLnN1cHBvcnRzKCdkaXNwbGF5JywnYmxvY2snKSkudG8uYmUudHJ1ZVxuXHRcdGV4cGVjdChxdWlja2Nzcy5zdXBwb3J0cygnZGlzcGxheScsJ2Jsb2NrbCcpKS50by5iZS5mYWxzZVxuXHRcdGV4cGVjdChxdWlja2Nzcy5zdXBwb3J0cygnZGlzcGxheScsJycpKS50by5iZS5mYWxzZVxuXHRcdGV4cGVjdChxdWlja2Nzcy5zdXBwb3J0cygnZGlzcGxheScsbnVsbCkpLnRvLmJlLmZhbHNlXG5cdFx0ZXhwZWN0KHF1aWNrY3NzLnN1cHBvcnRzKCdvcGFjaXR5JywnMC41JykpLnRvLmJlLnRydWVcblx0XHRleHBlY3QocXVpY2tjc3Muc3VwcG9ydHMoJ29wYWNpdHknLDAuNSkpLnRvLmJlLnRydWVcblx0XHRleHBlY3QocXVpY2tjc3Muc3VwcG9ydHNQcm9wZXJ0eSgnb3BhY2l0eScpKS50by5iZS50cnVlXG5cdFx0ZXhwZWN0KHF1aWNrY3NzLnN1cHBvcnRzUHJvcGVydHkoJ29wYWNpdHl5JykpLnRvLmJlLmZhbHNlXG5cblxuXG5cdHN1aXRlIFwiYW5pbWF0aW9uXCIsICgpLT5cblx0XHR0ZXN0IFwiLmFuaW1hdGlvbihuYW1lLCBrZXlmcmFtZXMpIHdpbGwgY3JlYXRlIGEgQGtleWZyYW1lcyBydWxlXCIsICgpLT5cblx0XHRcdGxhc3RFbCA9ICQoZG9jdW1lbnQuaGVhZCkuY2hpbGRyZW4oKS5sYXN0KClbMF1cblx0XHRcdGV4cGVjdChsYXN0RWwuaWQpLm5vdC50by5lcXVhbCAncXVpY2tjc3MnXG5cblx0XHRcdHF1aWNrY3NzLmFuaW1hdGlvbiAnbXlBbmltYXRpb24nLFxuXHRcdFx0XHQnMCUnOlxuXHRcdFx0XHRcdHRyYW5zZm9ybTogJ3JvdGF0ZSgwZGVnKSdcblx0XHRcdFx0XHRvcGFjaXR5OiAxXG5cdFx0XHRcdFx0d2lkdGg6IDEwMFxuXHRcdFx0XHRcdG1hcmdpblRvcDogNVxuXHRcdFx0XHQnNTAlJzpcblx0XHRcdFx0XHR3aWR0aDogMTUwXG5cdFx0XHRcdCcxMDAlJzpcblx0XHRcdFx0XHR0cmFuc2Zvcm06ICdyb3RhdGUoMzYwZGVnKSdcblx0XHRcdFx0XHRvcGFjaXR5OiAwLjVcblx0XHRcdFx0XHR3aWR0aDogNTBcblx0XHRcdFxuXHRcdFx0bGFzdEVsID0gJChkb2N1bWVudC5oZWFkKS5jaGlsZHJlbigpLmxhc3QoKVswXVxuXHRcdFx0ZXhwZWN0KGxhc3RFbC5pZCkudG8uZXF1YWwgJ3F1aWNrY3NzJ1xuXHRcdFx0ZXhwZWN0KGxhc3RFbC5pbm5lckhUTUwpLnRvLmluY2x1ZGUgJ2tleWZyYW1lcyBteUFuaW1hdGlvbiB7J1xuXHRcdFx0ZXhwZWN0KGxhc3RFbC5pbm5lckhUTUwpLnRvLmluY2x1ZGUgJzAlIHsnXG5cdFx0XHRleHBlY3QobGFzdEVsLmlubmVySFRNTCkudG8uaW5jbHVkZSAndHJhbnNmb3JtOnJvdGF0ZSgwZGVnKSdcblx0XHRcdGV4cGVjdChsYXN0RWwuaW5uZXJIVE1MKS50by5pbmNsdWRlICdvcGFjaXR5OjEnXG5cdFx0XHRleHBlY3QobGFzdEVsLmlubmVySFRNTCkudG8uaW5jbHVkZSAnd2lkdGg6MTAwcHgnXG5cdFx0XHRleHBlY3QobGFzdEVsLmlubmVySFRNTCkudG8uaW5jbHVkZSAnbWFyZ2luLXRvcDo1cHgnXG5cdFx0XHRleHBlY3QobGFzdEVsLmlubmVySFRNTCkudG8uaW5jbHVkZSAnNTAlIHsnXG5cdFx0XHRleHBlY3QobGFzdEVsLmlubmVySFRNTCkudG8uaW5jbHVkZSAnd2lkdGg6MTUwcHgnXG5cdFx0XHRleHBlY3QobGFzdEVsLmlubmVySFRNTCkudG8uaW5jbHVkZSAnMTAwJSB7J1xuXHRcdFx0ZXhwZWN0KGxhc3RFbC5pbm5lckhUTUwpLnRvLmluY2x1ZGUgJ3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKSdcblx0XHRcdGV4cGVjdChsYXN0RWwuaW5uZXJIVE1MKS50by5pbmNsdWRlICdvcGFjaXR5OjAuNSdcblx0XHRcdGV4cGVjdChsYXN0RWwuaW5uZXJIVE1MKS50by5pbmNsdWRlICd3aWR0aDo1MHB4J1xuXHRcdFxuXG5cdFx0dGVzdCBcImNhbGxpbmcgLmFuaW1hdGlvbigpIHdpdGggdGhlIHNhbWUgYXJncyBtdWx0aXBsZSB0aW1lcyBzaG91bGQgb25seSBpbnNlcnQgdGhlIGtleWZyYW1lcyBvbmNlXCIsICgpLT5cblx0XHRcdGFuaW1hdGlvbiA9XG5cdFx0XHRcdCcwJSc6XG5cdFx0XHRcdFx0dHJhbnNmb3JtOiAncm90YXRlKDBkZWcpJ1xuXHRcdFx0XHQnMTAwJSc6XG5cdFx0XHRcdFx0dHJhbnNmb3JtOiAncm90YXRlKDM2MGRlZyknXG5cdFx0XHRcblx0XHRcdHF1aWNrY3NzLmFuaW1hdGlvbiAnc29tZUFuaW1hdGlvbicsIGFuaW1hdGlvblxuXHRcdFx0bGFzdEVsID0gJChkb2N1bWVudC5oZWFkKS5jaGlsZHJlbigpLmxhc3QoKVswXVxuXHRcdFx0ZXhwZWN0KGxhc3RFbC5pbm5lckhUTUwpLnRvLmluY2x1ZGUgJ2tleWZyYW1lcyBzb21lQW5pbWF0aW9uIHsnXG5cdFx0XHRleHBlY3QobGFzdEVsLmlubmVySFRNTC5tYXRjaCgvc29tZUFuaW1hdGlvbi9nKT8ubGVuZ3RoKS50by5lcXVhbCAxXG5cdFx0XHRcblx0XHRcdHF1aWNrY3NzLmFuaW1hdGlvbiAnc29tZUFuaW1hdGlvbicsIGFuaW1hdGlvblxuXHRcdFx0ZXhwZWN0KGxhc3RFbC5pbm5lckhUTUwubWF0Y2goL3NvbWVBbmltYXRpb24vZyk/Lmxlbmd0aCkudG8uZXF1YWwgMVxuXHRcdFx0XG5cdFx0XHRxdWlja2Nzcy5hbmltYXRpb24gJ3NvbWVBbmltYXRpb24yJywgYW5pbWF0aW9uXG5cdFx0XHRleHBlY3QobGFzdEVsLmlubmVySFRNTC5tYXRjaCgvc29tZUFuaW1hdGlvbi9nKT8ubGVuZ3RoKS50by5lcXVhbCAyXG5cdFx0XHRleHBlY3QobGFzdEVsLmlubmVySFRNTC5tYXRjaCgvc29tZUFuaW1hdGlvbjIvZyk/Lmxlbmd0aCkudG8uZXF1YWwgMVxuXHRcdFx0XG5cdFx0XHRxdWlja2Nzcy5hbmltYXRpb24gJ3NvbWVBbmltYXRpb24yJywgYW5pbWF0aW9uXG5cdFx0XHRleHBlY3QobGFzdEVsLmlubmVySFRNTC5tYXRjaCgvc29tZUFuaW1hdGlvbi9nKT8ubGVuZ3RoKS50by5lcXVhbCAyXG5cdFx0XHRleHBlY3QobGFzdEVsLmlubmVySFRNTC5tYXRjaCgvc29tZUFuaW1hdGlvbjIvZyk/Lmxlbmd0aCkudG8uZXF1YWwgMVxuXHRcdFx0XG5cdFx0XHRxdWlja2Nzcy5hbmltYXRpb24gJ3NvbWVBbmltYXRpb24yJywgeydmcm9tJzp7d2lkdGg6NTB9LCAndG8nOnt3aWR0aDoxMDB9fVxuXHRcdFx0ZXhwZWN0KGxhc3RFbC5pbm5lckhUTUwubWF0Y2goL3NvbWVBbmltYXRpb24vZyk/Lmxlbmd0aCkudG8uZXF1YWwgM1xuXHRcdFx0ZXhwZWN0KGxhc3RFbC5pbm5lckhUTUwubWF0Y2goL3NvbWVBbmltYXRpb24yL2cpPy5sZW5ndGgpLnRvLmVxdWFsIDJcblxuXG5cblx0c3VpdGUgXCJzdHlsZSByZWdpc3RyYXRpb25cIiwgKCktPlxuXHRcdHNldHVwICgpLT4gcmVzZXREaXZzKHRydWUpXG5cblx0XHR0ZXN0IFwiYSBjbGFzc05hbWUgd2lsbCBiZSByZXR1cm5lZCBmcm9tIHF1aWNrY3NzLnJlZ2lzdGVyKCkgZm9yIGEgZ2l2ZW4gcnVsZSBvYmplY3Qgd2hpY2ggY2FuIGJlIGFwcGxpZWQgdG8gZWxlbWVudHNcIiwgKCktPlxuXHRcdFx0Y2xhc3NOYW1lID0gcXVpY2tjc3MucmVnaXN0ZXIge3dpZHRoOicxNTBweCcsICdtYXJnaW4tdG9wJzonMjVweCd9XG5cblx0XHRcdGV4cGVjdCh0eXBlb2YgY2xhc3NOYW1lKS50by5lcXVhbCAnc3RyaW5nJ1xuXHRcdFx0ZXhwZWN0KHF1aWNrY3NzKGRpdnNbMF0sICd3aWR0aCcpKS5ub3QudG8uZXF1YWwgJzE1MHB4J1xuXHRcdFx0ZXhwZWN0KHF1aWNrY3NzKGRpdnNbMF0sICdtYXJnaW5Ub3AnKSkubm90LnRvLmVxdWFsICcyNXB4J1xuXG5cdFx0XHRkaXZzWzBdLmNsYXNzTmFtZSArPSBcIiAje2NsYXNzTmFtZX1cIlxuXHRcdFx0ZXhwZWN0KHF1aWNrY3NzKGRpdnNbMF0sICd3aWR0aCcpKS50by5lcXVhbCAnMTUwcHgnXG5cdFx0XHRleHBlY3QocXVpY2tjc3MoZGl2c1swXSwgJ21hcmdpblRvcCcpKS50by5lcXVhbCAnMjVweCdcblxuXG5cdFx0dGVzdCBcInZhbHVlcyBhbmQgcHJvcGVydGllcyB3aWxsIGJlIG5vcm1hbGl6ZWRcIiwgKCktPlxuXHRcdFx0Y2xhc3NOYW1lID0gcXVpY2tjc3MucmVnaXN0ZXIge3dpZHRoOjEyNSwgaGVpZ2h0OjcwLCB6SW5kZXg6MTIsIG1hcmdpblRvcDoyMCwgZm9udFNpemU6MjAsIHBvc2l0aW9uOiAncmVsYXRpdmUnfVxuXG5cdFx0XHRleHBlY3QocXVpY2tjc3MoZGl2c1swXSwgJ3dpZHRoJykpLm5vdC50by5lcXVhbCAnMTI1cHgnXG5cdFx0XHRleHBlY3QocXVpY2tjc3MoZGl2c1swXSwgJ2hlaWdodCcpKS5ub3QudG8uZXF1YWwgJzcwcHgnXG5cdFx0XHRleHBlY3QocXVpY2tjc3MoZGl2c1swXSwgJ21hcmdpblRvcCcpKS5ub3QudG8uZXF1YWwgJzIwcHgnXG5cdFx0XHRleHBlY3QocXVpY2tjc3MoZGl2c1swXSwgJ2ZvbnRTaXplJykpLm5vdC50by5lcXVhbCAnMjBweCdcblx0XHRcdGV4cGVjdChxdWlja2NzcyhkaXZzWzBdLCAnekluZGV4JykpLm5vdC50by5lcXVhbCAnMTInXG5cblx0XHRcdGRpdnNbMF0uY2xhc3NOYW1lICs9IFwiICN7Y2xhc3NOYW1lfVwiXG5cdFx0XHRleHBlY3QocXVpY2tjc3MoZGl2c1swXSwgJ3dpZHRoJykpLnRvLmVxdWFsICcxMjVweCdcblx0XHRcdGV4cGVjdChxdWlja2NzcyhkaXZzWzBdLCAnaGVpZ2h0JykpLnRvLmVxdWFsICc3MHB4J1xuXHRcdFx0ZXhwZWN0KHF1aWNrY3NzKGRpdnNbMF0sICdtYXJnaW5Ub3AnKSkudG8uZXF1YWwgJzIwcHgnXG5cdFx0XHRleHBlY3QocXVpY2tjc3MoZGl2c1swXSwgJ2ZvbnRTaXplJykpLnRvLmVxdWFsICcyMHB4J1xuXHRcdFx0ZXhwZWN0KHF1aWNrY3NzKGRpdnNbMF0sICd6SW5kZXgnKSkudG8uZXF1YWwgJzEyJ1xuXG5cblx0XHR0ZXN0IFwib25seSB2YWxpZCBwcm9wZXJ0eSB2YWx1ZXMgd2lsbCBiZSByZWdpc3RlcmVkXCIsICgpLT5cblx0XHRcdGNsYXNzTmFtZSA9IHF1aWNrY3NzLnJlZ2lzdGVyIHt3aWR0aDoyMCwgaGVpZ2h0Ont2YWx1ZTonMjBweCd9LCBvcGFjaXR5OjAuNSwgbGluZUhlaWdodDooLT4nMmVtJyksIGZvbnRTaXplOicxMid9XG5cdFx0XHRpbnNlcnRlZCA9IChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcXVpY2tjc3MnKS50ZXh0Q29udGVudCkubWF0Y2gobmV3IFJlZ0V4cCBcIlxcXFwuI3tjbGFzc05hbWV9IHsoLis/KX1cIik/WzFdXG5cblx0XHRcdGV4cGVjdCh0eXBlb2YgaW5zZXJ0ZWQpLnRvLmVxdWFsICdzdHJpbmcnXG5cdFx0XHRleHBlY3QoaW5zZXJ0ZWQpLnRvLmluY2x1ZGUgJ3dpZHRoOjIwcHgnXG5cdFx0XHRleHBlY3QoaW5zZXJ0ZWQpLnRvLmluY2x1ZGUgJ29wYWNpdHk6MC41J1xuXHRcdFx0ZXhwZWN0KGluc2VydGVkKS50by5pbmNsdWRlICdmb250LXNpemU6MTJweCdcblx0XHRcdGV4cGVjdChpbnNlcnRlZCkubm90LnRvLmluY2x1ZGUgJ2hlaWdodCdcblx0XHRcdGV4cGVjdChpbnNlcnRlZCkubm90LnRvLmluY2x1ZGUgJ2xpbmUtaGVpZ2h0J1xuXG5cblx0XHR0ZXN0IFwiYSBydWxlIG9iamVjdCB3aWxsIGJlIG9ubHkgZGVmaW5lZCBvbmNlIGluc2lkZSB0aGUgc3R5bGUgZWxlbWVudFwiLCAoKS0+XG5cdFx0XHRjbGFzc05hbWUxID0gcXVpY2tjc3MucmVnaXN0ZXIge3dpZHRoOjMwLCBoZWlnaHQ6JzUwJ31cblx0XHRcdGNsYXNzTmFtZTIgPSBxdWlja2Nzcy5yZWdpc3RlciB7d2lkdGg6MzAsIGhlaWdodDonNTAnfVxuXHRcdFx0ZXhwZWN0KGNsYXNzTmFtZTEpLnRvLmVxdWFsKGNsYXNzTmFtZTIpXG5cdFx0XHRcblx0XHRcdG1hdGNoID0gKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNxdWlja2NzcycpLnRleHRDb250ZW50KS5tYXRjaChuZXcgUmVnRXhwIFwiI3tjbGFzc05hbWUxfVwiLCAnZycpXG5cdFx0XHRleHBlY3QobWF0Y2gubGVuZ3RoKS50by5lcXVhbCAxXG5cblxuXHRcdHRlc3QgXCJzdHlsZXMgY2FuIGJlIHJlZ2lzdGVyZWQgYXQgZGlmZmVyZW50IGxldmVscyBmb3Igc3BlY2lmaWNpdHkgKGRlZmF1bHQ9MClcIiwgKCktPlxuXHRcdFx0Y2xhc3NOYW1lMSA9IHF1aWNrY3NzLnJlZ2lzdGVyIHt3aWR0aDoxMCwgaGVpZ2h0OjEwfVxuXHRcdFx0Y2xhc3NOYW1lMiA9IHF1aWNrY3NzLnJlZ2lzdGVyIHt3aWR0aDoyMCwgaGVpZ2h0OjIwfVxuXG5cdFx0XHRkaXZzWzBdLmNsYXNzTmFtZSA9IFwiI3tjbGFzc05hbWUxfVwiXG5cdFx0XHRleHBlY3Qoc3R5bGVzWzBdLndpZHRoKS50by5lcXVhbCgnMTBweCcpXG5cdFx0XHRleHBlY3Qoc3R5bGVzWzBdLmhlaWdodCkudG8uZXF1YWwoJzEwcHgnKVxuXHRcdFx0XG5cdFx0XHRkaXZzWzBdLmNsYXNzTmFtZSArPSBcIiAje2NsYXNzTmFtZTJ9XCJcblx0XHRcdGV4cGVjdChzdHlsZXNbMF0ud2lkdGgpLnRvLmVxdWFsKCcyMHB4Jylcblx0XHRcdGV4cGVjdChzdHlsZXNbMF0uaGVpZ2h0KS50by5lcXVhbCgnMjBweCcpXG5cdFx0XHRcblx0XHRcdHF1aWNrY3NzLnJlZ2lzdGVyIHt3aWR0aDoxMCwgaGVpZ2h0OjEwfVxuXHRcdFx0ZXhwZWN0KHN0eWxlc1swXS53aWR0aCkudG8uZXF1YWwoJzIwcHgnKVxuXHRcdFx0ZXhwZWN0KHN0eWxlc1swXS5oZWlnaHQpLnRvLmVxdWFsKCcyMHB4Jylcblx0XHRcdGV4cGVjdChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcXVpY2tjc3MxJykpLnRvLmVxdWFsIG51bGxcblx0XHRcdFxuXHRcdFx0cXVpY2tjc3MucmVnaXN0ZXIge3dpZHRoOjEwLCBoZWlnaHQ6MTB9LCAxXG5cdFx0XHRleHBlY3Qoc3R5bGVzWzBdLndpZHRoKS50by5lcXVhbCgnMTBweCcpXG5cdFx0XHRleHBlY3Qoc3R5bGVzWzBdLmhlaWdodCkudG8uZXF1YWwoJzEwcHgnKVxuXHRcdFx0XG5cdFx0XHRxdWlja2Nzcy5yZWdpc3RlciB7d2lkdGg6MjAsIGhlaWdodDoyMH0sIDVcblx0XHRcdGV4cGVjdChzdHlsZXNbMF0ud2lkdGgpLnRvLmVxdWFsKCcyMHB4Jylcblx0XHRcdGV4cGVjdChzdHlsZXNbMF0uaGVpZ2h0KS50by5lcXVhbCgnMjBweCcpXG5cblx0XHRcdGV4cGVjdChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcXVpY2tjc3MxJykpLm5vdC50by5lcXVhbCBudWxsXG5cdFx0XHRleHBlY3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3F1aWNrY3NzNScpKS5ub3QudG8uZXF1YWwgbnVsbFxuXHRcdFx0ZXhwZWN0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNxdWlja2NzcycpLnRleHRDb250ZW50KS50by5pbmNsdWRlKGNsYXNzTmFtZTEpXG5cdFx0XHRleHBlY3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3F1aWNrY3NzMScpLnRleHRDb250ZW50KS50by5pbmNsdWRlKGNsYXNzTmFtZTEpXG5cdFx0XHRleHBlY3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3F1aWNrY3NzNScpLnRleHRDb250ZW50KS5ub3QudG8uaW5jbHVkZShjbGFzc05hbWUxKVxuXHRcdFx0ZXhwZWN0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNxdWlja2NzcycpLnRleHRDb250ZW50KS50by5pbmNsdWRlKGNsYXNzTmFtZTIpXG5cdFx0XHRleHBlY3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3F1aWNrY3NzMScpLnRleHRDb250ZW50KS5ub3QudG8uaW5jbHVkZShjbGFzc05hbWUyKVxuXHRcdFx0ZXhwZWN0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNxdWlja2NzczUnKS50ZXh0Q29udGVudCkudG8uaW5jbHVkZShjbGFzc05hbWUyKVxuXG5cdFx0XHRxdWlja2Nzcy5yZWdpc3RlciB7d2lkdGg6MTAsIGhlaWdodDoxMH0sIDVcblx0XHRcdGV4cGVjdChzdHlsZXNbMF0ud2lkdGgpLnRvLmVxdWFsKCcxMHB4Jylcblx0XHRcdGV4cGVjdChzdHlsZXNbMF0uaGVpZ2h0KS50by5lcXVhbCgnMTBweCcpXG5cdFx0XHRleHBlY3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3F1aWNrY3NzNScpLnRleHRDb250ZW50KS50by5pbmNsdWRlKGNsYXNzTmFtZTEpXG5cblxuXHRcdHRlc3QgXCJzdHlsZXMgd2lsbCBiZSByZWdpc3RlcmVkIHdpdGggJyFpbXBvcnRhbnQnIGZsYWcgd2hlbiBwYXNzZWQgcXVpY2tjc3MucmVnaXN0ZXIoLi4uLCAuLi4sIHRydWUpXCIsICgpLT5cblx0XHRcdGNsYXNzTmFtZTEgPSBxdWlja2Nzcy5yZWdpc3RlciB7d2lkdGg6MzAsIGhlaWdodDozMH0sIDBcblx0XHRcdGNsYXNzTmFtZTIgPSBxdWlja2Nzcy5yZWdpc3RlciB7d2lkdGg6MzAsIGhlaWdodDozMH0sIDAsIHRydWVcblx0XHRcdGNsYXNzTmFtZTQgPSBxdWlja2Nzcy5yZWdpc3RlciB7d2lkdGg6NTB9LCAxLCB0cnVlXG5cdFx0XHRjbGFzc05hbWU1ID0gcXVpY2tjc3MucmVnaXN0ZXIge2hlaWdodDo1MH0sIDFcblx0XHRcdGNsYXNzTmFtZTMgPSBxdWlja2Nzcy5yZWdpc3RlciB7d2lkdGg6MjUsIGhlaWdodDoyNX0sIDJcblxuXHRcdFx0ZXhwZWN0KGNsYXNzTmFtZTEpLm5vdC50by5lcXVhbChjbGFzc05hbWUyKVxuXHRcdFx0XG5cdFx0XHRkaXZzWzBdLmNsYXNzTmFtZSA9IFwiI3tjbGFzc05hbWUzfSAje2NsYXNzTmFtZTR9ICN7Y2xhc3NOYW1lNX1cIlxuXHRcdFx0ZXhwZWN0KHN0eWxlc1swXS53aWR0aCkudG8uZXF1YWwoJzUwcHgnKVxuXHRcdFx0ZXhwZWN0KHN0eWxlc1swXS5oZWlnaHQpLnRvLmVxdWFsKCcyNXB4JylcblxuXHRcdFx0aW5zZXJ0ZWQgPSAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3F1aWNrY3NzJykudGV4dENvbnRlbnQpLm1hdGNoKG5ldyBSZWdFeHAgXCJcXFxcLiN7Y2xhc3NOYW1lMn0geyguKz8pfVwiKT9bMV1cblx0XHRcdGV4cGVjdChpbnNlcnRlZCkudG8uaW5jbHVkZSAnIWltcG9ydGFudCdcblxuXG5cdFx0dGVzdCBcImNsZWFyaW5nIHJlZ2lzdGVyZWRcIiwgKCktPlxuXHRcdFx0Y2xhc3NOYW1lID0gcXVpY2tjc3MucmVnaXN0ZXIge2E6JzFweCcsIGI6JzJweCd9XG5cdFx0XHRxdWlja2Nzcy5yZWdpc3RlciB7YTonMXB4JywgYjonMnB4J30sIDFcblx0XHRcdGV4cGVjdChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcXVpY2tjc3MnKS50ZXh0Q29udGVudCkudG8uaW5jbHVkZShjbGFzc05hbWUpXG5cdFx0XHRleHBlY3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3F1aWNrY3NzMScpLnRleHRDb250ZW50KS50by5pbmNsdWRlKGNsYXNzTmFtZSlcblx0XHRcdFxuXHRcdFx0cXVpY2tjc3MuY2xlYXJSZWdpc3RlcmVkKClcblx0XHRcdGV4cGVjdChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcXVpY2tjc3MnKS50ZXh0Q29udGVudCkubm90LnRvLmluY2x1ZGUoY2xhc3NOYW1lKVxuXHRcdFx0ZXhwZWN0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNxdWlja2NzczEnKS50ZXh0Q29udGVudCkudG8uaW5jbHVkZShjbGFzc05hbWUpXG5cdFx0XHRcblx0XHRcdHF1aWNrY3NzLnJlZ2lzdGVyIHthOicxcHgnLCBiOicycHgnfVxuXHRcdFx0ZXhwZWN0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNxdWlja2NzcycpLnRleHRDb250ZW50KS50by5pbmNsdWRlKGNsYXNzTmFtZSlcblx0XHRcdGV4cGVjdChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcXVpY2tjc3MxJykudGV4dENvbnRlbnQpLnRvLmluY2x1ZGUoY2xhc3NOYW1lKVxuXHRcdFx0XG5cdFx0XHRxdWlja2Nzcy5jbGVhclJlZ2lzdGVyZWQoMSlcblx0XHRcdGV4cGVjdChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcXVpY2tjc3MnKS50ZXh0Q29udGVudCkudG8uaW5jbHVkZShjbGFzc05hbWUpXG5cdFx0XHRleHBlY3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3F1aWNrY3NzMScpLnRleHRDb250ZW50KS5ub3QudG8uaW5jbHVkZShjbGFzc05hbWUpXG5cblxuXHRcdHN1aXRlIFwidGhlIHJldHVybmVkIGNsYXNzTmFtZSB3aWxsIGJlIHRoZSBzYW1lIChpLmUuIGhhc2hzdW0pXCIsICgpLT5cblx0XHRcdHRlc3QgXCJmb3IgdGhlIHNhbWUgb2JqZWN0XCIsICgpLT5cblx0XHRcdFx0cnVsZSA9IHt3aWR0aDoxMjUsIGhlaWdodDo3MCwgekluZGV4OjEyfVxuXHRcdFx0XHRleHBlY3QocXVpY2tjc3MucmVnaXN0ZXIocnVsZSkpLnRvLmVxdWFsKHF1aWNrY3NzLnJlZ2lzdGVyKHJ1bGUpKVxuXG5cblx0XHRcdHRlc3QgXCJmb3IgZGlmZiBvYmplY3RzIHdpdGggdGhlIHNhbWUgY29uZmlnXCIsICgpLT5cblx0XHRcdFx0ZXhwZWN0KHF1aWNrY3NzLnJlZ2lzdGVyKHt3aWR0aDoxMjUsIGhlaWdodDo3MCwgekluZGV4OjEzfSkpXG5cdFx0XHRcdC50by5lcXVhbChxdWlja2Nzcy5yZWdpc3Rlcih7d2lkdGg6MTI1LCBoZWlnaHQ6NzAsIHpJbmRleDoxM30pKVxuXG5cblx0XHRcdHRlc3QgXCJmb3IgZGlmZiBvYmplY3RzIHdpdGggdGhlIHNhbWUgY29uZmlnIGJ1dCBkaWZmZXJlbnQgbm90YXRpb25zXCIsICgpLT5cblx0XHRcdFx0ZXhwZWN0KHF1aWNrY3NzLnJlZ2lzdGVyKHt3aWR0aDoxMTUsIGhlaWdodDo3MCwgekluZGV4OjE0fSkpXG5cdFx0XHRcdC50by5lcXVhbChxdWlja2Nzcy5yZWdpc3Rlcih7d2lkdGg6JzExNXB4JywgaGVpZ2h0OjcwLCAnei1pbmRleCc6MTR9KSlcblxuXG5cdFx0XHR0ZXN0IFwiZm9yIGRpZmYgb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGNvbmZpZyBidXQgZGlmZmVyZW50IHByb3BlcnR5IG9yZGVyXCIsICgpLT5cblx0XHRcdFx0ZXhwZWN0KHF1aWNrY3NzLnJlZ2lzdGVyKHt3aWR0aDoxMDAsIGhlaWdodDo3MCwgekluZGV4OjE1fSkpXG5cdFx0XHRcdC50by5lcXVhbChxdWlja2Nzcy5yZWdpc3Rlcih7J3otaW5kZXgnOjE1LCB3aWR0aDonMTAwcHgnLCBoZWlnaHQ6NzB9KSlcblx0XHRcdFx0XG5cdFx0XHRcdGV4cGVjdChxdWlja2Nzcy5yZWdpc3Rlcih7d2lkdGg6MTAwLCBoZWlnaHQ6NzAsIHpJbmRleDoxNX0pKS5ub3Rcblx0XHRcdFx0LnRvLmVxdWFsKHF1aWNrY3NzLnJlZ2lzdGVyKHsnei1pbmRleCc6MTUsIHdpZHRoOicxMDBweCcsIGhlaWdodDo3MX0pKVxuXG5cdFx0XHR0ZXN0IFwiZm9yIGRpZmYgb2JqZWN0IHdpdGggdGhlIHNhbWUgY29uZmlnIHdoZW4gc29tZSBwcm9wZXJ0aWVzIGFyZSByZWplY3RlZFwiLCAoKS0+XG5cdFx0XHRcdGV4cGVjdChxdWlja2Nzcy5yZWdpc3RlciB7d2lkdGg6MjAsIGhlaWdodDp7dmFsdWU6JzIwcHgnfSwgb3BhY2l0eTowLjUsIGxpbmVIZWlnaHQ6KC0+JzJlbScpLCBmb250U2l6ZTonMTInfSlcblx0XHRcdFx0LnRvLmVxdWFsKHF1aWNrY3NzLnJlZ2lzdGVyIHt3aWR0aDoyMCwgaGVpZ2h0Ont2YWx1ZTonMjBweCd9LCBvcGFjaXR5OjAuNSwgZm9udFNpemU6JzEyJywgbGluZUhlaWdodDooLT4nMmVtJyl9KVxuXG5cblxuXG5cblxuXG4iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJSRUdFWF9MRU5fVkFMIiwiUkVHRVhfRElHSVRTIiwiUkVHRVhfU1BBQ0UiLCJSRUdFWF9LRUJBQiIsIklNUE9SVEFOVCIsIlBPU1NJQkxFX1BSRUZJWEVTIiwiUkVRVUlSRVNfVU5JVF9WQUxVRSIsIlFVQURfU0hPUlRIQU5EUyIsIkRJUkVDVElPTlMiLCJmb3JFYWNoIiwicHJvcGVydHkiLCJkaXJlY3Rpb24iLCJpIiwibGVuIiwicHVzaCIsImxlbmd0aCIsIlNBTVBMRV9TVFlMRSIsInN0eWxlQ29uZmlnIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJpbmNsdWRlcyIsInRhcmdldCIsIml0ZW0iLCJpbmRleE9mIiwiaXNJdGVyYWJsZSIsIm5vZGVUeXBlIiwidG9LZWJhYkNhc2UiLCJzdHJpbmciLCJyZXBsYWNlIiwiZSIsImxldHRlciIsImNvbmNhdCIsInRvTG93ZXJDYXNlIiwiaXNQcm9wU3VwcG9ydGVkIiwiaXNWYWx1ZVN1cHBvcnRlZCIsInZhbHVlIiwid2luZG93IiwiQ1NTIiwic3VwcG9ydHMiLCJnZXRQcmVmaXgiLCJza2lwSW5pdGlhbENoZWNrIiwiaiIsImxlbjEiLCJwcmVmaXgiLCJub3JtYWxpemVQcm9wZXJ0eSIsIm5vcm1hbGl6ZVZhbHVlIiwidGVzdCIsInNvcnQiLCJhcnJheSIsImdyZWF0IiwibGVzcyIsInBpdm90IiwiaGFzaCIsImhzaCIsImNoYXJDb2RlQXQiLCJydWxlVG9TdHJpbmciLCJydWxlIiwiaW1wb3J0YW50Iiwib3V0cHV0IiwicHJvcCIsInByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImlubGluZVN0eWxlQ29uZmlnIiwiY3JlYXRlIiwiaW5saW5lU3R5bGUiLCJ2YWx1ZVRvU3RvcmUiLCJsZXZlbCIsImNvbmZpZyIsInN0eWxlRWwiLCJpZCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImVsIiwiY29udGVudCIsImNhY2hlIiwidGV4dENvbnRlbnQiLCJjbGVhcklubGluZVN0eWxlIiwia2V5IiwidmVyc2lvbiIsIl9xdWlja2NzcyIsImluZGV4IiwicXVpY2tjc3MiLCJ0YXJnZXRFbCIsImNvbXB1dGVkU3R5bGUiLCJzdWJFbCIsInN1YlByb3BlcnR5Iiwic3ViVmFsdWUiLCJfY29tcHV0ZWRTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJzZXRQcm9wZXJ0eSIsImFuaW1hdGlvbiIsIm5hbWUiLCJmcmFtZXMiLCJmcmFtZSIsImdlbmVyYXRlZCIsInJ1bGVzIiwicmVnaXN0ZXIiLCJjbGFzc05hbWUiLCJyZWYiLCJjbGVhclJlZ2lzdGVyZWQiLCJVTlNFVCIsInN1cHBvcnRzUHJvcGVydHkiLCJleGNsdWRlIiwiZXhjbHVkZXMiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJleGNsdWRlUHJvcHMiLCJyZXMiLCJleHRlbmRFeGNsdWRlIiwiYXJncyIsIkFzc2VydGlvbkVycm9yIiwibWVzc2FnZSIsIl9wcm9wcyIsInNzZiIsImV4dGVuZCIsInNob3dEaWZmIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInN0YWNrIiwidG9KU09OIiwiaGFzUHJvcGVydHkiLCJwYXJzZVBhdGgiLCJwYXRoIiwic3RyIiwicGFydHMiLCJtYXRjaCIsIm1hcCIsIm1hcE1hdGNoZXMiLCJyZWdleHAiLCJtQXJyIiwiZXhlYyIsInBhcnNlZCIsInBhcnNlRmxvYXQiLCJwIiwiaW50ZXJuYWxHZXRQYXRoVmFsdWUiLCJwYXRoRGVwdGgiLCJ0ZW1wb3JhcnlWYWx1ZSIsInBhcnQiLCJpbnRlcm5hbFNldFBhdGhWYWx1ZSIsInZhbCIsInRlbXBPYmoiLCJwcm9wTmFtZSIsInByb3BWYWwiLCJuZXh0IiwiZ2V0UGF0aEluZm8iLCJsYXN0IiwiaW5mbyIsInBhcmVudCIsImV4aXN0cyIsImdldFBhdGhWYWx1ZSIsInNldFBhdGhWYWx1ZSIsImZsYWciLCJmbGFncyIsIl9fZmxhZ3MiLCJuZWdhdGUiLCJleHByIiwiZ2xvYmFsIiwiZmFjdG9yeSIsIm1vZHVsZSIsInRoaXMiLCJwcm9taXNlRXhpc3RzIiwiUHJvbWlzZSIsImdsb2JhbE9iamVjdCIsInNlbGYiLCJzeW1ib2xFeGlzdHMiLCJtYXBFeGlzdHMiLCJNYXAiLCJzZXRFeGlzdHMiLCJTZXQiLCJ3ZWFrTWFwRXhpc3RzIiwiV2Vha01hcCIsIndlYWtTZXRFeGlzdHMiLCJXZWFrU2V0IiwiZGF0YVZpZXdFeGlzdHMiLCJEYXRhVmlldyIsInN5bWJvbEl0ZXJhdG9yRXhpc3RzIiwic3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMiLCJ0b1N0cmluZ1RhZyIsInNldEVudHJpZXNFeGlzdHMiLCJlbnRyaWVzIiwibWFwRW50cmllc0V4aXN0cyIsInNldEl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJtYXBJdGVyYXRvclByb3RvdHlwZSIsImFycmF5SXRlcmF0b3JFeGlzdHMiLCJBcnJheSIsImFycmF5SXRlcmF0b3JQcm90b3R5cGUiLCJzdHJpbmdJdGVyYXRvckV4aXN0cyIsIlN0cmluZyIsInN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlIiwidG9TdHJpbmdMZWZ0U2xpY2VMZW5ndGgiLCJ0b1N0cmluZ1JpZ2h0U2xpY2VMZW5ndGgiLCJ0eXBlRGV0ZWN0IiwidHlwZW9mT2JqIiwiaXNBcnJheSIsImxvY2F0aW9uIiwibmF2aWdhdG9yIiwibWltZVR5cGVzIiwicGx1Z2lucyIsIkhUTUxFbGVtZW50IiwidGFnTmFtZSIsInN0cmluZ1RhZyIsIm9ialByb3RvdHlwZSIsIlJlZ0V4cCIsIkRhdGUiLCJ0b1N0cmluZyIsImV4cGVjdFR5cGVzIiwidHlwZXMiLCJmbGFnTXNnIiwic3NmaSIsInQiLCJhcnQiLCJjaGFyQXQiLCJvciIsImpvaW4iLCJvYmpUeXBlIiwidHlwZSIsInNvbWUiLCJleHBlY3RlZCIsInVuZGVmaW5lZCIsImdldEFjdHVhbCIsIl9vYmoiLCJGdW5jdGlvbiIsImZ1bmN0aW9uTmFtZU1hdGNoIiwiZ2V0RnVuY05hbWUiLCJhRnVuYyIsImdldFByb3BlcnRpZXMiLCJvYmplY3QiLCJyZXN1bHQiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiYWRkUHJvcGVydHkiLCJwcm90byIsImdldEVudW1lcmFibGVQcm9wZXJ0aWVzIiwiaW5jbHVkZVN0YWNrIiwidHJ1bmNhdGVUaHJlc2hvbGQiLCJ1c2VQcm94eSIsInByb3h5RXhjbHVkZWRLZXlzIiwiaW5zcGVjdCIsInNob3dIaWRkZW4iLCJkZXB0aCIsImNvbG9ycyIsImN0eCIsInNlZW4iLCJzdHlsaXplIiwiZm9ybWF0VmFsdWUiLCJpc0RPTUVsZW1lbnQiLCJub2RlTmFtZSIsInJlY3Vyc2VUaW1lcyIsImV4cG9ydHMiLCJyZXQiLCJwcmltaXRpdmUiLCJmb3JtYXRQcmltaXRpdmUiLCJvdXRlckhUTUwiLCJ4bWxWZXJzaW9uIiwieG1sU2VyaWFsaXplciIsIlhNTFNlcmlhbGl6ZXIiLCJzZXJpYWxpemVUb1N0cmluZyIsIm5zIiwiY29udGFpbmVyIiwiY3JlYXRlRWxlbWVudE5TIiwiY2xvbmVOb2RlIiwiaHRtbCIsImlubmVySFRNTCIsImVyciIsInZpc2libGVLZXlzIiwibmFtZVN1ZmZpeCIsImlzRXJyb3IiLCJnZXROYW1lIiwiaXNSZWdFeHAiLCJpc0RhdGUiLCJ0b1VUQ1N0cmluZyIsImZvcm1hdEVycm9yIiwiYmFzZSIsInR5cGVkQXJyYXkiLCJicmFjZXMiLCJpc1R5cGVkQXJyYXkiLCJmb3JtYXRBcnJheSIsImZvcm1hdFR5cGVkQXJyYXkiLCJmb3JtYXRQcm9wZXJ0eSIsInBvcCIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwic2ltcGxlIiwiSlNPTiIsInN0cmluZ2lmeSIsIkluZmluaXR5IiwibCIsImhhc093blByb3BlcnR5IiwicHJvcERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJzZXQiLCJzcGxpdCIsImxpbmUiLCJzdWJzdHIiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyIiwiYXIiLCJvYmplY3RUb1N0cmluZyIsInJlIiwiZCIsIm8iLCJvYmpEaXNwbGF5Iiwia3N0ciIsInNwbGljZSIsImdldE1lc3NhZ2UiLCJhY3R1YWwiLCJtc2ciLCJ0cmFuc2ZlckZsYWdzIiwiYXNzZXJ0aW9uIiwiaW5jbHVkZUFsbCIsIkZha2VNYXAiLCJfa2V5IiwiTWF0aCIsInJhbmRvbSIsIm5vdyIsImdldE1hcCIsInNldE1hcCIsImlzRXh0ZW5zaWJsZSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiTWVtb2l6ZU1hcCIsIm1lbW9pemVDb21wYXJlIiwibGVmdEhhbmRPcGVyYW5kIiwicmlnaHRIYW5kT3BlcmFuZCIsIm1lbW9pemVNYXAiLCJpc1ByaW1pdGl2ZSIsImxlZnRIYW5kTWFwIiwibWVtb2l6ZVNldCIsImRlZXBFcXVhbCIsIm9wdGlvbnMiLCJjb21wYXJhdG9yIiwiZXh0ZW5zaXZlRGVlcEVxdWFsIiwic2ltcGxlUmVzdWx0Iiwic2ltcGxlRXF1YWwiLCJtZW1vaXplIiwibWVtb2l6ZVJlc3VsdExlZnQiLCJtZW1vaXplUmVzdWx0UmlnaHQiLCJjb21wYXJhdG9yUmVzdWx0IiwibGVmdEhhbmRUeXBlIiwiZXh0ZW5zaXZlRGVlcEVxdWFsQnlUeXBlIiwidmFsdWVPZiIsIml0ZXJhYmxlRXF1YWwiLCJyZWdleHBFcXVhbCIsImdlbmVyYXRvckVxdWFsIiwiVWludDhBcnJheSIsImJ1ZmZlciIsImVudHJpZXNFcXVhbCIsIm9iamVjdEVxdWFsIiwic2l6ZSIsImxlZnRIYW5kSXRlbXMiLCJyaWdodEhhbmRJdGVtcyIsImdhdGhlckVudHJpZXMiLCJnZXRHZW5lcmF0b3JFbnRyaWVzIiwiaGFzSXRlcmF0b3JGdW5jdGlvbiIsImdldEl0ZXJhdG9yRW50cmllcyIsIml0ZXJhdG9yRXJyb3IiLCJnZW5lcmF0b3IiLCJnZW5lcmF0b3JSZXN1bHQiLCJhY2N1bXVsYXRvciIsImRvbmUiLCJnZXRFbnVtZXJhYmxlS2V5cyIsImtleXNFcXVhbCIsImxlZnRIYW5kS2V5cyIsInJpZ2h0SGFuZEtleXMiLCJsZWZ0SGFuZEVudHJpZXMiLCJyaWdodEhhbmRFbnRyaWVzIiwiaXNQcm94eUVuYWJsZWQiLCJQcm94eSIsIlJlZmxlY3QiLCJnZXR0ZXIiLCJwcm9wZXJ0eUdldHRlciIsIm5ld0Fzc2VydGlvbiIsImNoYWkiLCJBc3NlcnRpb24iLCJmbkxlbmd0aERlc2MiLCJhZGRMZW5ndGhHdWFyZCIsImZuIiwiYXNzZXJ0aW9uTmFtZSIsImlzQ2hhaW5hYmxlIiwiYnVpbHRpbnMiLCJwcm94aWZ5Iiwibm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSIsInByb3h5R2V0dGVyIiwiaGFzIiwic3VnZ2VzdGlvbiIsInN1Z2dlc3Rpb25EaXN0YW5jZSIsImRpc3QiLCJzdHJpbmdEaXN0YW5jZUNhcHBlZCIsInN0ckEiLCJzdHJCIiwiY2FwIiwiYWJzIiwibWVtbyIsImZpbGwiLCJjaCIsIm1pbiIsImFkZE1ldGhvZCIsIm1ldGhvZCIsIm1ldGhvZFdyYXBwZXIiLCJhcHBseSIsIm92ZXJ3cml0ZVByb3BlcnR5IiwiX2dldCIsIl9zdXBlciIsIm92ZXJ3cml0aW5nUHJvcGVydHlHZXR0ZXIiLCJvcmlnTG9ja1NzZmkiLCJvdmVyd3JpdGVNZXRob2QiLCJfbWV0aG9kIiwib3ZlcndyaXRpbmdNZXRob2RXcmFwcGVyIiwiY2FuU2V0UHJvdG90eXBlIiwic2V0UHJvdG90eXBlT2YiLCJ0ZXN0Rm4iLCJleGNsdWRlTmFtZXMiLCJmaWx0ZXIiLCJwcm9wRGVzYyIsImFkZENoYWluYWJsZU1ldGhvZCIsImNoYWluaW5nQmVoYXZpb3IiLCJjaGFpbmFibGVCZWhhdmlvciIsIl9fbWV0aG9kcyIsImNoYWluYWJsZU1ldGhvZEdldHRlciIsImNoYWluYWJsZU1ldGhvZFdyYXBwZXIiLCJhc3NlcnRlck5hbWVzIiwiYXNzZXJ0ZXJOYW1lIiwicGQiLCJvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QiLCJfY2hhaW5pbmdCZWhhdmlvciIsIm92ZXJ3cml0aW5nQ2hhaW5hYmxlTWV0aG9kR2V0dGVyIiwib3ZlcndyaXRpbmdDaGFpbmFibGVNZXRob2RXcmFwcGVyIiwiY29tcGFyZUJ5SW5zcGVjdCIsImEiLCJiIiwiZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bSIsImVudW1lcmFibGUiLCJnZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyIsImNvbXBhdGlibGVJbnN0YW5jZSIsInRocm93biIsImVycm9yTGlrZSIsImNvbXBhdGlibGVDb25zdHJ1Y3RvciIsImNvbXBhdGlibGVNZXNzYWdlIiwiZXJyTWF0Y2hlciIsImNvbXBhcmlzb25TdHJpbmciLCJnZXRGdW5jdGlvbk5hbWUiLCJjb25zdHJ1Y3RvckZuIiwiZ2V0Q29uc3RydWN0b3JOYW1lIiwiY29uc3RydWN0b3JOYW1lIiwidHJpbSIsImlzTmFOIiwiTnVtYmVyIiwicmVxdWlyZSQkMCIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwicmVxdWlyZSQkMyIsInJlcXVpcmUkJDQiLCJyZXF1aXJlJCQ1IiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDciLCJyZXF1aXJlJCQ4IiwicmVxdWlyZSQkOSIsInBhdGh2YWwiLCJyZXF1aXJlJCQxMCIsInJlcXVpcmUkJDExIiwicmVxdWlyZSQkMTIiLCJyZXF1aXJlJCQxMyIsInJlcXVpcmUkJDE0IiwicmVxdWlyZSQkMTUiLCJyZXF1aXJlJCQxNiIsInJlcXVpcmUkJDE3IiwicmVxdWlyZSQkMTgiLCJyZXF1aXJlJCQxOSIsInJlcXVpcmUkJDIwIiwicmVxdWlyZSQkMjEiLCJyZXF1aXJlJCQyMiIsInJlcXVpcmUkJDIzIiwicmVxdWlyZSQkMjQiLCJfY2hhaSIsInV0aWwiLCJsb2NrU3NmaSIsImNvbnNvbGUiLCJ3YXJuIiwiYXNzZXJ0IiwibmVnYXRlTXNnIiwiX2FjdHVhbCIsIm9rIiwiXyIsImNoYWluIiwiYW4iLCJhcnRpY2xlIiwiU2FtZVZhbHVlWmVybyIsImluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yIiwiaW5jbHVkZSIsImlzRGVlcCIsImRlc2NyaXB0b3IiLCJpbmNsdWRlZCIsImlzRXFsIiwiZXFsIiwiZmlyc3RFcnIiLCJudW1FcnJzIiwicHJvcEFzc2VydGlvbiIsImNoZWNrRXJyb3IiLCJpdGVtc0NvdW50IiwiY2hlY2tBcmd1bWVudHMiLCJhc3NlcnRFcXVhbCIsInByZXZMb2NrU3NmaSIsImFzc2VydEVxbCIsImFzc2VydEFib3ZlIiwibiIsImRvTGVuZ3RoIiwibXNnUHJlZml4IiwiblR5cGUiLCJlcnJvck1lc3NhZ2UiLCJzaG91bGRUaHJvdyIsInRvIiwiaGF2ZSIsInByaW50T2JqIiwiYXNzZXJ0TGVhc3QiLCJhc3NlcnRCZWxvdyIsImFzc2VydE1vc3QiLCJzdGFydCIsImZpbmlzaCIsInN0YXJ0VHlwZSIsImZpbmlzaFR5cGUiLCJyYW5nZSIsImFzc2VydEluc3RhbmNlT2YiLCJpc0luc3RhbmNlT2YiLCJUeXBlRXJyb3IiLCJhc3NlcnRQcm9wZXJ0eSIsImlzTmVzdGVkIiwiaXNPd24iLCJuYW1lVHlwZSIsInBhdGhJbmZvIiwiYXNzZXJ0T3duUHJvcGVydHkiLCJhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJhY3R1YWxEZXNjcmlwdG9yIiwiYXNzZXJ0TGVuZ3RoQ2hhaW4iLCJhc3NlcnRMZW5ndGgiLCJhc3NlcnRNYXRjaCIsImlzIiwiYXNzZXJ0S2V5cyIsImtleXNUeXBlIiwiZGVlcFN0ciIsIm1peGVkQXJnc01zZyIsImFueSIsImFsbCIsImV4cGVjdGVkS2V5IiwiYWN0dWFsS2V5IiwiZXZlcnkiLCJhc3NlcnRUaHJvd3MiLCJlcnJNc2dNYXRjaGVyIiwiY2F1Z2h0RXJyIiwiZXZlcnlBcmdJc1VuZGVmaW5lZCIsImV2ZXJ5QXJnSXNEZWZpbmVkIiwiQm9vbGVhbiIsImVycm9yTGlrZUZhaWwiLCJlcnJNc2dNYXRjaGVyRmFpbCIsImVycm9yTGlrZVN0cmluZyIsImlzQ29tcGF0aWJsZUluc3RhbmNlIiwiaXNDb21wYXRpYmxlQ29uc3RydWN0b3IiLCJwbGFjZWhvbGRlciIsImlzQ29tcGF0aWJsZU1lc3NhZ2UiLCJyZXNwb25kVG8iLCJpdHNlbGYiLCJjb250ZXh0Iiwic2F0aXNmeSIsIm1hdGNoZXIiLCJjbG9zZVRvIiwiZGVsdGEiLCJpc1N1YnNldE9mIiwic3Vic2V0Iiwic3VwZXJzZXQiLCJjbXAiLCJjb250YWlucyIsIm9yZGVyZWQiLCJlbGVtIiwiaWR4IiwibWF0Y2hJZHgiLCJlbGVtMiIsImJlIiwic3ViamVjdCIsImZhaWxNc2ciLCJmYWlsTmVnYXRlTXNnIiwib25lT2YiLCJsaXN0IiwiYXNzZXJ0Q2hhbmdlcyIsImluaXRpYWwiLCJmaW5hbCIsIm1zZ09iaiIsImFzc2VydEluY3JlYXNlcyIsImFzc2VydERlY3JlYXNlcyIsImFzc2VydERlbHRhIiwiYmVoYXZpb3IiLCJyZWFsRGVsdGEiLCJleHByZXNzaW9uIiwiaXNTZWFsZWQiLCJpc0Zyb3plbiIsImlzRmluaXRlIiwiZXhwZWN0IiwiZmFpbCIsIm9wZXJhdG9yIiwibG9hZFNob3VsZCIsInNob3VsZEdldHRlciIsInNob3VsZFNldHRlciIsIndyaXRhYmxlIiwic2hvdWxkIiwiZXF1YWwiLCJ2YWwxIiwidmFsMiIsIlRocm93IiwiZXJydCIsImVycnMiLCJleGlzdCIsIm5vdCIsIlNob3VsZCIsImV4cHJlc3MiLCJlcnJtc2ciLCJpc09rIiwiaXNOb3RPayIsImFjdCIsImV4cCIsIm5vdEVxdWFsIiwic3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsImRlZXBTdHJpY3RFcXVhbCIsIm5vdERlZXBFcXVhbCIsImlzQWJvdmUiLCJhYnYiLCJhYm92ZSIsImlzQXRMZWFzdCIsImF0bHN0IiwibGVhc3QiLCJpc0JlbG93IiwiYmx3IiwiYmVsb3ciLCJpc0F0TW9zdCIsImF0bXN0IiwibW9zdCIsImlzVHJ1ZSIsImlzTm90VHJ1ZSIsImlzRmFsc2UiLCJpc05vdEZhbHNlIiwiaXNOdWxsIiwiaXNOb3ROdWxsIiwiTmFOIiwiaXNOb3ROYU4iLCJub3RFeGlzdHMiLCJpc1VuZGVmaW5lZCIsImlzRGVmaW5lZCIsImlzRnVuY3Rpb24iLCJpc05vdEZ1bmN0aW9uIiwiaXNPYmplY3QiLCJpc05vdE9iamVjdCIsImlzTm90QXJyYXkiLCJpc1N0cmluZyIsImlzTm90U3RyaW5nIiwiaXNOdW1iZXIiLCJpc05vdE51bWJlciIsImZpbml0ZSIsImlzQm9vbGVhbiIsImlzTm90Qm9vbGVhbiIsInR5cGVPZiIsIm5vdFR5cGVPZiIsImluc3RhbmNlT2YiLCJub3RJbnN0YW5jZU9mIiwiaW5jIiwibm90SW5jbHVkZSIsImRlZXBJbmNsdWRlIiwiZGVlcCIsIm5vdERlZXBJbmNsdWRlIiwibmVzdGVkSW5jbHVkZSIsIm5lc3RlZCIsIm5vdE5lc3RlZEluY2x1ZGUiLCJkZWVwTmVzdGVkSW5jbHVkZSIsIm5vdERlZXBOZXN0ZWRJbmNsdWRlIiwib3duSW5jbHVkZSIsIm93biIsIm5vdE93bkluY2x1ZGUiLCJkZWVwT3duSW5jbHVkZSIsIm5vdERlZXBPd25JbmNsdWRlIiwibm90TWF0Y2giLCJub3RQcm9wZXJ0eSIsInByb3BlcnR5VmFsIiwibm90UHJvcGVydHlWYWwiLCJkZWVwUHJvcGVydHlWYWwiLCJub3REZWVwUHJvcGVydHlWYWwiLCJvd25Qcm9wZXJ0eSIsIm5vdE93blByb3BlcnR5Iiwib3duUHJvcGVydHlWYWwiLCJub3RPd25Qcm9wZXJ0eVZhbCIsImRlZXBPd25Qcm9wZXJ0eVZhbCIsIm5vdERlZXBPd25Qcm9wZXJ0eVZhbCIsIm5lc3RlZFByb3BlcnR5Iiwibm90TmVzdGVkUHJvcGVydHkiLCJuZXN0ZWRQcm9wZXJ0eVZhbCIsIm5vdE5lc3RlZFByb3BlcnR5VmFsIiwiZGVlcE5lc3RlZFByb3BlcnR5VmFsIiwibm90RGVlcE5lc3RlZFByb3BlcnR5VmFsIiwibGVuZ3RoT2YiLCJoYXNBbnlLZXlzIiwiaGFzQWxsS2V5cyIsImNvbnRhaW5zQWxsS2V5cyIsImNvbnRhaW4iLCJkb2VzTm90SGF2ZUFueUtleXMiLCJkb2VzTm90SGF2ZUFsbEtleXMiLCJoYXNBbnlEZWVwS2V5cyIsImhhc0FsbERlZXBLZXlzIiwiY29udGFpbnNBbGxEZWVwS2V5cyIsImRvZXNOb3RIYXZlQW55RGVlcEtleXMiLCJkb2VzTm90SGF2ZUFsbERlZXBLZXlzIiwidGhyb3dzIiwiYXNzZXJ0RXJyIiwidGhyb3ciLCJkb2VzTm90VGhyb3ciLCJhcHByb3hpbWF0ZWx5Iiwic2FtZU1lbWJlcnMiLCJzZXQxIiwic2V0MiIsInNhbWUiLCJtZW1iZXJzIiwibm90U2FtZU1lbWJlcnMiLCJzYW1lRGVlcE1lbWJlcnMiLCJub3RTYW1lRGVlcE1lbWJlcnMiLCJzYW1lT3JkZXJlZE1lbWJlcnMiLCJub3RTYW1lT3JkZXJlZE1lbWJlcnMiLCJzYW1lRGVlcE9yZGVyZWRNZW1iZXJzIiwibm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyIsImluY2x1ZGVNZW1iZXJzIiwibm90SW5jbHVkZU1lbWJlcnMiLCJpbmNsdWRlRGVlcE1lbWJlcnMiLCJub3RJbmNsdWRlRGVlcE1lbWJlcnMiLCJpbmNsdWRlT3JkZXJlZE1lbWJlcnMiLCJub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMiLCJpbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzIiwibm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyIsImluTGlzdCIsImNoYW5nZXMiLCJjaGFuZ2UiLCJjaGFuZ2VzQnkiLCJ0bXBNc2ciLCJieSIsImRvZXNOb3RDaGFuZ2UiLCJjaGFuZ2VzQnV0Tm90QnkiLCJidXQiLCJpbmNyZWFzZXMiLCJpbmNyZWFzZSIsImluY3JlYXNlc0J5IiwiZG9lc05vdEluY3JlYXNlIiwiaW5jcmVhc2VzQnV0Tm90QnkiLCJkZWNyZWFzZXMiLCJkZWNyZWFzZSIsImRlY3JlYXNlc0J5IiwiZG9lc05vdERlY3JlYXNlIiwiZG9lc05vdERlY3JlYXNlQnkiLCJkZWNyZWFzZXNCdXROb3RCeSIsImlmRXJyb3IiLCJleHRlbnNpYmxlIiwiaXNOb3RFeHRlbnNpYmxlIiwic2VhbGVkIiwiaXNOb3RTZWFsZWQiLCJmcm96ZW4iLCJpc05vdEZyb3plbiIsImlzRW1wdHkiLCJlbXB0eSIsImlzTm90RW1wdHkiLCJhbGlhcyIsImFzIiwidXNlZCIsInVzZSIsImNvcmUiLCJnZXRQcm90b3R5cGVPZkV4aXN0cyIsImlzRG9tIiwiaHRtbEVsZW1lbnRFeGlzdHMiLCJpc0FycmF5RXhpc3RzIiwiY2xlYXIiLCJjbGVhck1hcCIsInZhbHVlcyIsImRlbGV0ZSIsImRlbGV0ZU1hcCIsIkRFRkFVTFRfVE9MRVJBTkNFIiwiYm90aE51bWJlcnMiLCJsZWZ0IiwicmlnaHQiLCJhbG1vc3RFcXVhbCIsInRvbCIsInRvbGVyYW5jZSIsImNoYWlBbG1vc3QiLCJjdXN0b21Ub2xlcmFuY2UiLCJzdGFuZGFyZFRvbGVyYW5jZSIsInV0aWxzIiwib3ZlcnJpZGVBc3NlcnRFcXVhbCIsIm92ZXJyaWRlQXNzZXJ0RXFsIiwidG9sZXJhbmNlT3ZlcnJpZGUiLCJkaXZzIiwicmVzZXREaXZzIiwic3R5bGVzIiwibW9jaGEiLCJzZXR1cCIsInNsb3ciLCJ0aW1lb3V0IiwiX19rYXJtYV9fIiwiYmFpbCIsIiQiLCJhcHBlbmRUbyIsInRvQXJyYXkiLCJkaXYiLCJyZW1vdmVBdHRyaWJ1dGUiLCJ3aWR0aCIsImhlaWdodCIsImJhY2tncm91bmRDb2xvciIsInN1aXRlIiwic3VpdGVUZWFyZG93biIsInJvdW5kIiwibWFyZ2luVG9wIiwiZm9udFNpemUiLCJsaW5lSGVpZ2h0Iiwib3BhY2l0eSIsInBvc2l0aW9uIiwibWFyZ2luQm90dG9tIiwidG9wTWFyZ2luIiwiY29tcHV0ZWRWYWx1ZSIsImdldEF0dHJpYnV0ZSIsImxhc3RFbCIsImNoaWxkcmVuIiwidHJhbnNmb3JtIiwicmVmMSIsInJlZjIiLCJyZWYzIiwicmVmNCIsInJlZjUiLCJyZWY2IiwicmVmNyIsInpJbmRleCIsImluc2VydGVkIiwiY2xhc3NOYW1lMSIsImNs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
